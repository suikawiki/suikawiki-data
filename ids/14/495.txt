
* Data structures

[314] タイマーは、初期状態では動作していません。時間と動作が設定されると、
指定時間経過後に指定の動作が実行されます。既に設定された動作は取り消され、実行されません。

[62] [[要求]]は、次のようなデータ構造です。
[FIG(list members)[
[FIGCAPTION[
[[要求]]
]FIGCAPTION]
:[[要求メソッド]]:バイト列。
:[[要求対象]]:バイト列。
:[[プロトコルの版]]:[CODE[1.1]]。
:[[ヘッダーリスト]]:0個以上の[[ヘッダー]]のリスト。
:[[本体]]:バイト列。初期値は空。
]FIG]

[63] [[応答]]は、次のようなデータ構造です。
[FIG(list members)[
[FIGCAPTION[
[[応答]]
]FIGCAPTION]
:[[プロトコルの版]]:[CODE[0.9]], [CODE[1.0]], [CODE[1.1]] のいずれか。初期値は [CODE[0.9]]。
:[[状態符号]]:[[非負整数]]。初期値は [CODE[200]]。
:[[理由句]]:[[バイト列]]。初期値は [CODE[OK]]。
:[[ヘッダーリスト]]:0個以上の[[ヘッダー]]のリスト。初期値は空。
:[[不完全メッセージ]]フラグ:初期値は未設定。
]FIG]

[252] [[WebSocketフレーム]]は、次のようなデータ構造です。
[FIG(list members)[
[FIGCAPTION[
[[WebSocketフレーム]]
]FIGCAPTION]
:[[FIN]]:0 か 1。
:[[RSV1]]:0 か 1。
:[[RSV2]]:0 か 1。
:[[RSV3]]:0 か 1。
:[[opcode]]:0-15 の[[整数]]。
:[[mask]]:0 か 1。
:長さ:[[非負整数]]。
:マスクキー:4バイトの[[バイト列]]または null。
:データ:[[バイト列]]または[[文字列]]。
]FIG]

[38] 終了は、次のようなデータ構造です。
[FIG(list members)[
:リセット:[[真]]か[[偽]]。既定値は[[偽]]。
:失敗:[[真]]か[[偽]]。
:[[WebSocket]] cleanly:[[真]]か[[偽]]か null。既定値は null。
:[[WebSocket]] [[状態符号]]:[[整数]]か null。既定値は null。
:[[WebSocket]] 理由:[[文字列]]か null。既定値は null。
:[131] 再試行可能性:[[真]]か[[偽]]。既定値は[[偽]]。
]FIG]

;; [257] 再試行可能性が[[真]]であれば、何も考えずに同じ[[要求]]を他の[[接続]]で再送信して構いません。

* Proxies

[609] A [[client]] has a [F[PAC]], which is initially [[null]].
If the client is configured to use a [[PAC file]], it is set to an object
which represents the file.
Otherwise, if the client is configured to use one or more proxy servers,
it is set to a virtual [[PAC file]] which represents those proxy server configurations.

@@
[610] To [DFN[run a PAC file]] with [VAR[pac]] and [VAR[url]], ...

[611] The steps to [[run a PAC file]] return zero or more [[proxy configurations][proxy configuration]].

[612] A [DFN[proxy configuration]] has [DFN[[F[protocol]]]], which is one of:
[CODE[tcp]],
[CODE[unix]],
[CODE[http]],
[CODE[https]],
[CODE[socks4]], and
[CODE[socks5]].

[613] A [[proxy configuration]] whose [F[protocol]] is
[CODE[http]], [CODE[https]], [CODE[socks4]], or [CODE[socks5]] has
[DFN[[F[host]]]], whose value is a [[host]], and
[DFN[[F[port]]]], whose value is an [[integer]] or [[null]].

[614] A [[proxy configuration]] whose [F[protocol]] is
[CODE[unix]] has [DFN[[F[path]]]], whose value is a [[byte string]].

* Domain names

[615] The [DFN[name resolution steps]] for [VAR[host]] are these steps:
[FIG(steps)[
= [616] If [VAR[host]] is a [[domain]]:
== [617] Return the result of applying [[name resolution]] to [VAR[host]].
= [618] Otherwise:
== [619] Return [VAR[host]].
]FIG]

;; [620] These steps return an [[IPv4 address]], an [[IPv6 address]],
or an [[error]].

* Establishing connections

[542] To [DFN[establish a connection to the HTTP server]] of an [[URL record]] [VAR[url]]
from a client [VAR[client]], optionally with the [VAR[ws]] flag, run these steps:
[FIG(steps)[
= [543] If [VAR[client]]'s [F[PAC]] is not [[null]]:
== [544] Let [VAR[proxies]] be the result of [[running a PAC file][run a PAC file]] with 
[VAR[client]]'s [F[PAC]] and [VAR[url]].
= [545] Otherwise:
== [546] Let [VAR[proxies]] be a list whose only member is a [[proxy configuration]]
whose [F[protocol]] is [CODE[tcp]].
= [547] For each [VAR[proxy]] in [VAR[proxies]], in order, run these substeps:
== [548] Set [VAR[request mode]] to ''default''.
== [549] If [VAR[client]] does not support [VAR[proxy]]'s [F[protocol]]:
=== [550] Set [VAR[connection]] to a [[failure]].
== [551] Otherwise, switch by [VAR[proxy]]'s [F[protocol]]:
[FIG(switch)[
: [CODE[tcp]] :
[FIG(steps)[
= [552] Let [VAR[port]] be the [[effective port]] of [VAR[url]].
= [553] Let [VAR[addr]] be the result of applying [[name resolution steps]] 
to [VAR[url]]'s [F[host]].
= [554] If [VAR[addr]] is an [[error]]:
== [555] Set [VAR[connection]] to a [[failure]].
= [556] Otherwise:
== [557] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[addr]] and [VAR[url]]'s [F[port]].
== [558] Set [VAR[connection]] to the result of 
[[establishing a TCP connection][establish a TCP connection]]
to [VAR[addr]] and [VAR[port]].
]FIG]
: [CODE[unix]] :
[FIG(steps)[
= [559] Set [VAR[connection]] to the result of
[[establishing a UNIX socket domain connection][下位層の接続]]
with [VAR[protocol]]'s [F[path]].
]FIG]
: [CODE[http]] or [CODE[https]] :
[FIG(steps)[
= [560] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[url]]'s [F[host]] and [VAR[url]]'s [F[port]].
= [561] Let [VAR[proxy port]] be [VAR[proxy]]'s [F[port]].
= [562] If [VAR[proxy port]] is [[null]]:
== [563] If [VAR[proxy]]'s [F[protocol]] is [CODE[http]], set [VAR[proxy port]] to [[80]].
== [564] If [VAR[proxy]]'s [F[protocol]] is [CODE[https]], set [VAR[proxy port]] to [[443]].
= [565] Let [VAR[proxy addr]] be the result of applying [[name resolution steps]] 
to [VAR[proxy]]'s [F[host]].
= [566] If [VAR[proxy addr]] is an [[error]]:
== [567] Set [VAR[connection]] to a [[failure]].
= [568] Otherwise:
== [569] Set [VAR[connection]] to the result of 
[[establishing a TCP connection][establish a TCP connection]]
to [VAR[proxy addr]] and [VAR[proxy port]].
= [570] If [VAR[connection]] is ''not'' a [[failure]] and
[VAR[proxy]]'s [F[protocol]] is [CODE[https]]:
== [571] Set [VAR[connection]] to the result of running the [[TLS steps]] for
[VAR[connection]] and [VAR[proxy]]'s [F[host]].
= [572] If [VAR[connection]] is ''not'' a [[failure]] and
[VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[https]]:
== [573] If [VAR[url]]'s [F[port]] is [[null]]:
=== [574] Let [VAR[target]] be [VAR[url]]'s [F[host]].
== [575] Otherwise:
=== [576] Let [VAR[target]] be [VAR[url]]'s [F[host]], followed by [CODE[:]],
followed by [VAR[url]]'s [F[port]], [[serialized][serialize an integer]].
== [577] Let [VAR[http]] be a new [[HTTP client][HTTP接続の処理]] whose
[F[transport]] is [VAR[connection]].
== [578] Set [VAR[connection]] to the result of
[[establishing an HTTP [CODE(HTTP)[CONNECT]] connection][下位層の接続]]
with [VAR[http]] and [VAR[target]].
@@ and proxy credentials
== [579] If [VAR[connection]] is a [[failure]] whose HTTP response's [F[status]] is
[CODE[407]]:
=== 
@@ Show proxy auth dialog
= [580] Otherwise:
== [581] Set [VAR[request mode]] to ''HTTP proxy''.
]FIG]
: [CODE[socks4]] :
[FIG(steps)[
= [582] Let [VAR[port]] be the [[effective port]] of [VAR[url]].
= [583] Let [VAR[addr]] be the result of applying [[name resolution steps]] 
to [VAR[url]]'s [F[host]].
= [584] If [VAR[addr]] is ''not'' an [[IPv4 address]]:
== [585] Set [VAR[connection]] to a [[failure]].
= [586] Otherwise:
== [587] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[addr]] and [VAR[url]]'s [F[port]].
== [588] Let [VAR[proxy port]] be [VAR[proxy]]'s [F[port]].
== [589] If [VAR[proxy port]] is [[null]], set [VAR[proxy port]] to [[1080]].
== [590] Let [VAR[proxy addr]] be the result of applying [[name resolution steps]] 
to [VAR[proxy]]'s [F[host]].
== [591] Set [VAR[connection]] to the result of 
[[establishing a TCP connection][establish a TCP connection]]
to [VAR[proxy addr]] and [VAR[proxy port]].
== [592] Set [VAR[connection]] to the result of
[[establishing a SOCKS4 connection][下位層の接続]]
with [VAR[connection]], [VAR[addr]], and [VAR[port]].
]FIG]
: [CODE[socks5]] :
[FIG(steps)[
= [593] Let [VAR[port]] be the [[effective port]] of [VAR[url]].
= [594] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[url]]'s [F[host]] and [VAR[url]]'s [F[port]].
= [595] Let [VAR[proxy port]] be [VAR[proxy]]'s [F[port]].
= [597] If [VAR[proxy port]] is [[null]], set [VAR[proxy port]] to [[1080]].
= [596] Let [VAR[proxy addr]] be the result of applying [[name resolution steps]] 
to [VAR[proxy]]'s [F[host]].
= [598] Set [VAR[connection]] to the result of 
[[establishing a TCP connection][establish a TCP connection]]
to [VAR[proxy addr]] and [VAR[proxy port]].
= [599] Set [VAR[connection]] to the result of
[[establishing a SOCKS5 connection][下位層の接続]]
with [VAR[connection]], [VAR[url]]'s [F[host]], and [VAR[port]].
]FIG]
]FIG]
== [600] If [VAR[connection]] is not a [[failure]]:
=== [601] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[https]]:
==== [602] Set [VAR[connection]] to the result of running the [[TLS steps]] for
[VAR[connection]] and [VAR[url]]'s [F[host]].
== [603] If [VAR[connection]] is not a [[failure]]:
=== [604] Set [VAR[connection]]'s [F[request mode]] to [VAR[request mode]].
=== [605] Return [VAR[connection]] and abort these steps.
= [606] Return a [[failure]].
]FIG]

@@
[607] To [DFN[wait for other connections]] with [VAR[host]] and [VAR[port]],
run steps in [[WebSocket接続を得る]].

[640] [[接続]]の端点は、その種類に依存した[[接続]]確立の処理によって作成されます。
[[接続]]の確立完了時に、接続の種類に依存した情報を[[アプリケーション]]に引渡します。

[641] [[接続]]の端点は、次の状態を持ちます。
[FIG(list members)[
:[VAR[種別]]:「サーバー」または「クライアント」。
:[VAR[送信閉じ済みフラグ]]:初期状態では未設定。
:[VAR[受信閉じ済みフラグ]]:初期状態では未設定。
:[VAR[送信待ちバッファー]]:初期状態では空のリスト。
]FIG]

[608] A [[connection]] has [DFN[[F[request mode]]]], which is ''default'' or ''HTTP proxy''.
If the [F[request mode]] of a [[connection]] is ''HTTP proxy'',
a [[request]] has to be sent over the [[connection]] as an [[HTTP request]]
whose [[request target]] is an [[absolute URL]].

[642] [[アプリケーション]]は、[[接続]]の端点に次の指示を行えます。
[FIG(list)[
- [[バイト]]の送信の指示
- 正常終了の送信の指示
- 中断の指示
- credentials の送信の指示
]FIG]

[643] [[バイト]]の送信の指示は、送信する[[バイト]] (0-255 のいずれかの値)と、
[[緊急データ]]か否かのフラグ (既定値は未設定。)
を[[引数]]とし、次のように処理します。
[FIG(steps)[
= [644] [VAR[送信閉じ済みフラグ]]が設定されていれば、[[例外]]を投げて停止します。
= [645] [VAR[送信待ちバッファー]]が満杯なら、[[例外]]を投げて停止します。
= [646] [[緊急データ]]フラグが設定されていて、
接続の種類が[[緊急データ]]に対応していないものなら、
[[例外]]を投げて停止します。
= [647] [VAR[送信待ちバッファー]]の末尾に、
引数の[[バイト]]、
引数の[[緊急データ]]か否かのフラグ、
[[約束]]の組を追加します。
= [648] 追加した[[約束]]を返します。
]FIG]

;; [649] 返された[[約束]]は、[[バイト]]が送信された際に[[解決]]されます。

[650] [[バイト列]]を送信するとは、当該[[バイト列]]について先頭の[[バイト]]から順に[[バイト]]の送信の指示を行い、最後の[[バイト]]が返した[[約束]]を返す
(空バイト列なら[[解決]]済みの[[約束]]を返す) ことをいいます。

[651] 正常終了の送信の指示は、次のように処理します。
[FIG(steps)[
= [652] [VAR[送信閉じ済みフラグ]]が設定されていれば、[[例外]]を投げて停止します。
= [653] [VAR[送信閉じ済みフラグ]]を設定します。
= [654] [[接続]]の種類に応じた処理を行います。
]FIG]

[655] 中断の指示は、次のように処理します。
[FIG(steps)[
= [656] [VAR[送信閉じ済みフラグ]]と[VAR[受信閉じ済みフラグ]]の両方が設定されていれば、
[[例外]]を投げて停止します。
= [657] [VAR[送信閉じ済みフラグ]]を設定します。
= [658] [VAR[受信閉じ済みフラグ]]を設定します。
= [659] [VAR[送信待ちバッファー]]の先頭の項目から順に、
[[約束]]を[[拒絶]]していきます。
= [660] [[接続]]の種類に応じた処理を行います。
= [661] 中断の通知を行います。リセットフラグを設定します。
]FIG]

[662] [[credentials]] の送信の指示は、
接続の種類に応じた処理を実行します。そのようなものがなければ、
[[例外]]を投げます。
なお引数として、接続の種類に応じた [[credentials]] を受け取ります。

[663] [[接続]]の端点は、[[アプリケーション]]に対して次の通知を行います。
[FIG(list)[
- [664] [[バイト]]の受信の通知
[FIG(list members)[
:[[バイト]]:受信した[[バイト]]。 0-255 のいずれかの値。
:[[緊急データ]]フラグ: [[TCP]] [[緊急データ]]か否か。既定値は[[偽]]。
]FIG]
- [665] 正常終了の受信の通知
- [666] 中断の通知
[FIG(list members)[
:[[リセット]]フラグ:[[TCP]] [CODE[[[RST]]]] 相当のものであるか否か。既定値は[[偽]]。
]FIG]
- [667] 警告の通知
- [668] challenge の受信の通知
[FIG(list members)[
:接続:認証を行う接続の端点。
:[[challenge]]:プロトコル依存の [[challenge]] データ。
]FIG]
]FIG]

[669] [[接続]]の種類に依存した方法で次の[[バイト]]を送信可能であると判断したら、
次のようにします。
[FIG(steps)[
= [670] [VAR[送信待ちバッファー]]が空なら、ここで停止します。
= [671] [VAR[送信待ちバッファー]]の先頭の項目を取得し、バッファーからは削除します。
= [672] [[接続]]の種類に依存した方法で取得した項目の[[バイト]]を送信します。
(あれば) [[緊急データ]]フラグを引渡します。
= [673] 取得した項目の[[約束]]を[[解決]]します。
]FIG]

** TCP

[622] The [DFN[effective port]] of [VAR[url]] is the value returned by these steps:
[FIG(steps)[
= [623] Let [VAR[port]] be [VAR[url]]'s [F[port][URL's port]].
= [624] If [VAR[port]] is [[null]]:
== [625] Set [VAR[port]] to the value determined by the [VAR[url]]'s [F[scheme][URL scheme]]:
[FIG(switch)[
: [CODE(URI)@en[ftp]] : [[21]]
: [CODE(URI)@en[http]] : [[80]]
: [CODE(URI)@en[https]] : [[443]]
]FIG]
= [626] Return [VAR[port]].
]FIG]

[627] To [DFN[establish a TCP connection]] to [VAR[addr]] and [VAR[port]],
run these steps:
[FIG(steps)[
= [628] Let [VAR[connection]] be a [[TCP]] connection to [VAR[addr]] and [VAR[port]].
= [629] If [VAR[connection]] is ''not'' a [[failure]]:
== [630] Disable the [CODE[SO_OOBINLINE]] option of [VAR[connection]].
== [631] Enable the [CODE[SO_NODELAY]] option of [VAR[connection]].
== [632] Run the [[TCP keep alive steps]] for [VAR[connection]].
= [633] Return [VAR[connection]].
]FIG]

[634] The [DFN[TCP keep alive steps]] for [VAR[connection]] is a set of implementation
dependent steps.  An example of such steps is:
[FIG(steps)[
= [635] Enable the [CODE[SO_KEEPALIVE]] option of [VAR[connection]].
= [636] Set [CODE[TCP_KEEPIDLE]] option of [VAR[connection]] to 45 (seconds).
= [637] Set [CODE[TCP_KEEPINTVL]] option of [VAR[connection]] to 45 (seconds).
]FIG]

[674] [[接続]]の確立は、送受信者の [[IPアドレス]]と[[ポート番号]]を決定し
[[handshake]] を適切に行い、正常に完了することによります。
端点における[[フロー制御]]その他のオプションも適切に設定します。

[675] 確立の完了時に、相手の [[IPアドレス]]と[[ポート番号]]を[[アプリケーション]]に通知します。

[676] [[TCP]] の[[セグメント]]を受信したら、次のようにします。
[FIG(steps)[
= [677] [[TCP]] に従い処理し、不適切と判断すればここで停止します。
= [678] [CODE[[[RST]]]] フラグが設定されていれば、
== [679] [VAR[送信閉じ済みフラグ]]を設定します。
== [680] [VAR[受信閉じ済みフラグ]]を設定します。
== [681] 中断を通知します。リセットフラグを設定します。
= [682] データの各[[バイト]]について、順に、
== [683] [[バイト]]の受信を通知します。当該[[バイト]]の値を渡します。
[[緊急ポインター]]が本[[バイト]]を指していれば、[[緊急データ]]フラグも設定します。
= [684] [CODE[[[FIN]]]] フラグが設定されていれば、
== [685] [VAR[受信閉じ済みフラグ]]を設定します。
== [686] 正常終了の受信を通知します。
]FIG]

[687] [[タイムアウト]]その他の理由で[[接続]]が利用できないことを検知したら、
次のようにします。
[FIG(steps)[
= [688] [VAR[送信閉じ済みフラグ]]を設定します。
= [689] [VAR[受信閉じ済みフラグ]]を設定します。
= [690] 中断を通知します。
]FIG]

[691] [[バイト]]を送信できるかどうかは、[[フロー制御]]、[[輻輳制御]]その他の状況により決定します。

[692] [[バイト]]の送信は、次のようにします。
[FIG(steps)[
= [693] [[緊急データ]]フラグが設定されていれば、
== [694] 指定された[[バイト]]をデータとして含み、[[緊急ポインター]]が当該[[バイト]]を指す[[セグメント]]を送信することにします。
= [695] それ以外なら、
== [696] 指定された[[バイト]]をデータとして含む[[セグメント]]を送信することにします。
]FIG]

;; [697] 実際の送信時には、前後の[[バイト]]とまとめた[[セグメント]]で送信されたり、
必要に応じて[[再送]]されたりします。

[698] [[緊急データ]]に対応しています。

[699] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [700] [CODE[[[FIN]]]] フラグが設定された[[セグメント]]を送信することにします。
]FIG]

[701] 中断の指示があれば、次のようにします。
[FIG(steps)[
= [702] 必要に応じて [CODE[[[FIN]]]] フラグが設定された[[セグメント]]を送信することにします。
= [703] [[TCP]] で受信したデータの処理を以後行わないことにします。
]FIG]

** TLS

[638] The [DFN[TLS steps]] for [VAR[connection]] and [VAR[url]] is:
[FIG(steps)[
@@
]FIG]

[704] 接続の確立は、指定された[VAR[下位の[[接続]]]]において、 [[TLS handshake]]
を適切に行い、正常に完了することによります。

;; [705] [[警告]]を受信していれば、アプリケーションにその旨を通知します。

[706] 確立の完了時に、次の情報をアプリケーションに引渡します。
[FIG(list)[
- [[TLS]] の版
- 選択された [[cipher suite]] と引数
- ([VAR[種別]]が「サーバー」の場合) [[SNI]] ホスト名
- 選択された [[ALPN]] プロトコル
- 相手の[[証明書]]と[[中間証明書]] (あれば)
]FIG]

[707] [VAR[下位の接続]]からバイトを受信したら、[[バイト]]と[[緊急データ]]フラグを [[TLS]] に従い処理します。

[708] [[closure alert]] を受信したら、次のようにします。
[FIG(steps)[
= [709] 正常終了の受信を通知します。
]FIG]

[710] [[error alert]] を受信したら、次のようにします。
[FIG(steps)[
= [711] [[alert level]] が[[警告]]なら、
== [712] 警告を通知します。
= [713] それ以外なら、
== [714] [VAR[送信閉じ済みフラグ]]を設定します。
== [715] [VAR[受信閉じ済みフラグ]]を設定します。
== [716] 中断を通知します。リセットフラグを設定します。
]FIG]

[717] [VAR[下位の接続]]から正常終了を受信したら、次のようにします。
[FIG(steps)[
= [718] [VAR[受信閉じ済みフラグ]]が設定されていなければ、
== [719] [VAR[受信閉じ済みフラグ]]を設定します。
== [720] 正常終了の受信を通知します。
]FIG]

[721] [VAR[下位の接続]]から中断を受信したら、次のようにします。
[FIG(steps)[
= [722] [VAR[受信閉じ済みフラグ]]と[VAR[送信閉じ済みフラグ]]のどちらかが未設定なら、
== [723] [VAR[送信閉じ済みフラグ]]を設定します。
== [724] [VAR[受信閉じ済みフラグ]]を設定します。
== [725] 中断を通知します。
]FIG]

[726] バイトの送信は、 [[TLS]] に従い処理します。

[727] バイトを送信できるかどうかは、新たなバイトを入力として [[TLS]]
で処理できるかどうかとします。

[728] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [729] [[closure alert]] を送信します。
= [730] [VAR[下位の接続]]に正常終了の送信を指示します。
]FIG]

[731] 中断の指示があれば、[VAR[下位の接続]]に中断を指示します。

[732] [[TLS]] の処理によりバイト列を送信するべきときは、
[VAR[下位の接続]]で指定されたバイト列を送信します。

[733] [[TLS]] の最初の [[handshake]] 
または[[再折衝]]により[[クライアント証明書]]を要求された時は、
次のようにします。
[FIG(steps)[
= [734] challenge の受信を通知します。
[FIG(list members)[
:接続:この[[接続]]。
:challenge:(サーバーなら) [CODE(HTTP)@en[[[ClientHello]]]]
や (クライアントなら) [CODE(HTTP)@en[[[CertificateRequest]]]]
に含まれる情報のうち必要なもの。
]FIG]
]FIG]

[735] credentials の送信は、次のようにします。
[FIG(steps)[
= [736] [[TLS]] が [[credentials]] を受け付ける状態でなければ、例外を投げて停止します。
= [737] そうでなければ、与えられた [[credentials]] を [[TLS]] の処理に引渡します。
]FIG]

** HTTP/1 [CODE(HTTP)@en[CONNECT]] の場合

[738] 状態として、次のものを持ちます。
[FIG(list members)[
:[VAR[HTTP]]:[[HTTP接続]]の[[クライアント]]。[[HTTP接続の処理]]参照。
:[VAR[接続確立済みフラグ]]:初期値は未設定。
]FIG]

[739] 接続の確立は、[VAR[target]] について、次のようにします。
[FIG(steps)[
= [740] [VAR[種別]]が「クライアント」の場合、
== [741] [VAR[HTTP]] を、引数として受け取った[[HTTP接続]]の[[クライアント]]に設定します。
== [742] [VAR[HTTP]] に、[[要求]]を送信します。ただし[[クライアント]]が適切な状態になく[[要求]]を送信できないときは、
[[例外]]を投げて停止します。
[FIG(list members)[
: [F[method][request method]] : [CODE[CONNECT]]
: [F[request target]] : [VAR[target]]
: [F[header list]] :
[FIG(list members)[
: [CODE[Host]] : [VAR[target]]
: [CODE[Proxy-Connection]] : [CODE[keep-alive]]
: [CODE[User-Agent]] : [[default `[CODE[User-Agent]]` value]]
]FIG]
]FIG]
== [743] [VAR[HTTP]] からの通知を、次のように処理します。
=== [744] [[要求]]のヘッダー受信完了の通知の場合、
==-= [745] 応答の状態符号が [CODE(HTTP)[[[200]]]] なら、
==-== [746] [VAR[接続確立済みフラグ]]を設定します。
==-== [747] 接続が確立されたとします。
==-= [748] それ以外なら、
==-== [749] 接続の確立は失敗とします。
=== [750] [[要求]]のデータ受信の通知の場合、
==== [751] [VAR[接続確立済みフラグ]]が設定されていれば、
===-= [752] データの各バイトについて、順に、
===-== [753] バイトの受信を通知します。当該バイトの値を渡します。
=== [754] [[要求]]のデータ終了の通知の場合、
==== [755] [VAR[接続確立済みフラグ]]が設定されていれば、
===-= [756] [VAR[受信閉じ済みフラグ]]を設定します。
===-= [757] 正常終了の受信を通知します。
=== [758] [[要求]]の完了の通知の場合、
==-= [759] 終了の失敗フラグが設定されていれば、
==-== [760] [VAR[接続確立済みフラグ]]が設定されていれば、
==-=== [761] [VAR[送信閉じ済みフラグ]]を設定します。
==-=== [762] [VAR[受信閉じ済みフラグ]]を設定します。
==-=== [763] 中断を通知します。
==-== [764] それ以外なら、
==-=== [765] 接続の確立は失敗とします。
= [766] [VAR[種別]]が「サーバー」の場合、
==
@@
]FIG]

[767] バイトは常に送信可能とします。

[768] バイトの送信は、次のようにします。
[FIG(steps)[
= [769] [VAR[HTTP]] でトンネルに指定されたバイトを送信します。
]FIG]

[770] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [771] [VAR[HTTP]] に接続の正常終了を指示します。
]FIG]

[772] 中断の指示があれば、次のようにします。
[FIG(steps)[
= [773] [VAR[HTTP]] に中断を指示します。
]FIG]

** HTTP/2 [CODE[CONNECT]]

@@

** SOCKS4 の場合

[774] 接続の確立は、次のようにします。下位層の接続[VAR[接続]]、
宛先[[IPv4アドレス]][VAR[ホスト]]、宛先[[ポート]]番号[VAR[ポート]]を引数として受け取ります。
[FIG(steps)[
= [775] [VAR[種別]]が「クライアント」の場合、
== [776] [VAR[接続]]で 0x04 0x01 [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] [VAR[a[SUB[1]]]] [VAR[a[SUB[2]]]]
[VAR[a[SUB[3]]]] [VAR[a[SUB[4]]]] 0x00 を送信します。
==- [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] は[VAR[ポート]]を[[16ビット符号無し整数]]
([[ネットワークバイト順]]) としたものです。
==- [VAR[a[SUB[1]]]] [VAR[a[SUB[2]]]] [VAR[a[SUB[3]]]] [VAR[a[SUB[4]]]]
は[VAR[ホスト]]を[[32ビット符号無し整数]] ([[ネットワークバイト順]]) としたものです。
== [777] [VAR[接続]]から8バイト受信するのを最大30s待ちます。
== [778] 受信した最初の2バイトが 0x00 0x5A でなければ、
=== [779] [VAR[接続]]の中断を指示します。
=== [780] 接続の確立を失敗とします。ここで停止します。
== [781] 接続を確立できたとします。
= [782] [VAR[種別]]が「サーバー」の場合、
== 
@@
]FIG]

[783] 接続確立後は、指示は[VAR[接続]]への指示とし、
[VAR[接続]]からの通知があればそれを通知します。

** SOCKS5 の場合

[784] 接続の確立は、次のようにします。下位層の接続[VAR[接続]]、
宛先[[ドメイン名]] (長さ255[[以下]]の[[バイト列]]) または
[[IPv4アドレス]]または[[IPv6アドレス]][VAR[ホスト]]、
宛先[[ポート]]番号[VAR[ポート]]を引数として受け取ります。
[FIG(steps)[
= [785] [VAR[種別]]が「クライアント」の場合、
== [786] [VAR[接続]]で 0x05 0x01 0x00 を送信します。
== [787] [VAR[接続]]から2バイト受信するのを最大30s待ちます。
== [788] 受信したのが 0x05 0x00 でなければ、
=== [789] [VAR[接続]]の中断を指示します。
=== [790] 接続の確立を失敗とします。ここで停止します。
== [791] [VAR[接続]]で 0x05 0x01 0x00 [VAR[A]] [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]]
を送信します。
==- [VAR[A]] は、
==-= [VAR[ホスト]]が[[ドメイン名]]の場合、[VAR[ホスト]]の前に[VAR[ホスト]]のバイト数を[[8ビット符号無し整数]]としたものです。
==-= [VAR[ホスト]]が[[IPv4アドレス]]の場合、[VAR[ホスト]]を[[32ビット符号無し整数]] ([[ネットワークバイト順]]) としたものです。
==-= [VAR[ホスト]]が[[IPv6アドレス]]の場合、[VAR[ホスト]]を16バイトのバイト列としたものです。
==- [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] は[VAR[ポート]]を[[16ビット符号無し整数]]
([[ネットワークバイト順]]) としたものです。
== [792] [VAR[接続]]から5バイト受信するのを最大30s待ちます。
== [793] 受信した最初の3バイトが 0x05 0x00 0x00 でないか、
第4バイトが 0x01, 0x03, 0x04 のいずれでもないか、
5バイトに満たなければ、
=== [794] [VAR[接続]]の中断を指示します。
=== [795] 接続の確立を失敗とします。ここで停止します。
== [796] 第4バイトが 0x01 なら、[VAR[接続]]から5バイト受信するのを最大30s待ちます。
== [797] 第4バイトが 0x03 なら、第5バイトを[[8ビット符号無し整数]]として解釈し、
[VAR[接続]]からそのバイト数 + 2 バイト分受信するのを最大30s待ちます。
== [798] 第4バイトが 0x04 なら、[VAR[接続]]から17バイト受信するのを最大30s待ちます。
== [799] 得られたのが指定のバイト数に満たなければ、
=== [800] [VAR[接続]]の中断を指示します。
=== [801] 接続の確立を失敗とします。ここで停止します。
== [802] 接続を確立できたとします。
= [803] [VAR[種別]]が「サーバー」の場合、
== 
@@
]FIG]

[804] 接続確立後は、指示は[VAR[接続]]への指示とし、
[VAR[接続]]からの通知があればそれを通知します。

** UNIX domain socket の場合

[805] 接続の確立は、次のようにします。
[FIG(steps)[
= [806] [VAR[種別]]が「クライアント」の場合、
== [807] [[ソケットAPI]]を使って新たに接続します。
[[アドレス族]]は [CODE[[[AF_UNIX]]]]、パス名は引数で指定された[[パス]]、
[[ソケット型]]は [CODE[[[SOCK_STREAM]]]] とします。
== [808] 接続に失敗すれば、確立は失敗とします。そうでなければ、確立できたとします。
= [809] [VAR[種別]]が「サーバー」の場合、
@@
]FIG]

[810] バイトが送信可能かどうかは、 [CODE[[[send]]]] によりバイト列を送信できるかどうかとします。

[811] バイトの送信は、 [CODE[[[send]]]] によります。

[812] 正常終了の送信の指示があれば、 [CODE[[[shutdown]]]] [CODE[[[SHUT_WR]]]] を実行します。

[813] 中断の指示があれば、 [CODE[[[shutdown]]]] [CODE[[[SHUT_RDWR]]]] を実行します。

[814]  [CODE[[[recv]]]] によりバイト列を受信したら、
各バイトを順に、バイトの受信を通知します。

[815] [CODE[[[recv]]]] で何も受信しなくなれば、
[VAR[送信閉じ済みフラグ]]を設定し、正常終了の受信を通知します。

[816] [CODE[[[send]]]] や [CODE[[[recv]]]] でエラーが発生したら、
[VAR[送信閉じ済みフラグ]]と[VAR[受信閉じ済みフラグ]]を設定し、
中断を通知します。

* HTTP clients

[34] [[クライアント]]は、次の内部状態を持ちます。
[FIG(list members)[
:[VAR[種別]]:[[クライアント]]。
:[VAR[接続]]:[[下位層の接続]]の端点。
:[VAR[状態]]:後述の状態遷移における状態のいずれか。初期値は「初期」。
:[VAR[要求の送信状態]]: 未送信、送信中、送信済みのいずれか。初期値は未送信。
:[VAR[要求締め切り]]フラグ:初期値は未設定です。
:[VAR[要求]]:[[要求]]か null。初期値は null です。
:[VAR[応答]]:[[応答]]か null。初期値は null です。
:[VAR[一時バッファー]]:バイト列。初期値は空。
:[VAR[最後のヘッダー]]:ヘッダーか null
:[VAR[残り長さ]]:[[非負整数]]か null か「chunked」かエラー。
:[VAR[応答受信済み]]:[[boolean]]。初期値は[[偽]]。
:[VAR[要求の転送済]]:[[非負整数]]。初期値は 0。
:[VAR[要求の処理完了]]:[[Promise]] か null。初期値は null。
:[VAR[WebSocket接続の状態]]:[CODE[CONNECTING]]、[CODE[OPEN]]、
[CODE[CLOSING]]、[CODE[CLOSED]]、null のいずれか。初期値は null。
:[VAR[フレーム]]:[[WebSocketフレーム]]または null。初期値は null。
:[VAR[先頭フレーム]]:[[WebSocketフレーム]]または null。初期値は null。
:[VAR[送信待ちフレーム]]:[[WebSocketフレーム]]または null。初期値は null。
:[VAR[終了]]:終了または null。初期値は null。
:[VAR[切断タイマー]]:タイマー。
]FIG]

** アプリケーションからの指示

[49] [[接続]]に対して[[アプリケーション]]は、
[FIG(list)[
- [[要求]]の送信 (>>42)
- [[WebSocket]] メッセージ送信 (>>259)
- ping 送信 (>>260)
- [[トンネル]]への[[バイト]]送信 (>>107)
- [[接続]]の正常終了 (>>50)
- 接続の中断 (>>52)
]FIG]
... を指示できます。

[42] 要求の送信は、次のようにします。この処理は、[[要求]]である[VAR[送信する要求]]と、
[VAR[WebSocket]] フラグを入力として受け取ります。
[FIG(steps)[
= [90] 前提として、[VAR[送信する要求]]は次の条件を満たす必要があります。
[FIG(list)[
- [93] [[要求メソッド]]が空ではない。
- [94] [[要求メソッド]]に 0x09, 0x0A, 0x0D, 0x20 が含まれない。
- [95] [[要求対象]]が空ではない。
- [96] [[要求対象]]に 0x0A, 0x0D が含まれない。
- [97] [[要求対象]]の先頭と末尾が 0x09, 0x20 でない。
- [99] すべての[[ヘッダー]]について、
-- [100] 名前に 0x3A が含まれない。
-- [101] 名前が空ではない。
-- [103] 名前に 0x0A, 0x0D が含まれない。
-- [102] 名前の先頭と末尾が 0x09, 0x20 でない。
-- [104] 値に 0x0A, 0x0D が含まれない。
-- [105] 値の先頭と末尾が 0x09, 0x20 でない。
- [298] [CODE(HTTP)@en[[[Transfer-Encoding:]]]] [[ヘッダー]]がない。
- [91] [VAR[WebSocket]] フラグが設定されていれば、
-- [92] [[本体]]が空である。
- [261] [[本体]]が空の場合、
-- [262] [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]がないか、値が [CODE[0]] である。
- [267] [[本体]]が空でない場合、
-- [263] [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]があって、値が[[本体]]のバイト数である。
]FIG]
= [74] [VAR[要求締め切り]]フラグが設定されているなら、
== [75] エラーを返し、ここで停止します。
= [58] [VAR[状態]]が「初期」か「要求待ち」でなければ、
== [35] エラーを返し、ここで停止します。
= [61] [VAR[要求]]を、[VAR[送信する要求]]に設定します。
= [64] [VAR[応答]]を、新しい[[応答]]に設定します。
= [60] [VAR[一時バッファー]]を、空バイト列に設定します。
= [59] [VAR[状態]]を、「応答前」に設定します。
= [77] [VAR[要求]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
== [78] [VAR[要求締め切り]]フラグを設定します。
= [98] [VAR[WebSocket]] フラグが設定されていれば、
== [258] [VAR[WebSocket接続の状態]]を、 [CODE[[[CONNECTING]]]] に設定します。
== [265] 16バイトの無作為に決定したバイト列を [[RFC 4648]] [[Base64]]
[[符号化]]したものを[VAR[要求]]の [CODE(HTTP)@en[[[Sec-WebSocket-Key:]]]]
[[ヘッダー]]として追加します。
== [266] [VAR[要求]]に [CODE(HTTP)@en[[[Sec-WebSocket-Version:]]]]
[[ヘッダー]]を値 [CODE[[[13]]]] で追加します。
== [264] 
@@ 拡張
= [57] [VAR[要求の送信状態]]を、送信中に設定します。
= [45] [VAR[要求の処理完了]]を、新しい [[Promise]] に設定します。
= [48] [VAR[要求の処理完了]]を返します。
= [46] [[並列に]]、[VAR[要求]]の送信を行います。
]FIG]

[25] [VAR[要求]]の送信は、次のようにします。
[FIG(steps)[
= [47] [[HTTP/1.1]] に従い[VAR[要求]]の[[ヘッダー部]] (空行の [CODE[CRLF]] まで)
を表す[[バイト列]]の各[[バイト]]を順に、
== [VAR[接続]]で[[バイト]]の送信を指示します。
== エラーが返されたら、ここで停止します。
= [1] [VAR[要求]]の[[メッセージ本体]]が存在する場合、各[[バイト]]を順に、
== [VAR[接続]]で[[バイト]]の送信を指示します。
== エラーが返されたら、ここで停止します。
== [VAR[要求の転送済]]を、1だけ大きな値に設定します。
== [VAR[要求]]について要求の本体の一部の送信を通知して構いません。
= [VAR[要求の送信状態]]を、送信済みに設定します。
= [VAR[要求]]について要求の送信完了を通知します。
= [520] [VAR[状態]]が「要求送信中」なら、
== [521] 次の要求に進みます。
]FIG]

[259] [[WebSocket]] メッセージ送信は、次のようにします。
この処理は、[[バイト列]]である[VAR[データ]]と、[[テキスト]]または[[バイナリー]]のいずれかの[VAR[種別]]を引数として受け取ります。
[FIG(steps)[
= [278] 前提として、次の条件を満たす必要があります。
[FIG(list)[
- [289] [VAR[データ]]の長さは 2[SUP[63]] [[未満]]かつ実装の扱える範囲内である
]FIG]
= [271] [VAR[WebSocket接続の状態]]が [CODE[[[OPEN]]]] でなければ、
エラーを返して停止します。
= [268] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:[VAR[種別]]がテキストなら 1、バイナリーなら 2
:[[mask]]:1
:[[長さ]]:[VAR[データ]]のバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[データ]]
]FIG]
= [269] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
= [270] [VAR[接続]]で [[WebSocketフレーム]]のバイト列を送信することとします。
]FIG]

[260] ping 送信は、次のようにします。
この処理は、バイト列である[VAR[データ]]と、[VAR[応答]]フラグを受け取ります。
[FIG(steps)[
= [287] 前提として、次の条件を満たす必要があります。
[FIG(list)[
- [288] [VAR[データ]]の長さは 2[SUP[63]] [[未満]]かつ実装の扱える範囲内である
]FIG]
= [272] [VAR[WebSocket接続の状態]]が [CODE[[[OPEN]]]] でなければ、
エラーを返して停止します。
= [273] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:[VAR[応答]]フラグが設定されていれば 10、されていなければ 9
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:指定されたバイト列
]FIG]
= [274] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
= [275] [VAR[接続]]で [[WebSocketフレーム]]のバイト列を送信することとします。
]FIG]

[107] [[トンネル]]への[[バイト]]の送信は、次のようにします。
[FIG(steps)[
= [108] [VAR[状態]]が「トンネル」か「トンネル送信中」以外なら、
== [335] エラーを返し、ここで停止します。
= [109] [VAR[接続]]で指定された[[バイト]]の送信を指示します。
= [110] エラーが返されたら、ここで停止します。
]FIG]

[50] [[接続]]の正常終了は、次のようにします。引数として[[非負整数]]または null
である[VAR[状態符号]]と、
[[バイト列]]である[VAR[理由]]を受け取ります。
[FIG(steps)[
= [286] 前提として、次の条件を満たす必要があります。
[FIG(list)[
- [285] [VAR[状態符号]]は2[SUP[16]] [[以下]]
- [283] [VAR[理由]]の長さは 2[SUP[63]] [[未満]]かつ実装の扱える範囲内である
- [276] [VAR[状態符号]]が null なら、[VAR[理由]]は空である
]FIG]
= [279] [VAR[WebSocket接続の状態]]が [CODE[[[OPEN]]]] か [CODE[[[CONNECTING]]]] なら、
== [281] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:8
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[状態符号]]が null なら空、
そうでなければ、[VAR[状態符号]]を表す[[16ビット符号無し整数]] ([[ネットワークバイト順]]) と、
それに続けて[VAR[理由]]
]FIG]
== [282] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
== [280] [VAR[WebSocket接続の状態]]が [CODE[[[CONNECTING]]]] なら、
=== [277] [VAR[送信待ちフレーム]]が null なら、[VAR[送信待ちフレーム]]を作成した[[WebSocketフレーム]]に設定します。
== [290] それ以外なら、
=== [297] [VAR[WebSocket接続の状態]]を、 [CODE[[[CLOSING]]]] に設定します。
=== [174] [VAR[要求]]について、WebSocket終了開始を通知します。
=== [284] [VAR[接続]]で、作成した [[WebSocketフレーム]]のバイト列を送信することとします。
=== [315] [VAR[切断タイマー]]により20s後に次の要求に進むことにします。
= [72] [VAR[要求締め切り]]フラグを設定します。
= [66] [VAR[状態]]が「初期」か「要求待ち」か「トンネル」か「トンネル送信中」なら、
== [55] [VAR[接続]]で正常終了の送信を指示します。
= [362] [VAR[状態]]が「トンネル」なら、
== [363] [VAR[状態]]を、「トンネル受信中」に設定します。
]FIG]

;; [73] これにより[[要求]]の送信側は閉じられますが、[[応答]]の受信はまだ続くかもしれません。

[52] [[接続]]の中断は、次のようにします。
[FIG(steps)[
= [44] [VAR[要求の締め切り]]フラグを設定します。
= [39] [VAR[要求の送信状態]]を送信済みに設定します。
= [51] [VAR[接続]]を中断します。
]FIG]

** アプリケーションへの通知

[11] [[状態機械]]は、[[要求]]について次の通知を行います。
それぞれ、次に示す[[引数]] (あれば) 付きで通知されます。
[FIG(list)[
- 要求の本体の一部の送信の通知
[FIG(list members)[
:[[転送済]]:[VAR[要求の転送済]]。
]FIG]
- [526] 要求の送信完了の通知
-- [527] [[要求]]全体の送信が完了したことの通知です。
[[WebSocket]] や [CODE(HTTP)@en[[[CONNECT]]]] [[要求]]では、
[[要求ヘッダー]]後の[[空行]]まで送信した時点で発火されます。
- 応答のヘッダー受信完了の通知
[FIG(list members)[
:[[応答]]:[VAR[応答]]。
:[[WebSocket接続確立]]:[[真]]か[[偽]]。既定値は[[偽]]。
]FIG]
- [377] データ開始の通知
-- [535] [[応答本体]]や[[トンネル]]、
[[バイナリー]]の[[WebSocketメッセージ]]の受信開始前に発火されます。
- [528] データ受信の通知
[FIG(list members)[
:データ:[[バイト列]]。
]FIG]
-- [529] [[応答本体]]や[[トンネル]]、
[[バイナリー]]の[[WebSocketメッセージ]]として[[バイト列]]を受信した際に発火されます。
- [378] データ終了の通知
-- [536] [[応答本体]]や[[トンネル]]、
[[バイナリー]]の[[WebSocketメッセージ]]の受信終了後に発火されます。
- [531] 文字列開始の通知
-- [537] [[テキスト]]の[[WebSocketメッセージ]]の受信開始前に発火されます。
- [532] 文字列受信の通知
[FIG(list members)[
:データ:[[文字列]]。
]FIG]
-- [534] [[テキスト]]の[[WebSocketメッセージ]]の[[文字列]]を受信した際に発火されます。
- [533] 文字列終了の通知
-- [538] [[テキスト]]の[[WebSocketメッセージ]]の受信終了後に発火されます。
- [250] ping の通知
[FIG(list members)[
:返答:[[真]]か[[偽]]。既定値は[[偽]]。
:データ:[[バイト列]]。既定値は空。
]FIG]
- [329] WebSocket終了開始の通知
-- [317] [[WebSocket]] で [[Closeフレーム]]を初めに送信または受信したときに発火されます。
- [358] 完了の通知
[FIG(list members)[
:[[応答]]:[VAR[応答]]。
:[[終了]]:終了。
]FIG]
]FIG]

[15] 各[[要求]]について、2種類の送信の通知と3種類の受信の通知をそれぞれこの順序で行うか、
その途中で失敗の通知で中断するかのいずれかです。
送信の通知と受信の通知はどちらもそれぞれ進行し、相互の順序は不定です。
送信の完了は通知されないことがあります (失敗の場合)。
データ受信の通知は、0回以上の任意の回数行います。
データ受信の通知のかわりに 0回以上の ping の通知がある場合があります。
[[トンネル]]では最初にデータ開始の通知、最後にデータ終了の通知があります。
完了の通知の前に、WebSocket終了開始の通知があるかもしれません。

[FIG(flow)[
:initial:要求の送信
:v:
:>>:3
:->:reqbody
:->:reqeof
:->:headers
:->:rerror
:->:reset

:reqbody:本体一部送信
:->:reqbody
:->:reqeof
:v:
:>>:2
:->:rerror
:->:reset

:reqeof:送信完了
:v:
:>>:1
:->:reset

:headers:ヘッダー受信
:v:
:>>:3
:->:body
:->:complete
:->:reset

:body:受信
:v:
:>>:4
:->:complete
:->:body
:->:reset

:complete:完了 (成功)
:v:
:>>:3

:reset:完了 (失敗)
:>>:5

]FIG]

;; [253] 図の「受信」は、データ受信、ping の受信、WebSocket終了開始、データ開始、データ終了を表します。

* The HTTP state machine

[68] [[クライアント]]は[[状態機械]]を持ちます。

[53] [VAR[接続]]の[[バイト]]受信の通知があると、次のようにします。
ただし、[VAR[状態]]が「初期」なら、[VAR[状態]]が変化するまで待ってから実行します。
[FIG(steps)[
= [14] [[緊急データ]]フラグが設定されていなければ、
== [37] [VAR[状態]]により決まる処理を行います。
]FIG]

[40] 正常終了の受信の通知があると、次のようにします。
[FIG(steps)[
= [54] [VAR[状態]]により決まる正常終了処理を行います。
= [322] [VAR[状態]]が「トンネル送信中」以外なら、
== [224] [VAR[接続]]を閉じることにします。
]FIG]

[13] 中断の通知があると、次のようにします。
[FIG(steps)[
= [359] リセットフラグが設定されていれば、
== [360] [VAR[要求]]が null でなければ、
=== [361] [VAR[終了]]を、新しい終了に設定します。リセットと失敗を[[真]]とします。
== [522] [VAR[要求締め切り]]フラグを設定します。
== [523] [VAR[要求の送信状態]]を送信済みに設定します。
== [524] 次の要求に進みます。
= [41] それ以外なら、
== [525] [VAR[状態]]により決まる中断処理を行います。
= [225] [VAR[接続]]を破棄します。
]FIG]

@@
[318] 送信するものがなくなった通知があると、次のようにします。
[FIG(steps)[
= [319] [VAR[状態]]が「トンネル」か「トンネル送信中」なら、
== [320] [VAR[要求]]について送信するものがなくなったことを通知します。
]FIG]

** 「初期」状態

[69] 正常終了か中断を受信したら、
[FIG(steps)[
= [VAR[要求締め切り]]フラグを設定します。
= [VAR[要求の送信状態]]を送信済みに設定します。
= 次の要求に進みます。
]FIG]

** 「要求待ち」状態

[2] バイトを受信したら、何もせずに無視します。

[33] 正常終了か中断を受信したら、
[FIG(steps)[
= [VAR[要求締め切り]]フラグを設定します。
= [VAR[要求の送信状態]]を送信済みに設定します。
= 次の要求に進みます。
]FIG]

** 「要求送信中」状態、「トンネル送信中」状態

[56] バイトを受信したら、何もせずに無視します。

[67] 正常終了を受信したら、
[FIG(steps)[
= [VAR[要求締め切り]]フラグを設定します。
= 次の要求に進みます。
]FIG]

[76] 中断を受信したら、
[FIG(steps)[
= [VAR[要求締め切り]]フラグを設定します。
= [VAR[要求の送信状態]]を送信済みに設定します。
= 次の要求に進みます。
]FIG]

** 「応答前」状態

[24] バイトを受信したら、
[FIG(steps)[
= [130] [VAR[応答受信済み]]を、[[真]]に設定します。
= [26] 受信したバイトを、[VAR[一時バッファー]]の末尾に連結します。
= [27] [VAR[一時バッファー]]の末尾4バイトが [CODE(HTTP)[HTTP]]
([[ASCII大文字・小文字不区別]]) なら、
== [VAR[応答]]の[[プロトコルの版]]を 1.0 に設定します。
== [VAR[状態]]を、「応答ヘッダー」に設定します。
== [VAR[一時バッファー]]を、空に設定します。
= [28] それ以外で、[VAR[一時バッファー]]の長さが8バイトなら、
== [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)@en[[[PUT]]]] か [CODE(HTTP)@en[[[CONNECT]]]] なら、
=== [VAR[要求締め切り]]フラグを設定します。
=== [VAR[要求の送信状態]]を送信済みに設定します。
=== [432] [VAR[終了]]を、失敗が[[真]]の新しい終了に設定します。
=== [433] 次の要求に進みます。
== それ以外なら、
=== [367] [VAR[要求]]についてデータ受信を通知します。[VAR[一時バッファー]]を引渡します。
=== [452] [VAR[残り長さ]]を、 null に設定します。
=== [485] [VAR[状態]]を、「応答本体」に設定します。
]FIG]

[8] 正常終了か中断を受信したら、
[FIG(steps)[
= [132] [VAR[一時バッファー]]が[[空文字列]]なら、
== [134] [VAR[要求締め切り]]フラグを設定します。
== [135] [VAR[要求の送信状態]]を送信済みに設定します。
== [133] [VAR[終了]]を、失敗が[[真]]の新しい終了に設定します。
== [434] [VAR[応答受信済み]]が[[真]]なら、[VAR[終了]]の再試行可能性を[[真]]とします。
== [136] 次の要求に進みます。
= [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)@en[[[PUT]]]] か [CODE(HTTP)@en[[[CONNECT]]]] なら、
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [435] [VAR[終了]]を、失敗が[[真]]の新しい終了に設定します。
== [436] 次の要求に進みます。
= それ以外なら、
== [530] [VAR[要求]]についてデータ受信を通知します。[VAR[一時バッファー]]を引渡します。
== 中断なら、[VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
== [VAR[要求]]について[VAR[応答]]のヘッダー受信完了を通知します。
== [VAR[要求締め切り]]フラグを設定します。
== 中断なら、[VAR[要求の送信状態]]を送信済みに設定します。
== [437] [VAR[終了]]を、新しい終了に設定します。
== [438] 次の要求に進みます。
]FIG]

** 「応答ヘッダー」状態

[36] バイトを受信したら、
[FIG(steps)[
= [VAR[一時バッファー]]の末尾に受信したバイトを追加します。
= [VAR[一時バッファー]]の末尾が 0x0A 0x0A または 0x0A 0x0D 0x0A なら、
== [137] ヘッダーの処理 (>>138) を行います。
= それ以外で、 [VAR[一時バッファー]]の長さが 2[SUP[18]]‐1 なら、
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [439] [VAR[終了]]を、失敗が[[真]]の新しい終了に設定します。
== [440] 次の要求に進みます。
]FIG]

[12] 正常終了か中断を受信したら、
[FIG(steps)[
= [445] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
= [139] ヘッダーの処理 (>>138) を行います。
= [442] [VAR[終了]]を、新しい終了に設定します。
= [141] [VAR[残り長さ]]が[[正]]で[VAR[応答]]の[[プロトコルの版]]が [CODE[1.1]] なら、
== [441] [VAR[終了]]の失敗を、[[真]]に設定します。
= [142] [VAR[要求締め切り]]フラグを設定します。
= [443] [VAR[要求の送信状態]]を送信済みに設定します。
= [444] 次の要求に進みます。
]FIG]

[138] ヘッダーの処理は、次のようにします。
[FIG(steps)[
= [140] [VAR[一時バッファー]]をヘッダー群として構文解析します。
= [113] [VAR[応答]]の[[プロトコルの版]]が [CODE[1.1]] で、
[CODE(HTTP)@en[[[Transfer-Encoding:]]]] [[ヘッダー]]があって、
[CODE(HTTP)@en[[[chunked]]]] ([[ASCII大文字・小文字不区別]]) が[[転送符号化]]として指定されていれば、
== [114] [VAR[残り長さ]]を、「chunked」に設定します。
= [115] それ以外なら、
== [32] [VAR[残り長さ]]を、[VAR[応答]]の [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]の処理の結果とします。
= [448] [VAR[残り長さ]]がエラーなら、
== [449] [VAR[要求締め切り]]フラグを設定します。
== [450] [VAR[要求の送信状態]]を送信済みに設定します。
== [446] [VAR[終了]]を、失敗が[[真]]の新しい終了に設定します。
== [447] 次の要求に進みます。
= [540] それ以外で、[VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)[[[CONNECT]]]] で、
[VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[200]]]] なら、
== [373] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
== [374] [VAR[要求]]についてデータ開始を通知します。
== [375] [VAR[要求締め切り]]フラグを設定します。
== [376] [VAR[状態]]を、「トンネル」に設定します。
= [143] それ以外で、[VAR[WebSocket接続の状態]]が [CODE[CONNECTING]] で、
[VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[101]]]] なら、
== [144] 
[FIG(list)[
- [299] [VAR[応答]]に [CODE(HTTP)@en[[[Upgrade:]]]] [[ヘッダー]]が無いか、 
[CODE(HTTP)@en[[[websocket]]]] ([[ASCII大文字・小文字不区別]]) が含まれていない
- [300] [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]が無いか、 
[CODE(HTTP)@en[[[Upgrade]]]] ([[ASCII大文字・小文字不区別]]) が含まれていない
- [301] [VAR[応答]]に [CODE(HTTP)@en[[[Sec-WebSocket-Accept:]]]] [[ヘッダー]]が無いか、 
値が[VAR[要求]]の [CODE(HTTP)@en[[[Sec-WebSocket-Key:]]]] の値に 
[CODE(HTTP)[[[258EAFA5-E914-47DA-95CA-C5AB0DC85B11]]]] を連結した値の 
[[SHA-1]] を [[Base64]] [[符号化]]したものでない
- [302] [VAR[応答]]の [CODE(HTTP)@en[[[Sec-WebSocket-Extensions:]]]] 
[[ヘッダー]]が存在する
- [303] [VAR[応答]]の [CODE(HTTP)@en[[[Sec-WebSocket-Protocol:]]]] [[ヘッダー]]が[VAR[要求]]の
[CODE(HTTP)@en[[[Sec-WebSocket-Protocol:]]]] [[ヘッダー]]の値のいずれかと一致しない
(一方が存在しない場合は、他方が存在している)
]FIG]
... のいずれかであれば、
=== [145] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
=== [248] [VAR[終了]]を、次の通り設定します。
[FIG(list members)[
:失敗:[[真]]。
:cleanly:[[偽]]。
:[[状態符号]]:[CODE[[[1006]]]]。
:理由:[[空文字列]]。
]FIG]
=== [245] [VAR[要求締め切り]]フラグを設定します。
=== [246] [VAR[要求の送信状態]]を送信済みに設定します。
=== [247] 次の要求に進みます。
== [146] それ以外なら、
=== [291] [VAR[WebSocket接続の状態]]を、 [CODE[OPEN]] に設定します。
=== [256] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
[[WebSocket接続確立]]を[[真]]にします。
=== [292] [VAR[要求締め切り]]フラグを設定します。
=== [293] [VAR[状態]]を、「WebSocketフレーム前」に設定します。
=== [147] [VAR[一時バッファー]]を、空に設定します。
=== [294] [VAR[送信待ちフレーム]]が null 以外なら、
==== [296] [VAR[WebSocket接続の状態]]を、 [CODE[[[CLOSING]]]] に設定します。
==== [295] [VAR[接続]]で、[VAR[送信待ちフレーム]]のバイト列を送信することにします。
==== [316] [VAR[切断タイマー]]により20s後に次の要求に進むことにします。
= [106] それ以外で、 [VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[1xx]]]] なら、
== [337] [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)[[[CONNECT]]]] か、
[VAR[WebSocket接続の状態]]が [CODE[CONNECTING]] なら、
=== [255] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
=== [254] [VAR[終了]]が null なら、新しい終了に設定します。
=== [339] [VAR[要求締め切り]]フラグを設定します。
=== [340] [VAR[要求の送信状態]]を送信済みに設定します。
=== [338] 次の要求に進みます。
== [341] それ以外なら、
=== [342] [VAR[応答]]の[[プロトコルの版]]、[[状態符号]]、[[理由句]]、[[ヘッダーリスト]]を初期値に設定します。
=== [382] [VAR[状態]]を、「応答前」に設定します。
=== [383] [VAR[一時バッファー]]を、空バイト列に設定します。
= [344] それ以外なら、
== [345] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
== [385] [VAR[要求]]についてデータ開始を通知します。
== [346] 
[FIG(list)[
- [348] [VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[204]]]], [CODE(HTTP)[[[205]]]],
[CODE(HTTP)[[[304]]]] のいずれかの場合か、
- [349] [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)@en[[[HEAD]]]] の場合
]FIG]
... のいずれかの場合、
=== [347] [VAR[残り長さ]]を、0に設定します。
== [87] [VAR[残り長さ]]が 0 なら、
=== [89] [VAR[終了]]を、新しい終了に設定します。
=== [79] [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
==== [80] [VAR[要求締め切り]]フラグを設定します。
=== [81] それ以外で、[VAR[応答]]の[[プロトコルの版]]が [CODE[1.0]] で、
[CODE(HTTP)@en[[[keep-alive]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定された
[CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]がなければ、
==== [82] [VAR[要求締め切り]]フラグを設定します。
=== [343] 次の要求に進みます。
== [116] それ以外で、 [VAR[残り長さ]]が「chunked」なら、
=== [117] [VAR[状態]]を、「塊前」に設定します。
== [88] それ以外なら、
=== [16] [VAR[状態]]を、「応答本体」に設定します。
]FIG]

** 「応答本体」状態

[6] バイトを受信したら、
[FIG(steps)[
= [451] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
= [453] [VAR[残り長さ]]が[[正]]なら、
== [454] [VAR[残り長さ]]を1減らします。
== [386] [VAR[残り長さ]]が0なら、
=== [387] [VAR[要求]]についてデータ終了を通知します。
=== [251] [VAR[終了]]を、新しい終了に設定します。
=== [83] [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
==== [84] [VAR[要求締め切り]]フラグを設定します。
=== [85] それ以外で、[VAR[応答]]の[[プロトコルの版]]が [CODE[1.0]] で、
[CODE(HTTP)@en[[[keep-alive]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定された
[CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]がなければ、
==== [86] [VAR[要求締め切り]]フラグを設定します。
=== [244] 次の要求に進みます。
]FIG]

[7] 正常終了か中断を受信したら、
[FIG(steps)[
= [388] [VAR[残り長さ]]が[[正]]なら、
== [389] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
== [390] [VAR[要求の送信状態]]を送信済みに設定します。
== [395] [VAR[要求]]についてデータ終了を通知します。
== [455] [VAR[終了]]を、新しい終了に設定します。
== [391] [VAR[応答]]の[[プロトコルの版]]が [CODE[1.1]] なら、
=== [392] [VAR[終了]]の失敗を[[真]]に設定します。
= [396] それ以外で、中断で[VAR[残り長さ]]が0なら、
== [397] [VAR[要求の送信状態]]を送信済みに設定します。
== [398] [VAR[要求]]についてデータ終了を通知します。
== [399] [VAR[終了]]を、新しい終了に設定します。
= [400] それ以外なら、
== [401] [VAR[要求]]についてデータ終了を通知します。
== [402] [VAR[終了]]を、新しい終了に設定します。
= [403] [VAR[要求締め切り]]フラグを設定します。
= [404] 次の要求に進みます。
]FIG]

** 「塊前」状態

[118] バイトを受信したら、
[FIG(steps)[
= [394] [[ASCII十六進数字]]なら、
== [456] [VAR[一時バッファー]]を、指定されたバイトに設定します。
== [457] [VAR[状態]]を、「塊サイズ」に設定します。
= [458] それ以外なら、
== [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [405] [VAR[要求]]についてデータ終了を通知します。
== [406] [VAR[終了]]を、新しい終了に設定します。
== [393] 次の要求に進みます。
]FIG]

[119] 正常終了か中断を受信したら、
[FIG(steps)[
= [459] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
= [460] [VAR[要求締め切り]]フラグを設定します。
= [461] [VAR[要求の送信状態]]を送信済みに設定します。
= [407] [VAR[要求]]についてデータ終了を通知します。
= [408] [VAR[終了]]を、新しい終了に設定します。
= [409] 次の要求に進みます。
]FIG]

** 「塊サイズ」状態

[120] バイトを受信したら、
[FIG(steps)[
= [462] [[ASCII十六進数字]]なら、
== [463] [VAR[一時バッファー]]に、指定されたバイトを追加します。
= [464] それ以外なら、
== [465] [VAR[一時バッファー]]を、[[十六進数]]として解釈します。
== [466] [VAR[残り長さ]]を、得られた値に設定します。
== [467] [VAR[残り長さ]]がエラー ([[桁溢れ]]) なら、
=== [468] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
=== [469] [VAR[要求締め切り]]フラグを設定します。
=== [470] [VAR[要求の送信状態]]を送信済みに設定します。
=== [410] [VAR[要求]]についてデータ終了を通知します。
=== [411] [VAR[終了]]を、新しい終了に設定します。
=== [412] 次の要求に進みます。
== [428] それ以外で、[VAR[残り長さ]]が 0 なら、
=== [431] [VAR[要求]]についてデータ終了を通知します。
=== [429] [VAR[状態]]を、「trailer 前」に設定します。
=== [430] [VAR[一時バッファー]]を、空に設定します。
== [471] それ以外なら、
=== [472] バイトが 0x0A なら、
==== [473] [VAR[状態]]を、「塊」に設定します。
=== [474] それ以外なら、
==== [475] [VAR[状態]]を、「塊拡張」に設定します。
]FIG]

[122] 正常終了か中断を受信したら、
[FIG(steps)[
= [476] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
= [477] [VAR[要求締め切り]]フラグを設定します。
= [478] [VAR[要求の送信状態]]を送信済みに設定します。
= [413] [VAR[要求]]についてデータ終了を通知します。
= [414] [VAR[終了]]を、新しい終了に設定します。
= [415] 次の要求に進みます。
]FIG]

** 「塊拡張」状態

[121] バイトを受信したら、
[FIG(steps)[
= [479] 0x0A なら、
== [480] [VAR[状態]]を、「塊」に設定します。
]FIG]

[123] 正常終了か中断を受信したら、
[FIG(steps)[
= [481] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
= [482] [VAR[要求締め切り]]フラグを設定します。
= [483] [VAR[要求の送信状態]]を送信済みに設定します。
= [416] [VAR[要求]]についてデータ終了を通知します。
= [417] [VAR[終了]]を、新しい終了に設定します。
= [418] 次の要求に進みます。
]FIG]

** 「塊」状態

[124] バイトを受信したら、
[FIG(steps)[
= [249] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
= [486] [VAR[残り長さ]]を1減らします。
= [487] [VAR[残り長さ]]が0なら、
== [488] [VAR[状態]]を、「塊後」に設定します。
]FIG]

[125] 正常終了か中断を受信したら、
[FIG(steps)[
= [489] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
= [490] [VAR[要求締め切り]]フラグを設定します。
= [491] [VAR[要求の送信状態]]を送信済みに設定します。
= [419] [VAR[要求]]についてデータ終了を通知します。
= [420] [VAR[終了]]を、新しい終了に設定します。
= [421] 次の要求に進みます。
]FIG]

** 「塊後」状態

[126] バイトを受信したら、
[FIG(steps)[
= [492] 0x0D なら、
== [493] [VAR[状態]]を、「塊 CR 後」に設定します。
= [494] 0x0A なら、
== [495] [VAR[状態]]を、「塊前」に設定します。
= [496] それ以外なら、
== [497] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
== [498] [VAR[要求締め切り]]フラグを設定します。
== [499] [VAR[要求の送信状態]]を送信済みに設定します。
== [422] [VAR[要求]]についてデータ終了を通知します。
== [423] [VAR[終了]]を、新しい終了に設定します。
== [424] 次の要求に進みます。
]FIG]

[127] 正常終了か中断を受信したら、
[FIG(steps)[
= [500] [VAR[応答]]の[[不完全メッセージ]]フラグを設定します。
= [501] [VAR[要求締め切り]]フラグを設定します。
= [502] [VAR[要求の送信状態]]を送信済みに設定します。
= [425] [VAR[要求]]についてデータ終了を通知します。
= [426] [VAR[終了]]を、新しい終了に設定します。
= [427] 次の要求に進みます。
]FIG]

** 「trailer 前」状態

[128] バイトを受信したら、
[FIG(steps)[
= [VAR[一時バッファー]]の末尾に受信したバイトを追加します。
= [VAR[一時バッファー]]の末尾が 0x0A 0x0A または 0x0A 0x0D 0x0A なら、
== [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
=== [VAR[要求締め切り]]フラグを設定します。
== [503] [VAR[終了]]を、新しい終了に設定します。
== [504] 次の要求に進みます。
= それ以外で、 [VAR[一時バッファー]]の長さが 2[SUP[18]]‐1 なら、
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [505] [VAR[終了]]を、新しい終了に設定します。
== [506] 次の要求に進みます。
]FIG]

[129] 正常終了か中断を受信したら、
[FIG(steps)[
= [509] [VAR[要求締め切り]]フラグを設定します。
= [510] [VAR[要求の送信状態]]を送信済みに設定します。
= [507] [VAR[終了]]を、新しい終了に設定します。
= [508] 次の要求に進みます。
]FIG]

** 「WebSocket フレーム前」状態

[148] バイトを受信したら、
[FIG(steps)[
= [VAR[一時バッファー]]の末尾に、受信したバイトを追加します。
= [VAR[一時バッファー]]の長さが2未満なら、ここで停止します。
= [VAR[フレーム]]を、次のような新しい[[WebSocketフレーム]]に設定します。
[FIG(list members)[
:[[FIN]]:[VAR[一時バッファー]]の第1バイトの最上位ビット
:[[RSV1]]:[VAR[一時バッファー]]の第1バイトの上位から第2ビット目
:[[RSV2]]:[VAR[一時バッファー]]の第1バイトの上位から第3ビット目
:[[RSV3]]:[VAR[一時バッファー]]の第1バイトの上位から第4ビット目
:[[opcode]]:[VAR[一時バッファー]]の第1バイトの下位4ビットを[[整数]]としたもの
:[[mask]]:[VAR[一時バッファー]]の第2バイトの最上位ビット
:[[長さ]]:[VAR[一時バッファー]]の第2バイトの下位7ビットを[[整数]]としたもの
]FIG]
= [VAR[フレーム]]の[[長さ]]が126か127で、[[opcode]] が 8 [[以上]]なら、
== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[長さ]]が126なら、
== [VAR[一時バッファー]]の長さが4以上でなければ、ここで停止します。
== [VAR[フレーム]]の[[長さ]]を、[VAR[一時バッファー]]の第3、第4バイトを[[ネットワークバイト順]]の[[16ビット符号無し整数]]とした値に設定します。
== [VAR[フレーム]]の[[長さ]]が126未満なら、
=== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[長さ]]が127なら、
== [VAR[一時バッファー]]の長さが10以上でなければ、ここで停止します。
== [VAR[一時バッファー]]の第3バイトの最上位ビットが 1 なら、
=== 失敗とします。ここで停止します。
== [VAR[フレーム]]の[[長さ]]を、[VAR[一時バッファー]]の第3-8バイトを[[ネットワークバイト順]]の[[64ビット符号無し整数]]とした値に設定します。
== [VAR[フレーム]]の[[長さ]]が2[SUP[16]]未満なら、
=== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[長さ]]が実装の扱える範囲を超えていれば、
== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[mask]]が設定されていれば、
== [VAR[一時バッファー]]に次の4バイトがなければ、ここで停止します。
== [VAR[フレーム]]の[[マスクキー]]を、[VAR[一時バッファー]]のその4バイトに設定します。
= [150] [VAR[種別]]が[[サーバー]]であり、[VAR[フレーム]]の [[mask]] が 0 なら、
== [153] 理由 [CODE[WebSocket Protocol Error]] で失敗とします。ここで停止します。
= [151] [VAR[種別]]が[[クライアント]]であり、[VAR[フレーム]]の [[mask]] が 1 なら、
== [152] 理由 [CODE[Masked frame from server]] で失敗とします。ここで停止します。
= [154] [VAR[フレーム]]の FIN が 0 で [[opcode]] が 8, 9, 10 なら、
== [155] 失敗とします。ここで停止します。
= [156] [VAR[フレーム]]の RSV1, RSV2, RSV3 のいずれかでも 1 なら、
== [157] 理由 [CODE[Invalid reserved bit]] で失敗とします。ここで停止します。
= [158] [VAR[フレーム]]の [[opcode]] が 3-7, 11-15 なら、
== [159] 理由 [CODE[Unknown opcode]] で失敗とします。ここで停止します。
= [170] [VAR[先頭フレーム]]が null で、[VAR[フレーム]]の [[opcode]] が 0 なら、
== [171] 理由 [CODE[Unexpected continuation]] で失敗とします。ここで停止します。
= [172] [VAR[先頭フレーム]]が非 null で、[VAR[フレーム]]の [[opcode]] が 1 か 2 なら、
== [173] 理由 [CODE[Previous data frame unfinished]] で失敗とします。ここで停止します。
= [175] [[FIN]] が 0 で [[opcode]] が 1, 2 なら、
== [176] [VAR[先頭フレーム]]を、[VAR[フレーム]]に設定します。
= [195] [VAR[一時バッファー]]を、空に設定します。
= [160] [VAR[フレーム]]の長さが0なら、
== [190] [[WebSocketフレーム]]の処理 (>>189) を行います。途中で停止したら、ここで停止します。
== [192] [VAR[フレーム]]を、 null に設定します。
== [191] [VAR[状態]]を、「WebSocket フレーム前」に設定します。
== [193] [VAR[一時バッファー]]を、空に設定します。
= [161] それ以外なら、
== [196] [VAR[状態]]を、「WebSocket データ」に設定します。
]FIG]

[149] 正常終了か中断を受信したら、
[FIG(steps)[
= [226] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [227] [VAR[終了]]を、次の通り設定します。
[FIG(list members)[
:失敗:[[真]]
:cleanly:[[偽]]
:状態符号:[CODE[[[1006]]]]
:理由:[[空文字列]]
]FIG]
= [330] 次の要求に進みます。
]FIG]

** 「WebSocket データ」状態

[163] バイトを受信したら、
[FIG(steps)[
= [164] [VAR[一時バッファー]]の末尾に、受信したバイトを追加します。
= [165] [VAR[フレーム]]の [[mask]] が1なら、
== [166] [VAR[フレーム]]のマスクキーの先頭から第
(([VAR[一時バッファー]]の長さ - 1) mod 4) バイト (先頭が第0バイトとして数えた時。)
を使って[VAR[一時バッファー]]の末尾のバイトを [[XOR]] したものに置き換えます。
= [167] [VAR[一時バッファー]]の[[長さ]]が[VAR[フレーム]]の[[長さ]]と等しくなければ、
ここで停止します。
= [188] [[WebSocketフレーム]]の処理 (>>189) を行います。途中で停止したら、ここで停止します。
= [184] [VAR[フレーム]]を、 null に設定します。
= [185] [VAR[状態]]を、「WebSocket フレーム前」に設定します。
= [186] [VAR[一時バッファー]]を、空に設定します。
]FIG]

@@ permessage-deflate

[162] 正常終了か中断を受信したら、
[FIG(steps)[
= [212] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [215] [VAR[終了]]を、次の通り設定します。
[FIG(list members)[
:失敗:[[真]]
:cleanly:[[偽]]
:状態符号:[CODE[[[1006]]]]
:理由:[[空文字列]]
]FIG]
= [331] 次の要求に進みます。
]FIG]

** 「WebSocket 切断待ち」状態

[217] 「WebSocket フレーム前」状態、「WebSocket データ」状態で失敗するという時、
次のようにします。
[FIG(steps)[
= [229] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [230] [VAR[終了]]を、次の通り設定します。
[FIG(list members)[
:失敗:[[真]]
:cleanly:[[偽]]
:状態符号:[CODE[[[1002]]]]
:理由:指定された理由。指定がなければ [CODE[WebSocket Protocol Error]]。
]FIG]
= [231] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:8
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[終了]]の[[状態符号]]を表す[[16ビット符号無し整数]] ([[ネットワークバイト順]]) と、
それに続けて理由
]FIG]
= [305] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
= [306] [VAR[接続]]で、作成した[[WebSocketフレーム]]を送信することにします。
= [232] [VAR[状態]]を、「WebSocket切断待ち」に設定します。
= [233] 次の要求に進むことにします。
]FIG]

[214] バイトを受信したら、
[FIG(steps)[
= [234] [VAR[終了]]の[[失敗]]が[[偽]]なら、
== [235] [VAR[終了]]の[[失敗]]を[[真]]に設定します。
== [236] [VAR[終了]]の[[状態符号]]を [CODE[[[1006]]]] に設定します。
== [237] [VAR[終了]]の理由を[[空文字列]]に設定します。
]FIG]

[220] 正常終了か中断を受信したら、
[FIG(steps)[
= [238] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [239] 中断で[VAR[終了]]の[[失敗]]が[[偽]]なら、
== [240] [VAR[終了]]の[[失敗]]を[[真]]に設定します。
== [241] [VAR[終了]]の[[状態符号]]を [CODE[[[1006]]]] に設定します。
== [242] [VAR[終了]]の理由を[[空文字列]]に設定します。
= [332] 次の要求に進みます。
]FIG]

** 「トンネル」状態

[111] バイトを受信したら、
[FIG(steps)[
= [484] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
]FIG]

[112] 正常終了か中断を受信したら、
[FIG(steps)[
= [371] [VAR[要求]]についてデータ終了を通知します。
= [328] [VAR[要求締め切り]]フラグを設定します。
= [321] 正常終了なら、
== [325] [VAR[状態]]を、「トンネル送信中」に設定します。
= [323] それ以外なら、
== [326] [VAR[要求の送信状態]]を送信済みに設定します。
== [324] [VAR[終了]]を、失敗が[[真]]の新しい終了に設定します。
== [327] 次の要求に進みます。
]FIG]

** 「トンネル受信中」状態

[364] バイトを受信したら、
[FIG(steps)[
= [366] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
]FIG]

[365] 正常終了か中断を受信したら、
[FIG(steps)[
= [372] [VAR[要求]]についてデータ終了を通知します。
= [328] [VAR[要求締め切り]]フラグを設定します。
= [369] [VAR[要求の送信状態]]を送信済みに設定します。
= [511] [VAR[終了]]を、新しい終了に設定します。
= [368] 中断なら、[VAR[終了]]の異常を[[真]]に設定します。
= [370] 次の要求に進みます。
]FIG]

** 「停止済み」状態

[43] 次の要求に進むとは、次のようにします。
[FIG(steps)[
= [243] [VAR[状態]]が「停止済み」なら、ここで停止します。
= [336] [VAR[切断タイマー]]を停止させます。
= [379] [VAR[要求の送信状態]]が送信中なら、
== [380] [VAR[状態]]を、「要求送信中」に設定します。
= [381] それ以外なら、
== [512] [VAR[要求]]が null ではなく、[VAR[要求の送信状態]]が送信済みなら、
=== [513] [VAR[要求]]について完了を通知します。[VAR[終了]]を引渡します。
== [333] [VAR[要求]]を、 null に設定します。
== [334] [VAR[応答]]を、 null に設定します。
== [514] [VAR[要求の送信状態]]を、未送信に設定します。
== [515] [VAR[要求の処理完了]]が null でなければ、
=== [516] [VAR[要求の処理完了]]を[[解決]]します。
=== [517] [VAR[要求の処理完了]]を null に設定します。
== [518] [VAR[要求締め切り]]フラグが設定されていれば、
=== [351] [VAR[接続]]の正常終了の送信を指示します。
=== [350] これ以後[VAR[接続]]の受信終了を指示して構いません。
=== [352] [VAR[状態]]を、「停止済み」に設定します。
== [519] それ以外なら、
=== [353] [VAR[状態]]を、「要求待ち」に設定します。
]FIG]

[70] バイトを受信したら、何もしません。

[71] 正常終了や中断を受信したら、何もしません。

** ヘッダー群として構文解析

[17] 入力を、 0x0D や 0x0A で区切られた[[行]]に分割します。
[[行]]には区切りの 0x0D, 0x0A は含めません。

[3] 最初の行を (あれば) 次のようにします。

[FIG(steps)[
= 先頭が [CODE[/]] なら、
== その次が[[ASCII数字]]列なら、これを[[十進整数]]として解釈します。
ただし[[先導0]]があるときは、 0 とみなします。
== その次が [CODE[.]] なら、
=== その次が [[ASCII数字]]列なら、これを[[十進整数]]として解釈します。
=== [19] 最初の[[整数]]が2[[以上]]か、
最初の[[整数]]が1と等しく次の[[整数]]が1[[以上]]なら、
==== [VAR[応答]]の[[プロトコルの版]]を、 1.1 に設定します。
== 次が1個以上の [CODE(charname)@en[[[SP]]]] であれば、すべて無視します。
== [21] 次に[[ASCII数字]]列があれば、[VAR[応答]]の[[状態符号]]をその[[十進整数]]値に設定します。
== [9] 次の1個以上の [CODE(charname)@en[[[SP]]]] があれば、
=== [4] [VAR[応答]]の[[理由句]]を、[[行]]のそれより後の部分に設定します。
== [5] それ以外なら、
=== [31] [VAR[応答]]の[[理由句]]を、[[空文字列]]に設定します。
= 先頭が1個[[以上]]の [CODE(charname)@en[[[SP]]]] 列なら、
== [20] 次に[[ASCII数字]]列があれば、[VAR[応答]]の[[状態符号]]をその[[十進整数]]値に設定します。
== [10] 次の1個以上の [CODE(charname)@en[[[SP]]]] があれば、
=== [22] [VAR[応答]]の[[理由句]]を、[[行]]のそれより後の部分に設定します。
== [29] それ以外なら、
=== [30] [VAR[応答]]の[[理由句]]を、[[空文字列]]に設定します。
]FIG]

[23] 更に、次のようにします。
[FIG(steps)[
= [VAR[最後のヘッダー]]を、 null に設定します。
= 残りの各行について順番に、
== 先頭の文字が 0x20 か 0x09 なら、
=== [VAR[最後のヘッダー]]が null 以外なら、
==== 行の先頭から 0x20 と 0x09 をすべて除去します。
==== [VAR[最後のヘッダー]]の値の末尾に、 0x20 と行の内容を追加します。
== 先頭の文字が 0x3A でなく、 0x3A が含まれるなら、
=== [VAR[最後のヘッダー]]を、 0x3A より前の部分を名前、 0x3A より後の部分を値とするヘッダーに設定します。
=== [VAR[応答]]の[[ヘッダーリスト]]の末尾に、[VAR[最後のヘッダー]]を追加します。
== それ以外なら、
=== [VAR[最後のヘッダー]]を、 null に設定します。
= [VAR[応答]]の[[ヘッダーリスト]]の各ヘッダーについて、
== 名前の末尾から 0x20 と 0x09 をすべて除去します。
== 値の先頭から 0x20 と 0x09 をすべて除去します。
== 値の末尾から 0x20 と 0x09 をすべて除去します。
]FIG]

** WebSocket フレームの処理

[189] [[WebSocketフレーム]]の処理は、次のようにします。
[FIG(steps)[
= [168] [VAR[フレーム]]の [[opcode]] が 8 なら、
== [199] [VAR[一時バッファー]]の長さが1なら、
=== [201] 理由[[空文字列]]で失敗とします。ここで停止します。
== [202] [VAR[一時バッファー]]が空でないなら、
=== [203] [VAR[フレーム]]の[[状態符号]]を、
[VAR[一時バッファー]]の先頭2バイトを[[ネットワークバイト順]]の[[符号無し16ビット整数]]として解釈した値とします。
=== [206] [VAR[フレーム]]の[[状態符号]]が [CODE[[[1005]]]] か [CODE[[[1006]]]] なら、
==== [207] 理由[[空文字列]]で失敗とします。ここで停止します。
=== [208] [VAR[フレーム]]の[[理由]]を、[VAR[一時バッファー]]から先頭2バイトを除いたものを入力として
[[utf-8復号器]]をエラーモード致死的で実行した出力とします。
=== [209] 失敗の場合は、理由 [CODE[Invalid UTF-8 in Close frame]] で失敗とします。ここで停止します。
== [213] [VAR[WebSocket接続の状態]]が [CODE[CLOSING]] でなければ、
=== [210] [VAR[WebSocket接続の状態]]を、 [CODE[CLOSING]] に設定します。
=== [211] [VAR[要求]]について、WebSocket終了開始を通知します。
=== [216] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:8
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[フレーム]]に[[状態符号]]がなければ空。そうでなければ、
[VAR[フレーム]]の[[状態符号]]を表す[[16ビット符号無し整数]] ([[ネットワークバイト順]]) と、
それに続けて理由
]FIG]
=== [307] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
=== [308] [VAR[接続]]で、作成した[[WebSocketフレーム]]を送信することにします。
== [218] [VAR[状態]]を、「WebSocket切断待ち」に設定します。
== [228] [VAR[終了]]を、次の通り設定します。
[FIG(list members)[
:失敗:[[偽]]
:cleanly:[[真]]
:状態符号:[VAR[フレーム]]の[[状態符号]] (なければ [CODE[1005]])
:理由:[VAR[フレーム]]の理由 (なければ[[空文字列]])
]FIG]
== [219] [VAR[種別]]が[[サーバー]]なら、
=== [311] 次の要求に進みます。
== [312] それ以外なら、
=== [313] [VAR[切断タイマー]]で、 1s 後に次の要求に進むことにします。
= [168] [VAR[フレーム]]の [[opcode]] が 9 なら、
== [222] [VAR[要求]]について、 ping を通知します。[VAR[一時バッファー]]をデータとして引き渡します。
== [223] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:10
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[一時バッファー]]
]FIG]
== [309] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
== [310] [VAR[接続]]で、作成した[[WebSocketフレーム]]を送信することにします。
= [168] [VAR[フレーム]]の [[opcode]] が 10 なら、
== [221] [VAR[要求]]について、 ping を通知します。返答フラグを設定し、
[VAR[一時バッファー]]をデータとして引き渡します。
= [168] [VAR[フレーム]]の [[opcode]] が 0, 1, 2 なら、
== [169] [VAR[フレーム]]の [[opcode]] が 0 なら、
=== [177] [VAR[先頭フレーム]]のデータの末尾に[VAR[一時バッファー]]を追加します。
=== [194] ただし実装の扱える長さを超える場合は、失敗とします。ここで停止します。
== [197] それ以外なら、
=== [198] [VAR[フレーム]]のデータを、[VAR[一時バッファー]]に設定します。
== [181] [VAR[フレーム]]の FIN が 1 なら、
=== [182] [VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]の [[opcode]]、
それ以外なら[VAR[フレーム]]の [[opcode]] が 1 なら、
==== [180] [[utf8復号器]]を実行します。
入力を、[VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]のデータ、
それ以外なら[VAR[フレーム]]のデータとします。
エラーモードを致死的に設定します。
==== [178] 失敗なら、理由 [CODE[Invalid UTF-8 in text frame]] で失敗とします。ここで停止します。
==== [183] [VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]のデータ、
それ以外なら[VAR[フレーム]]のデータを、結果に設定します。
=== [179] [VAR[要求]]について、データ受信を通知します。
[VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]のデータ、
それ以外なら[VAR[フレーム]]のデータを引き渡します。
=== [187] [VAR[先頭フレーム]]を、 null に設定します。
]FIG]

* FTP

@@
[639] XXX

* References

[621] The terms [DFN[[[serialize an integer]]]], [DFN[[[URL record]]]],
[DFN[[F[scheme][URL scheme]]]], [DFN[[F[host]]][URL's host]], and [DFN[[F[port]]][URL's port]]
are defined in the [[URL Standard]].

* XXX

@@
[354] 要求の送信:
= 利用可能な接続の選択
=- 起源サーバーへの接続
=- プロキシ接続
= なければ接続の確立
== プロキシの決定
== 下位層プロキシ接続
== 名前解決
== 起源サーバーまたはプロキシへの接続
= 接続できなければ、[[ネットワークエラー]]で停止
= 要求の作成
= 要求ヘッダー
=- 起源サーバー向け
=- プロキシ向け

@@
[355] 起源サーバーからの応答の受信
- [CODE(HTTP)[[[407]]]] なら、[[ネットワークエラー]]
- [[内容符号化]]

@@
[356] [[HTTP]] プロキシからの応答の受信
- [CODE(HTTP)[[[407]]]] なら、...

@@
[357] [[HTTP]] [CODE(HTTP)[[[CONNECT]]]] プロキシからの応答の受信
- [CODE(HTTP)[[[407]]]] なら、...
- その他非 [CODE(HTTP)[[[200]]]] なら、[[ネットワークエラー]]

@@
[384] 認証の通知
- 認証ダイアログ ([[TLSクライアント認証]])

@@
[539] [[WebSocket]]

@@
[541] [[HTTPキャッシュ]]

@@
[65] 
- reset vs abort
- [[flagged as full]]
- HTTP/2
- server