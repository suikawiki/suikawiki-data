* Introduction

''This section is non-normative.''

[907] This document is an implementation of Web transport protocols.

* Fetch and connections

[822] In the steps to [[obtain a connection]], to establish an HTTP connection,
run these steps:
[FIG(steps)[
= [808] Let [VAR[transport]] be the result of
[[establishing a transport][establish a transport]]
for the request's [F[current url]], [VAR[credentials]] flag, and the [[user agent]].
= [823] If [VAR[transport]] is a [[failure]]:
== [824] Return a [[failure]].
= [825] Otherwise:
== [826] Return an [[HTTP connection]]:
[FIG(list members)[
[FIGCAPTION[
[[HTTP connection]]
]FIGCAPTION]
: [F[endpoint type][connection's endpoint type]] : [CODE[client]]
: [F[transport][connection's transport]] : [VAR[transport]]
]FIG]
]FIG]

[809] To [[obtain a WebSocket connection]] for [VAR[url]], run these steps:
[FIG(steps)[
= [821] Let [VAR[transport]] be the result of
[[establishing a transport][establish a transport]]
for [VAR[url]] and the [[user agent]], with [VAR[ws]] flag set.
= [827] If [VAR[transport]] is a [[failure]]:
== [828] Return a [[failure]].
= [829] Otherwise:
== [830] Return an [[HTTP connection]]:
[FIG(list members)[
[FIGCAPTION[
[[HTTP connection]]
]FIGCAPTION]
: [F[endpoint type][connection's endpoint type]] : [CODE[client]]
: [F[transport][connection's transport]] : [F[transport]]
]FIG]
]FIG]

[607] To [DFN[wait for other connections]] with [VAR[host]] and [VAR[port]]
in [VAR[user agent]], run these steps:
[FIG(steps)[
= [831] If [VAR[host]] is a [[domain]]:
== [832] Let [VAR[n]] be an implementation dependent small number.
= [833] Otherwise:
== [834] Let [VAR[n]] be [N[1]].
= [835] Wait while the number of [[connections][connection]]
whose 
[F[remote address or domain][transport's remote address or domain]] is [VAR[host]],
[F[remote port][transport's remote port]] is [VAR[port]], and
[F[WebSocket接続の状態]] is [CODE[CONNECTING]],
in [VAR[user agent]]'s [F[connection pool]],
is ''not'' less than [VAR[n]].
]FIG]

[896] To modify [VAR[request]]'s [F[header list][request's header list]] per HTTP
in [[HTTP-network-or-cache fetch]], run these steps:
[FIG(steps)[
= [898] Append [CODE[Accept-Encoding]] header, if necessary.
= [897] Append [CODE[DNT]] header, if necessary.
= [899] Append [CODE[Upgrade-Insecure-Requests]] header, if necessary.
]FIG]

[838] To make an HTTP request over [VAR[connection]] using [VAR[request]]
in [[HTTP-network fetch]], 
with [VAR[credentials]] flag and optional [VAR[not retryable]] flag,
run these steps:
[FIG(steps)[
= [837] If [VAR[connection]]'s [F[transport][connection's transport]]'s
[F[http protocol][transport's http protocol]] is [CODE[http2]]:
== 
@@
= [541] If [VAR[connection]]'s [F[transport][connection's transport]]'s
[F[request mode]] is ''HTTP proxy'':
== [845] Let [VAR[target]] be the result of applying [[URL serializer]] to
[VAR[request]]'s [F[current url]] with [VAR[exclude fragment flag]] set.
= [843] Otherwise:
== [844] Let [VAR[target]] be [VAR[request]]'s [F[current url]]'s [F[pathquery]].
= [901] Let [VAR[host header]] be [VAR[request]]'s [F[current url]]'s [F[hostport]].
= [900] Append [CODE[Host]]/[VAR[host header]] to [VAR[request]]'s [F[header list][request's header list]].
= [905] Append [CODE[Connection]]/[CODE[keep-alive]] to [VAR[request]]'s
[F[header list][request's header list]].
= [840] Send an [[HTTP request]] over [VAR[connection]].
[FIG(list members)[
[FIGCAPTION[
[[HTTP request]]
]FIGCAPTION]
: [F[要求メソッド]] : [VAR[request]]'s [F[method][request method]]
: [F[要求対象]] : [VAR[target]]
: [F[ヘッダーリスト]] : [VAR[request]]'s [F[header list][request's header list]]
: [F[本体]] : [VAR[request]]'s [F[body][request body]]
]FIG]
= [839] Process notifications from [VAR[connection]] as follows:
[FIG(switch)[
: 要求の本体の一部の送信の通知 : Process [VAR[transmitted]] as follows:
[FIG(steps)[
= 
@@ Increase [VAR[request]]'s [F[body][request body]] stream's transmitted bytes
]FIG]
: 要求の送信完了の通知 :
[FIG(steps)[
= 
@@ Set [VAR[request]]'s [F[body][request body]] stream's done flag
]FIG]
: 応答のヘッダー受信完了の通知 : Process [VAR[http response]] as follows:
[FIG(steps)[
= [856] If [VAR[connection]]'s [F[transport][connection's transport]]'s
[F[request mode]] is ''not'' ''HTTP proxy'' and
[VAR[http response]]'s [F[状態符号]] is [CODE[407]]:
== [857] Set [VAR[response]] to a [[network error]].
= [858] Otherwise:
== [841] Set [VAR[response]] to a [[response]].
[FIG(list members)[
[FIGCAPTION[
[[Response][response]]
]FIGCAPTION]
: [F[status][status code]] : [VAR[http response]]'s [F[状態符号]]
: [F[status message]] : [VAR[http response]]'s [F[理由句]]
: [F[header list][response's header list]] : [VAR[http response]]'s [F[ヘッダーリスト]]
: [F[HTTPS state]] : [VAR[connection]]'s [F[transport][connection's transport]]'s
[F[HTTPS state][connection's HTTPS state]]
]FIG]
== [892] If [VAR[connection]]'s [F[transport][connection's transport]]'s
[F[protocol][transport's protocol]] is 
[CODE[tls]] and [VAR[connection]]'s [F[transport][connection's transport]]'s
[F[has alert]] is [[false]]:
=== [893] Process the HSTS header of [VAR[response]], if any.
=== [894] Process the PKP headers of [VAR[response]], if any.
= [842] Now ''headers are transmitted''.  Return [VAR[response]].
]FIG]
: データ受信の通知 : Process [VAR[data]] as follows:
[FIG(steps)[
= 
@@ Write [VAR[data]] to [VAR[response]]'s [F[body][response body]] stream
]FIG]
: データ終了の通知 :
[FIG(steps)[
= 
@@ Set [VAR[response]]'s [F[body][response body]] stream's done flag
]FIG]
: 完了の通知 : Process [VAR[http response]] and [VAR[exit status]] as follows:
[FIG(steps)[
= [851] If [VAR[exit status]]'s [F[失敗]] is true:
== [852] If ''headers are transmitted'':
=== [855] Mutate [VAR[response]] into a [[network error]].
== [257] Otherwise, if [VAR[not retryable]] is [[false]] and 
[VAR[exit status]]'s [F[can retry][exit's can retry]] is [[true]]:
=== [882] Let [VAR[connection]] be the result of 
[[obtaining a connection][obtain a connection]], given [VAR[request]]'s 
[F[current url]]'s [F[origin]] and [VAR[credentials]].
=== [883] If [VAR[connection]] is a [[failure]], return a [[network error]]
and abort these steps.
=== [884] Return the result of recursively making an HTTP request
over [VAR[connection]] using [VAR[request]],
with [VAR[credentials]] flag, with [VAR[not retryable]] flag set.
== [854] Otherwise:
=== [853] Return a [[network error]].
]FIG]
]FIG]
]FIG]

@@ TLS client certificate dialog

@@
[357] [[HTTP]] [CODE(HTTP)[[[CONNECT]]]] プロキシからの応答の受信
- [CODE(HTTP)[[[407]]]] なら、...
- その他非 [CODE(HTTP)[[[200]]]] なら、[[ネットワークエラー]]

@@
[539] [[WebSocket]] client/server steps

* Domain names

** Name resolution

[615] The [DFN[name resolution steps]] for [VAR[host]] are these steps:
[FIG(steps)[
= [616] If [VAR[host]] is a [[domain]]:
== [617] Return the result of applying [[platform]]'s [[name resolution]]
steps to [VAR[host]].
= [618] Otherwise:
== [619] Return [VAR[host]].
]FIG]

;; [620] These steps return an [[IPv4 address]], an [[IPv6 address]],
or an [[error]].

@@ caching of the result

** Verification of service identity

[943] The [DFN[service identity verification steps]] for [VAR[host]] and
[VAR[certificate]] are these steps:
[FIG(steps)[
= [947] Let [VAR[domains]] be a list of the [CODE[dNSName]] values in [VAR[certificate]]'s 
[CODE[subjectAltName]] [[extension][TLS extension]], if any.
= [948] Let [VAR[addresses]] be a list of the [CODE[iPAddress]] values in [VAR[certificate]]'s 
[CODE[subjectAltName]] [[extension][TLS extension]], if any.
= [949] If all of these conditions are [[true]]:
[FIG(list)[
- [964] [VAR[domains]] is empty
- [965] [VAR[addresses]] is empty
- [966] [VAR[certificate]]'s [CODE[subject]] field has any [CODE[CN]] value
]FIG]
== [967] Let [VAR[cn]] be [VAR[certificate]]'s [CODE[subject]] field has 
the first [CODE[CN]] value.
= [968] Otherwise:
== [969] Let [VAR[cn]] be [[null]].
= [944] If [VAR[host]] is a [[domain]]:
== [958] For each [VAR[domain]] in [VAR[domains]]:
=== [957] If [VAR[host]] [[domain-pattern matches][domain-pattern match]] [VAR[domain]]:
==== [959] Return [[true]] and abort these steps.
== [970] If [VAR[cn]] is not [[null]] and
[VAR[host]] [[domain-pattern matches][domain-pattern match]] [VAR[cn]]:
=== [971] Return [[true]] and abort these steps.
= [945] Otherwise, if [VAR[host]] is an [[IPv4 address]]:
== [954] For each [VAR[address]] in [VAR[addresses]]:
=== [955] If [VAR[address]] represents the same [[IPv4 address]] as [VAR[host]]:
==== [956] Return [[true]] and abort these steps.
== [963] If [VAR[cn]] is the result of applying [[IPv4 serializer]] to [VAR[host]]:
=== [972] Return [[true]] and abort these steps.
= [946] Otherwise, if [VAR[host]] is an [[IPv6 address]]:
== [950] For each [VAR[address]] in [VAR[addresses]]:
=== [951] If [VAR[address]] represents the same [[IPv6 address]] as [VAR[host]]:
==== [952] Return [[true]] and abort these steps.
= [953] Return [[false]].
]FIG]

[960] Whether a [[domain]] [VAR[domain]] [DFN[domain-pattern matches][domain-pattern match]]
a string [VAR[pattern]] or not is the value returned by the following steps:
[FIG(steps)[
= [962] If the last character of [VAR[pattern]], if any, is a [CODE[.]] character:
== [973] Return [[false]] and abort these steps.
= [975] Let [VAR[canonicalized pattern]] be [VAR[pattern]], [[converted to ASCII lowercase]].
= [974] If [VAR[domain]] is [VAR[canonicalized pattern]], optionally followed by
a [CODE[.]] character:
== [976] Return [[true]] and abort these steps.
= [977] If the first two characters of [VAR[canonicalized pattern]], if any, is [CODE[*.]]:
== [979] Remove the first two characters from [VAR[canonicalized pattern]].
== [980] If [VAR[canonicalized pattern]] does not contain any [CODE[.]] character,
or [VAR[canonicalized pattern]] is one of [[ICANN DOMAINS]]:
=== [982] Return [[false]] and abort these steps.
== [983] If [VAR[domain]] is one or more characters,
followed by [VAR[canonicalized pattern]], optionally followed by a [CODE[.]] character:
=== [984] Return [[true]] and abort these steps.
= [978] Return [[false]].
]FIG]

* URLs

[1058] The [DFN[[F[hostport]]]] of a [[URL record]] [VAR[url]] is the concatenation of:
[FIG(list)[
= [1059] [F[host]]
= [902] If [VAR[url]]'s [F[port]] is not [[null]]:
== [903] [CODE[:]]
== [904] [VAR[url]]'s [F[port]], [[serialized][serialize an integer]]
]FIG]

[622] The [DFN[effective port]] of [VAR[url]] is the value returned by these steps:
[FIG(steps)[
= [623] Let [VAR[port]] be [VAR[url]]'s [F[port][URL's port]].
= [624] If [VAR[port]] is [[null]]:
== [625] Set [VAR[port]] to the value determined by the [VAR[url]]'s [F[scheme][URL scheme]]:
[FIG(switch)[
: [CODE(URI)@en[ftp]] : [[21]]
: [CODE(URI)@en[http]] : [[80]]
: [CODE(URI)@en[https]] : [[443]]
]FIG]
= [626] Return [VAR[port]].
]FIG]

[1057] The [DFN[[F[pathquery]]]] of a [[URL record]] [VAR[url]] is the concatenation of:
[FIG(list)[
= [846] [CODE[/]]
= [847] The strings in [VAR[url]]'s [F[path]], separated from each other by [CODE[/]]
= [848] If [VAR[url]]'s [F[query]] is not [[null]]:
== [849] [CODE[?]]
== [850] [VAR[url]]'s [F[query]]
]FIG]

* Proxies

** Proxy configuration data structures

[612] A [DFN[proxy configuration]] has [DFN[[F[protocol][proxy's protocol]]]], which is one of:
[CODE[tcp]],
[CODE[unix]],
[CODE[http]],
[CODE[https]],
[CODE[socks4]], and
[CODE[socks5]].

;; [1017] The value [CODE[tcp]] represents direct access (i.e. no proxy).

[613] A [[proxy configuration]] whose [F[protocol][proxy's protocol]] is
[CODE[http]], [CODE[https]], [CODE[socks4]], or [CODE[socks5]] has
[DFN[[F[host][proxy's host]]]], whose value is a [[host]], and
[DFN[[F[port][proxy's port]]]], whose value is an [[integer]] or [[null]].
The initial value of the [F[port][proxy's port]] is [[null]].

[543] A [[proxy configuration]] whose [F[protocol][proxy's protocol]] is
[CODE[http]] or [CODE[https]] has [DFN[[F[username][proxy's username]]]],
whose value is a [[string]],
and [DFN[[F[password][proxy's password]]]], whose value is a [[string]] or [[null]].
The initial value of the [F[username][proxy's username]] is the [[empty string]].
The initial value of the [F[password]] is [[null]].

[614] A [[proxy configuration]] whose [F[protocol][proxy's protocol]] is
[CODE[unix]] has [DFN[[F[path][proxy's path]]]], whose value is a [[byte string]].


[1000] A [[user agent]] has following fields:
[FIG(list members)[
: [DFN[[F[HTTP proxy]]]] : A [[proxy configuration]] or [[null]].
: [DFN[[F[HTTPS proxy]]]] : A [[proxy configuration]] or [[null]].
: [DFN[[F[FTP proxy]]]] : A [[proxy configuration]] or [[null]].
: [DFN[[F[SOCKS proxy]]]] : A [[proxy configuration]] or [[null]].
: [DFN[[F[[[PAC]] [[URL]]]]  : A [[URL record]] or [[null]].
: [DFN[[F[use [[WPAD]] flag]]]] : A [[boolean]].
: [DFN[[F[no proxy hosts]]]] : A list of [[host]]s.
]FIG]

[1043] A [[user agent]] [MAY[MAY]] allow the [[user]] to configure
values of these fields in implementation-dependent ways.

** Proxy configuration environment variables

[836] If a [[user agent]] supports [[environment variable]]s, 
it [MUST[MUST]] run these steps upon initialization:
[FIG(steps)[
= [1021] Set the [[user agent]]'s [F[HTTP proxy]] to the result of
[[parsing environment variable][parse an environment variable]] [CODE[http_proxy]].
= [1022] Set the [[user agent]]'s [F[HTTPS proxy]] to the result of
[[parsing environment variable][parse an environment variable]] [CODE[https_proxy]].
= [1023] Set the [[user agent]]'s [F[FTP proxy]] to the result of
[[parsing environment variable][parse an environment variable]] [CODE[ftp_proxy]].
= [1037] Let [VAR[no_proxy]] be the result of
[[getting the environment variable][get an environment variable]] [CODE[no_proxy]].
= [1038] If [VAR[no_proxy value]] is not [[null]] and is not the [[empty string]]:
== [1039] For each substring [VAR[value]] obtained by splitting [VAR[no_proxy value]]
by a [CODE[,]] character:
=== [1040] Remove any leading and trailing [[C0 controls and space]] characters
from [VAR[value]].
=== [1041] Let [VAR[host]] be the result of applying the [[host parser]] to [VAR[value]].
=== [1042] If [VAR[host]] is not an error,
append [VAR[host]] to the [[user agent]]'s [F[no proxy hosts]].
]FIG]

[1024] To [DFN[parse an environment variable]] whose name is [VAR[name]],
run these steps:
[FIG(steps)[
= [1025] Let [VAR[value]] be the result of 
[[getting the environment variable][get an environment variable]] [VAR[name]].
= [1026] If [VAR[value]] is [[null]] or the [[empty string]]:
== [1027] Return [[null]] and abort these steps.
= [1055] Let [VAR[url]] be the result of applying the [[proxy environment variable parser]]
to [VAR[value]].
= [1030] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE[http][http:]]
or [CODE[https][https:]]:
== [1031] Return a [[proxy configuration]].
[FIG(list members)[
[FIGCAPTION[
[[Proxy configuration][proxy configuration]]
]FIGCAPTION]
: [F[protocol][proxy's protocol]] : [VAR[url]]'s [F[scheme][URL scheme]]
: [F[host][proxy's host]] : [VAR[url]]'s [F[host][URL's host]]
: [F[port][proxy's port]] : [VAR[url]]'s [F[port][URL's port]]
: [F[username][proxy's username]] : [VAR[url]]'s [F[username][URL's username]]
: [F[password][proxy's password]] : [VAR[url]]'s [F[password][URL's password]]
]FIG]
= [1032] Otherwise, if [VAR[url]]'s [F[scheme][URL scheme]] is [CODE[socks4][socks4:]]
or [CODE[socks5][socks5:]] and [CODE[url]]'s [F[host][URL's host]] is not [[null]]:
== [1033] Return a [[proxy configuration]].
[FIG(list members)[
[FIGCAPTION[
[[Proxy configuration][proxy configuration]]
]FIGCAPTION]
: [F[protocol][proxy's protocol]] : [VAR[url]]'s [F[scheme][URL scheme]]
: [F[host][proxy's host]] : [VAR[url]]'s [F[host][URL's host]]
: [F[port][proxy's port]] : [VAR[url]]'s [F[port][URL's port]]
]FIG]
= [1034] Otherwise:
== [1035] The [[user agent]] [MAY[MAY]] report an error and [MAY[MAY]]
terminate the [[user agent]].
== [1036] Return [[null]].
]FIG]

[1045] To [DFN[get an environment variable]] with string [VAR[name]], run these steps:
[FIG(steps)[
= [1046] If the [[user agent]]'s [[process]] has an [[environment variable]]
whose name is [VAR[name]]:
== [1047] Let [VAR[value]] be the value of the [[user agent]]'s [[process]]'s
[[environment variable]] whose name is [VAR[name]].
== [1049] Let [VAR[encoding]] be the [[encoding]] of the [[platform]].
== [1048] Return the result of [[decoding][decode]] [VAR[value]] in [VAR[encoding]].
= [1050] Otherwise:
== [1051] Return [[null]].
]FIG]

[1056] When the [DFN[proxy environment variable parser]] is applied to
a string [VAR[value]], the implementation [MUST[MUST]] run these steps:
[FIG(steps)[
= [1028] If [VAR[value]] does not begin with a [[scheme][URL scheme (syntax)]]
followed by [CODE[://]],
prepend [CODE[http://]] to [VAR[value]].
= [1029] Return the result of applying the [[URL parser]] to [VAR[value]].
]FIG]

** Fetching PAC scripts

[1004] A [[user agent]] has a [F[[[PAC]] script]], which is initially [[null]].

[1001] If [F[use [[WPAD]] flag]] is [[true]], the [[user agent]] [MUST[MUST]]
send appropriate [[WPAD]] request.

[1003] If a [[PAC]] [[URL]] is provided by [[WPAD]] processing,
the [[user agent]] [MUST[MUST]] [[fetch]] the [[PAC]] file.
Otherwise, if [F[[[PAC]] [[URL]]]] is not [[null]],
the [[user agent]] [MUST[MUST]] [[fetch]] the [F[[[PAC]] [[URL]]]].
When a [[PAC]] script file is [[fetch]]ed, the [[user agent]]'s
[F[[[PAC]] script]] [MUST[MUST]] be set to the file.

** Choosing proxy configurations

[1010] To [DFN[get proxies]] for [[URL record]] [VAR[url]], run these steps:
[FIG(steps)[
= [1018] For each [[host]] [VAR[host]] in the [[user agent]]'s [F[no proxy hosts]]:
== [1019] If [VAR[host]] [[equals][host equivalence]] [VAR[url]]'s [F[host]]:
=== [1020] Return a list whose only member is a [[proxy configuration]]
whose [F[protocol][proxy's protocol]] is [CODE[tcp]] and abort these steps.
= [544] If the [[user agent]]'s [F[[[PAC]] script]] is not [[null]]:
== [545] Process the [[user agent]]'s [F[[[PAC]] script]] with [VAR[url]].
== [1011] Return the result of the previous step and abort these steps.
= [609] If the [[user agent]]'s [F[SOCKS proxy]] is not [[null]]:
== [610] Return a list whose only member is the [[user agent]]'s [F[SOCKS proxy]]
and abort these steps.
= [611] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE[http][http:]] and 
the [[user agent]]'s [F[HTTP proxy]] is not [[null]]:
== [1012] Return a list whose only member is the [[user agent]]'s [F[HTTP proxy]]
and abort these steps.
= [1013] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE[https][https:]] and 
the [[user agent]]'s [F[HTTPS proxy]] is not [[null]]:
== [1014] Return a list whose only member is the [[user agent]]'s [F[HTTPS proxy]]
and abort these steps.
= [1015] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE[ftp][ftp:]] and 
the [[user agent]]'s [F[FTP proxy]] is not [[null]]:
== [1016] Return a list whose only member is the [[user agent]]'s [F[FTP proxy]]
and abort these steps.
= [546] Return a list whose only member is a [[proxy configuration]]
whose [F[protocol][proxy's protocol]] is [CODE[tcp]].
]FIG]

;; [1052] [VAR[url]]'s [F[scheme][URL scheme]] has to be a [[network scheme]].

* Transports

[640] A [DFN[transport]] has following states:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [DFN[[F[protocol]]][transport's protocol]] :
One of 
[CODE[tcp]],
[CODE[unix]],
[CODE[http1connect]],
[CODE[http2connect]],
[CODE[tls]],
[CODE[socks4]], and
[CODE[socks5]].
: [DFN[[F[endpoint type][transport's endpoint type]]]] :
Either [CODE[client]] or [CODE[server]].
: [DFN[[F[remote address or domain][transport's remote address or domain]]]] :
A [[domain]] or [[null]].  Unless stated otherwise, the value is [[null]].
: [DFN[[F[remote port][transport's remote port]]]] :
An [[integer]] or [[null]].
: [DFN[[F[proxy configuration][transport's proxy configuration]]]] : A [[proxy configuration]].
: [DFN[[F[http protocol][transport's http protocol]]]] :
Either [CODE[http1]] or [CODE[http2]].
Unless stated otherwise, the value is [CODE[http1]].
:[VAR[送信閉じ済みフラグ]]:初期状態では未設定。
:[VAR[受信閉じ済みフラグ]]:初期状態では未設定。
:[VAR[送信待ちバッファー]]:初期状態では空のリスト。
: [DFN[[F[request mode]]]] :
The value is either ''default'' or ''HTTP proxy''.
If the [F[request mode]] of a [[transport]] is ''HTTP proxy'',
a [[request]] has to be sent over the [[transport]] as an [[HTTP request]]
whose [[request target]] is an [[absolute URL]].
: [DFN[[F[HTTPS state]]][transport's HTTPS state]] :
An [[HTTPS state]] value.  Either [CODE[none]], [CODE[deprecated]], or [CODE[modern]].
Unless stated otherwise, the value is [CODE[none]].
]FIG]

[1054] To [DFN[create a transport for a proxy configuration]] [VAR[proxy]]
with a [[URL record]] [VAR[url]] and optional [VAR[ws]] flag, run rhese steps:
[FIG(steps)[
= [549] If [VAR[user agent]] does not support [VAR[proxy]]'s [F[protocol]]:
== [550] Return a [[failure]] and abort these steps.
= [551] Switch by [VAR[proxy]]'s [F[protocol]]:
[FIG(switch)[
: [CODE[tcp]] :
[FIG(steps)[
= [552] Set [VAR[effective port]] be the [[effective port]] of [VAR[url]].
= [553] Set [VAR[addr]] to the result of applying [[name resolution steps]] 
to [VAR[url]]'s [F[host][URL's host]].
= [554] If [VAR[addr]] is an [[error]]:
== [555] Return a [[failure]] and abort these steps.
= [557] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[addr]] and [VAR[port]].
= [558] Return the result of 
[[establishing a TCP transport][establish a TCP transport]]
to [VAR[addr]] and [VAR[effective port]].
]FIG]
: [CODE[unix]] :
[FIG(steps)[
= [559] Return the result of
[[establishing a UNIX socket domain transport][establish a UNIX socket domain transport]]
with [VAR[proxy]]'s [F[path][proxy's path]], [VAR[url]]'s [F[host][URL's host]],
and [VAR[url]]'s [[effective port]].
]FIG]
: [CODE[http]] or [CODE[https]] :
[FIG(steps)[
= [560] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[url]]'s [F[host]] and [VAR[port]].
= [561] Let [VAR[proxy port]] be [VAR[proxy]]'s [F[port]].
= [562] If [VAR[proxy port]] is [[null]]:
== [563] If [VAR[proxy]]'s [F[protocol]] is [CODE[http]], set [VAR[proxy port]] to [N[80]].
== [564] If [VAR[proxy]]'s [F[protocol]] is [CODE[https]], set [VAR[proxy port]] to [N[443]].
= [565] Let [VAR[proxy addr]] be the result of applying [[name resolution steps]] 
to [VAR[proxy]]'s [F[host]].
= [566] If [VAR[proxy addr]] is an [[error]]:
== [567] Return a [[failure]] and abort these steps.
= [568] Let [VAR[transport]] be the result of 
[[establishing a TCP transport][establish a TCP transport]]
to [VAR[proxy addr]] and [VAR[proxy port]].
= [570] If [VAR[proxy]]'s [F[protocol]] is [CODE[https]]:
== [571] Set [VAR[transport]] to the result of running the [[TLS steps]] for
[VAR[transport]] and [VAR[proxy]]'s [F[host]].
= [556] If [VAR[transport]] is a [[failure]]:
== [569] Return a [[failure]] and abort these steps.
= [572] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[https]]:
== [577] Let [VAR[http]] be an [[HTTP connection]]:
[FIG(list members)[
[FIGCAPTION[
[[HTTP connection]]
]FIGCAPTION]
: [F[endpoint type][connection's endpoint type]] : [CODE[client]]
: [F[transport][connection's transport]] : [VAR[transport]]
]FIG]
== [578] Set [VAR[transport]] to the result of
[[establishing an HTTP [CODE(HTTP)[CONNECT]] transport][establish an HTTP [CODE(HTTP)@en[CONNECT]] transport]]
with [VAR[http]] and [VAR[url]].
@@ [VAR[credentials]] flag and proxy credentials
== [579] If [VAR[transport]] is a [[failure]] whose HTTP response's [F[status]] is
[CODE[407]]:
=== 
@@ Show proxy auth dialog
= [580] Otherwise:
== [581] Set [VAR[transport]]'s [F[request mode]] to ''HTTP proxy''.
== [576] Set [VAR[transport]]'s 
[F[remote address or domain][transport's remote address or domain]] to [VAR[url]]'s
[F[host][URL's host]].
== [909] Set [VAR[transport]]'s [F[remote port][transport's remote port]] to
[VAR[url]]'s [[effective port]].
= [548] Return [VAR[transport]].
]FIG]
: [CODE[socks4]] :
[FIG(steps)[
= [582] Let [VAR[effective port]] be the [[effective port]] of [VAR[url]].
= [583] Set [VAR[addr]] to the result of applying [[name resolution steps]] 
to [VAR[url]]'s [F[host]].
= [584] If [VAR[addr]] is ''not'' an [[IPv4 address]]:
== [585] Return a [[failure]] and abort these steps.
= [587] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[addr]] and [VAR[port]].
= [588] Let [VAR[proxy port]] be [VAR[proxy]]'s [F[port]].
= [589] If [VAR[proxy port]] is [[null]], set [VAR[proxy port]] to [N[1080]].
= [590] Let [VAR[proxy addr]] be the result of applying [[name resolution steps]] 
to [VAR[proxy]]'s [F[host]].
= [591] Let [VAR[transport]] be the result of 
[[establishing a TCP connection][establish a TCP connection]]
to [VAR[proxy addr]] and [VAR[proxy port]].
= [592] Return the result of
[[establishing a SOCKS4 connection][establish a SOCKS4 connection]]
with [VAR[transport]], [VAR[addr]], and [VAR[effective port]].
]FIG]
: [CODE[socks5]] :
[FIG(steps)[
= [593] Let [VAR[effective port]] be the [[effective port]] of [VAR[url]].
= [594] If [VAR[ws]] flag is set, [[wait for other connections]]
with [VAR[url]]'s [F[host]] and [VAR[port]].
= [595] Let [VAR[proxy port]] be [VAR[proxy]]'s [F[port]].
= [597] If [VAR[proxy port]] is [[null]], set [VAR[proxy port]] to [N[1080]].
= [596] Let [VAR[proxy addr]] be the result of applying [[name resolution steps]] 
to [VAR[proxy]]'s [F[host]].
= [598] Let [VAR[transport]] be the result of 
[[establishing a TCP transport][establish a TCP transport]]
to [VAR[proxy addr]] and [VAR[proxy port]].
= [599] Return the result of
[[establishing a SOCKS5 transport][establish a SOCKS5 transport]]
with [VAR[transport]], [VAR[url]]'s [F[host]], and [VAR[effective port]].
]FIG]
]FIG]

]FIG]

[542] To [DFN[establish a transport]] for an [[URL record]] [VAR[url]]
and a [[user agent]] [VAR[user agent]], optionally with [VAR[credentials]]
and [VAR[ws]] flags, run these steps:
[FIG(steps)[
= [1009] Let [VAR[proxies]] be the result of [[getting proxies][get proxies]] for [VAR[url]].
= [908] Let [VAR[addr]] be [[null]].
= [914] Let [VAR[port]] be [VAR[url]]'s [F[port]].
= [547] For each [VAR[proxy]] in [VAR[proxies]], in order, run these substeps:
== [1053] Set [VAR[transport]] to the result of 
[[creating a transport for proxy][create a transport for a proxy configuration]]
[VAR[proxy]] with [VAR[url]] and [VAR[ws]].
== [600] If [VAR[transport]] is not a [[failure]]:
=== [601] If [VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[https][https:]]:
==== [602] Set [VAR[transport]] to the result of running the [[TLS steps]] for
[VAR[transport]], [VAR[url]]'s [F[host]], [VAR[credentials]] flag, and [VAR[ws]] flag,
in [VAR[user agent]].
== [927] If [VAR[transport]] is not a [[failure]]:
=== [1182] Set [VAR[transport]]'s [F[proxy configuration][transport's proxy configuration]]
to [VAR[proxy]].
=== [934] If [VAR[transport]]'s [F[request mode]] is '''not''' ''HTTP proxy'' and
[VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[ftp][ftp:]]:
==== [935] 
@@ Use [[FTP]]
=== [931] Otherwise, if none of these conditions is [[true]]:
[FIG(list)[
- [930] [VAR[transport]]'s [F[request mode]] is ''HTTP proxy''
- [932] [VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[http][http:]]
- [933] [VAR[url]]'s [F[scheme][URL scheme]] is [CODE(URI)@en[https][https:]]
]FIG]
==== [929] Set [VAR[transport]] to a [[failure]].
== [603] If [VAR[transport]] is not a [[failure]]:
=== [605] Return [VAR[transport]] and abort these steps.
= [606] Return a [[failure]].
]FIG]

;; [936] [VAR[url]]'s [F[scheme][URL scheme]] has to be a [[network scheme]].

[642] [[アプリケーション]]は、 [[transport]] に次の指示を行えます。
[FIG(list)[
- [[バイト]]の送信の指示
- 正常終了の送信の指示
- 中断の指示
- credentials の送信の指示
]FIG]

[643] [[バイト]]の送信の指示は、送信する[[バイト]] (0-255 のいずれかの値)と、
[[緊急データ]]か否かのフラグ (既定値は未設定。)
を[[引数]]とし、次のように処理します。
[FIG(steps)[
= [644] [VAR[送信閉じ済みフラグ]]が設定されていれば、[[例外]]を投げて停止します。
= [645] [VAR[送信待ちバッファー]]が満杯なら、[[例外]]を投げて停止します。
= [646] [[緊急データ]]フラグが設定されていて、
[[transport]] の種類が[[緊急データ]]に対応していないものなら、
[[例外]]を投げて停止します。
= [647] [VAR[送信待ちバッファー]]の末尾に、
引数の[[バイト]]、
引数の[[緊急データ]]か否かのフラグ、
[[約束]]の組を追加します。
= [648] 追加した[[約束]]を返します。
]FIG]

;; [649] 返された[[約束]]は、[[バイト]]が送信された際に[[解決]]されます。

[650] [[バイト列]]を送信するとは、当該[[バイト列]]について先頭の[[バイト]]から順に[[バイト]]の送信の指示を行い、最後の[[バイト]]が返した[[約束]]を返す
(空バイト列なら[[解決]]済みの[[約束]]を返す) ことをいいます。

[651] 正常終了の送信の指示は、次のように処理します。
[FIG(steps)[
= [652] [VAR[送信閉じ済みフラグ]]が設定されていれば、[[例外]]を投げて停止します。
= [653] [VAR[送信閉じ済みフラグ]]を設定します。
= [654] [[transport]]の種類に応じた処理を行います。
]FIG]

[655] 中断の指示は、次のように処理します。
[FIG(steps)[
= [656] [VAR[送信閉じ済みフラグ]]と[VAR[受信閉じ済みフラグ]]の両方が設定されていれば、
[[例外]]を投げて停止します。
= [657] [VAR[送信閉じ済みフラグ]]を設定します。
= [658] [VAR[受信閉じ済みフラグ]]を設定します。
= [659] [VAR[送信待ちバッファー]]の先頭の項目から順に、
[[約束]]を[[拒絶]]していきます。
= [660] [[transport]]の種類に応じた処理を行います。
= [661] 中断の通知を行います。リセットフラグを設定します。
]FIG]

[662] [[credentials]] の送信の指示は、
[[transport]]の種類に応じた処理を実行します。そのようなものがなければ、
[[例外]]を投げます。
なお引数として、[[transport]]の種類に応じた [[credentials]] を受け取ります。

[663] [[transport]]は、[[アプリケーション]]に対して次の通知を行います。
[FIG(list)[
- [664] [[バイト]]の受信の通知
[FIG(list members)[
:[[バイト]]:受信した[[バイト]]。 0-255 のいずれかの値。
:[[緊急データ]]フラグ: [[TCP]] [[緊急データ]]か否か。既定値は[[偽]]。
]FIG]
- [665] 正常終了の受信の通知
- [666] 中断の通知
[FIG(list members)[
:[[リセット]]フラグ:[[TCP]] [CODE[[[RST]]]] 相当のものであるか否か。既定値は[[偽]]。
]FIG]
- [667] 警告の通知
- [668] challenge の受信の通知
[FIG(list members)[
: [VAR[transport]] :認証を行う [[transport]]。
:[[challenge]]:プロトコル依存の [[challenge]] データ。
]FIG]
]FIG]

[669] [[transport]]の種類に依存した方法で次の[[バイト]]を送信可能であると判断したら、
次のようにします。
[FIG(steps)[
= [670] [VAR[送信待ちバッファー]]が空なら、ここで停止します。
= [671] [VAR[送信待ちバッファー]]の先頭の項目を取得し、バッファーからは削除します。
= [672] [[transport]]の種類に依存した方法で取得した項目の[[バイト]]を送信します。
(あれば) [[緊急データ]]フラグを引渡します。
= [673] 取得した項目の[[約束]]を[[解決]]します。
]FIG]

** TCP

[627] To [DFN[establish a TCP transport]] to [VAR[addr]] and [VAR[port]],
run these steps:
[FIG(steps)[
= [628] Connect to address [VAR[addr]] and port [VAR[port]] using [[TCP]].
= [641] If a [[TCP connection]] has been established:
== [674] Let [VAR[transport]] be a [[transport]] representing the
[[TCP connection]], with following states:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [F[protocol][transport's protocol]] : [CODE[tcp]]
: [F[endpoint type][transport's endpoint type]] : [CODE[client]]
: [F[remote address or domain][transport's remote address or domain]] : [VAR[addr]]
: [F[remote port][transport's remote port]] : [VAR[port]]
]FIG]
== [630] Disable the [CODE[SO_OOBINLINE]] option of [VAR[transport]]'s connection.
== [631] Enable the [CODE[SO_NODELAY]] option of [VAR[transport]]'s connection.
== [632] Run the [[TCP keep alive steps]] for [VAR[transport]].
== [818] Return [VAR[transport]].
= [629] Otherwise:
== [819] Return a [[failure]].
]FIG]

[634] The [DFN[TCP keep alive steps]] for [VAR[transport]] are implementation
dependent.  An example of such steps is:
[FIG(steps)[
= [635] Enable the [CODE[SO_KEEPALIVE]] option of [VAR[transport]].
= [636] Set [CODE[TCP_KEEPIDLE]] option of [VAR[transport]]'s connection to 45 (seconds).
= [637] Set [CODE[TCP_KEEPINTVL]] option of [VAR[transport]]'s connection to 45 (seconds).
]FIG]

@@ [675] XXX server accept steps

[676] [[TCP]] の[[セグメント]]を受信したら、次のようにします。
[FIG(steps)[
= [677] [[TCP]] に従い処理し、不適切と判断すればここで停止します。
= [678] [CODE[[[RST]]]] フラグが設定されていれば、
== [679] [VAR[送信閉じ済みフラグ]]を設定します。
== [680] [VAR[受信閉じ済みフラグ]]を設定します。
== [681] 中断を通知します。リセットフラグを設定します。
= [682] データの各[[バイト]]について、順に、
== [683] [[バイト]]の受信を通知します。当該[[バイト]]の値を渡します。
[[緊急ポインター]]が本[[バイト]]を指していれば、[[緊急データ]]フラグも設定します。
= [684] [CODE[[[FIN]]]] フラグが設定されていれば、
== [685] [VAR[受信閉じ済みフラグ]]を設定します。
== [686] 正常終了の受信を通知します。
]FIG]

[687] [[タイムアウト]]その他の理由で[[transport]]が利用できないことを検知したら、
次のようにします。
[FIG(steps)[
= [688] [VAR[送信閉じ済みフラグ]]を設定します。
= [689] [VAR[受信閉じ済みフラグ]]を設定します。
= [690] 中断を通知します。
]FIG]

[691] [[バイト]]を送信できるかどうかは、[[フロー制御]]、[[輻輳制御]]その他の状況により決定します。

[692] [[バイト]]の送信は、次のようにします。
[FIG(steps)[
= [693] [[緊急データ]]フラグが設定されていれば、
== [694] 指定された[[バイト]]をデータとして含み、[[緊急ポインター]]が当該[[バイト]]を指す[[セグメント]]を送信することにします。
= [695] それ以外なら、
== [696] 指定された[[バイト]]をデータとして含む[[セグメント]]を送信することにします。
]FIG]

;; [697] 実際の送信時には、前後の[[バイト]]とまとめた[[セグメント]]で送信されたり、
必要に応じて[[再送]]されたりします。

[698] [[緊急データ]]に対応しています。

[699] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [700] [CODE[[[FIN]]]] フラグが設定された[[セグメント]]を送信することにします。
]FIG]

[701] 中断の指示があれば、次のようにします。
[FIG(steps)[
= [702] 必要に応じて [CODE[[[FIN]]]] フラグが設定された[[セグメント]]を送信することにします。
= [703] [[TCP]] で受信したデータの処理を以後行わないことにします。
]FIG]

** HTTP [CODE(HTTP)@en[CONNECT]]

[633] A [[transport]] whose [F[protocol][transport's protocol]] is
[CODE[http1connect]] or [CODE[http2connect]] has following additional states:
[FIG(list members)[
: [DFN[[F[http][transport's http]]]] : An [[HTTP connection]].
: [DFN[[F[established][transport's established]]]] :  A [[boolean]].  Initially, [[false]].
]FIG]

[739] To [DFN[establish an HTTP [CODE(HTTP)@en[CONNECT]] transport]]
with [[HTTP connection]] [VAR[http]] and [[URL record]] [VAR[url]], run these steps:
[FIG(steps)[
= [740] Let [VAR[transport]] be a [[transport]]:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [F[protocol][transport's protocol]] :
If [VAR[http]]'s [F[protocol][connection's protocol]] is [CODE[http2]], [CODE[http2connect]].
Otherwise, [CODE[http1connect]].
: [F[endpoint type][transport's endpoint type]] : [CODE[client]]
: [F[remote address or domain][transport's remote address or domain]] : 
[VAR[url]]'s [F[host][url's host]]
: [F[remote port][transport's remote port]] : [VAR[url]]'s [[effective port]]
: [F[http][transport's http]] : [VAR[http]]
]FIG]
= [766] Send an [[HTTP request]] over [VAR[http]]:
[FIG(list members)[
: [F[method][request method]] : [CODE[CONNECT]]
: [F[request target]] : [VAR[url]]'s [F[hostport]]
: [F[header list]] :
[FIG(list members)[
: [CODE[Host]] : [VAR[url]]'s [F[hostport]]
: [CODE[Proxy-Connection]] : [CODE[keep-alive]]
: [CODE[User-Agent]] : [[default `[CODE[User-Agent]]` value]]
]FIG]
]FIG]
= [741] If failed, return a [[failure]] and abort these steps.
= [817] Process notifications from [VAR[http]] as follows:
[FIG(switch)[
: [744] [[要求]]のヘッダー受信完了の通知 :
[FIG(steps)[
= [745] 応答の状態符号が [CODE(HTTP)[[[200]]]] なら、
== [746] Set [VAR[transport]]'s [F[established][transport's established]] to [[true]].
== [747] Return [VAR[transport]].
= [748] Otherwise:
== [749] Return a [[failure]].
]FIG]
: [750] [[要求]]のデータ受信の通知 :
[FIG(steps)[
= [751] If [VAR[transport]]'s [F[established][transport's established]] is [[true]]:
-= [752] データの各バイトについて、順に、
-== [753] バイトの受信を通知します。当該バイトの値を渡します。
]FIG]
: [754] [[要求]]のデータ終了の通知 :
[FIG(steps)[
= [755] If [VAR[transport]]'s [F[established][transport's established]] is [[true]]:
-= [756] [VAR[受信閉じ済みフラグ]]を設定します。
-= [757] 正常終了の受信を通知します。
]FIG]
: [758] [[要求]]の完了の通知 :
[FIG(steps)[
= [759] If [VAR[connection]]'s [F[exit status][connection's exit status]]'s [F[失敗]] is [[true]]:
== [760] If [VAR[transport]]'s [F[established][transport's established]] is [[true]]:
=== [761] [VAR[送信閉じ済みフラグ]]を設定します。
=== [762] [VAR[受信閉じ済みフラグ]]を設定します。
=== [763] 中断を通知します。
== [764] Otherwise:
=== [765] Return a [[failure]].
]FIG]
]FIG]
]FIG]

@@ [738] XXX server accept steps

[767] バイトは常に送信可能とします。

[768] バイトの送信は、次のようにします。
[FIG(steps)[
= [769] [VAR[transport]]'s [F[http][transport's http]] でトンネルに指定されたバイトを送信します。
]FIG]

[770] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [771] [VAR[transport]]'s [F[http][transport's http]] に接続の正常終了を指示します。
]FIG]

[772] 中断の指示があれば、次のようにします。
[FIG(steps)[
= [773] [VAR[transport]]'s [F[http][transport's http]] に中断を指示します。
]FIG]

*** HTTP/2

@@

** SOCKS4

[743] A [[transport]] whose [F[protocol][transport's protocol]] is
[CODE[socks4]] has following additional states:
[FIG(list members)[
: [DFN[[F[transport][socks4 transport's transport]]]] : A [[transport]].
]FIG]

[774] To [DFN[establish a SOCKS4 transport]]
to [[IPv4 address]] [VAR[address]] and [[port]] [VAR[port]] over 
[[transport]] [VAR[transport]], run these steps:
[FIG(steps)[
= [776] [VAR[transport]]で 0x04 0x01 [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] [VAR[a[SUB[1]]]] [VAR[a[SUB[2]]]]
[VAR[a[SUB[3]]]] [VAR[a[SUB[4]]]] 0x00 を送信します。
=- [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] は[VAR[port]]を[[16ビット符号無し整数]]
([[ネットワークバイト順]]) としたものです。
=- [VAR[a[SUB[1]]]] [VAR[a[SUB[2]]]] [VAR[a[SUB[3]]]] [VAR[a[SUB[4]]]]
は[VAR[address]]を[[32ビット符号無し整数]] ([[ネットワークバイト順]]) としたものです。
= [777] [VAR[transport]]から8バイト受信するのを最大30s待ちます。
= [778] 受信した最初の2バイトが 0x00 0x5A でなければ、
== [779] [VAR[transport]]の中断を指示します。
== [780] Return a [[failure]] and abort these steps.
= [781] Return a [[transport]]:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [F[protocol][transport's protocol]] : [CODE[socks4]]
: [F[endpoint type][transport's endpoint type]] : [CODE[client]]
: [F[remote address or domain][transport's remote address or domain]] : [VAR[address]]
: [F[remote port][transport's remote port]] : [VAR[port]]
: [F[transport][socks4 transport's transport]] : [VAR[transport]]
]FIG]
]FIG]

@@ [742] XXX server

[783] 接続確立後は、指示は[VAR[transport]]への指示とし、
[VAR[transport]]からの通知があればそれを通知します。

** SOCKS5

[775] A [[transport]] whose [F[protocol][transport's protocol]] is
[CODE[socks5]] has following additional states:
[FIG(list members)[
: [DFN[[F[transport][socks5 transport's transport]]]] : A [[transport]].
]FIG]

[784] To [DFN[establish a SOCKS5 transport]]
to destination [VAR[host]] and [[port]] [VAR[port]] over [[transport]] [VAR[transport]],
run these steps:
[FIG(steps)[
= [785] If [VAR[host]] is a [[domain]] whose length is greater than [N[255]]:
== [803] Return a [[failure]] and abort these steps.
= [786] [VAR[transport]]で 0x05 0x01 0x00 を送信します。
= [787] [VAR[transport]]から2バイト受信するのを最大30s待ちます。
= [788] 受信したのが 0x05 0x00 でなければ、
== [789] [VAR[transport]]の中断を指示します。
== [790] Return a [[failure]] and abort these steps.
= [791] [VAR[transport]]で 0x05 0x01 0x00 [VAR[A]] [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]]
を送信します。
=- [VAR[A]] は、
=-= [VAR[host]]が[[ドメイン名]]の場合、[VAR[host]]を [[UTF-8]] に変換したものの前に
[VAR[host]] を [[UTF-8]] に変換したもののバイト数を[[8ビット符号無し整数]]としたものを置いたものです。
=-= [VAR[host]]が[[IPv4アドレス]]の場合、[VAR[host]]を[[32ビット符号無し整数]] ([[ネットワークバイト順]]) としたものです。
=-= [VAR[host]]が[[IPv6アドレス]]の場合、[VAR[host]]を16バイトのバイト列としたものです。
=- [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] は[VAR[port]]を[[16ビット符号無し整数]]
([[ネットワークバイト順]]) としたものです。
= [792] [VAR[transport]]から5バイト受信するのを最大30s待ちます。
= [793] 受信した最初の3バイトが 0x05 0x00 0x00 でないか、
第4バイトが 0x01, 0x03, 0x04 のいずれでもないか、
5バイトに満たなければ、
== [794] [VAR[transport]]の中断を指示します。
== [795] Return a [[failure]] and abort these steps.
= [796] 第4バイトが 0x01 なら、[VAR[transport]]から5バイト受信するのを最大30s待ちます。
= [797] 第4バイトが 0x03 なら、第5バイトを[[8ビット符号無し整数]]として解釈し、
[VAR[transport]]からそのバイト数 + 2 バイト分受信するのを最大30s待ちます。
= [798] 第4バイトが 0x04 なら、[VAR[transport]]から17バイト受信するのを最大30s待ちます。
= [799] 得られたのが指定のバイト数に満たなければ、
== [800] [VAR[transport]]の中断を指示します。
== [801] Return a [[failure]] and abort these steps.
= [802] Return a [[transport]]:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [F[protocol][transport's protocol]] : [CODE[socks5]]
: [F[endpoint type][transport's endpoint type]] : [CODE[client]]
: [F[remote address or domain][transport's remote address or domain]] : [VAR[host]]
: [F[remote port][transport's remote port]] : [VAR[port]]
: [F[transport][socks5 transport's transport]] : [VAR[transport]]
]FIG]
]FIG]

@@ [782] XXX server

[804] 接続確立後は、指示は[VAR[transport]]への指示とし、
[VAR[transport]]からの通知があればそれを通知します。

** UNIX domain socket の場合

[805] To [DFN[establish a UNIX domain socket connection]] for [[byte string]] [VAR[path]]
with [[host]] [VAR[host]] and [[integer]] [VAR[port]], run these steps:
[FIG(steps)[
= [807] [[ソケットAPI]]を使って新たに接続します。
[FIG(list members)[
: [[アドレス族]] :[CODE[[[AF_UNIX]]]]
: [[パス名]] : [VAR[path]]
: [[ソケット型]] : [CODE[[[SOCK_STREAM]]]]
]FIG]
= [806] If failed, return a [[failure]] and abort these steps.
= [820] Return a [[connection endpoint]] representing the socket,
with following states:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [F[protocol][transport's protocol]] : [CODE[unix]]
: [F[endpoint type][transport's endpoint type]] : [CODE[client]]
: [F[remote address or domain][transport's remote address or domain]] : [VAR[host]]
: [F[remote port][transport's remote port]] : [VAR[port]]
]FIG]
]FIG]

@@ [608] XXX server

[810] バイトが送信可能かどうかは、 [CODE[[[send]]]] によりバイト列を送信できるかどうかとします。

[811] バイトの送信は、 [CODE[[[send]]]] によります。

[812] 正常終了の送信の指示があれば、 [CODE[[[shutdown]]]] [CODE[[[SHUT_WR]]]] を実行します。

[813] 中断の指示があれば、 [CODE[[[shutdown]]]] [CODE[[[SHUT_RDWR]]]] を実行します。

[814]  [CODE[[[recv]]]] によりバイト列を受信したら、
各バイトを順に、バイトの受信を通知します。

[815] [CODE[[[recv]]]] で何も受信しなくなれば、
[VAR[送信閉じ済みフラグ]]を設定し、正常終了の受信を通知します。

[816] [CODE[[[send]]]] や [CODE[[[recv]]]] でエラーが発生したら、
[VAR[送信閉じ済みフラグ]]と[VAR[受信閉じ済みフラグ]]を設定し、
中断を通知します。

** TLS

[877] A [[transport]] whose [F[protocol][transport's protocol]] is
[CODE[tls]] has following additional states:
[FIG(list members)[
: [F[is ev]] : A [[boolean]].  Initially, [[false]].
: [F[remote certificates]] : A list of [[certificates][certificate]].
: [F[has alert]] : A [[boolean]].  Initially, [[false]].
]FIG]

[638] The [DFN[TLS steps]] for [VAR[transport]], [VAR[url]], and [VAR[credentials]],
with optional [VAR[ws]] flag,
in [VAR[user agent]] are as follows:
[FIG(steps)[
= 
@@ credentials
= [878] If [VAR[ws]] is true:
== [879] Set [VAR[alpn protocols]] to ([CODE[http/1.1]]).
= [880] Otherwise:
== [881] Set [VAR[alpn protocols]] to ([CODE[h2]], [CODE[http/1.1]]).
==
@@ If switched from HTTP/2 to HTTP/1.1
= [356] Initiate [[TLS handshake]].
[FIG(list members)[
: Minimum TLS version : [CODE[1.0]]
: Underlying transport : [VAR[transport]]
: Compression : Disabled
: [[TLS session]] cache : [VAR[user agent]]'s [F[[[TLS session]] cache]]
: [[SNI]] host : 
If [VAR[url]]'s [F[host]] is a [[domain]], [VAR[url]]'s [F[host]].
Otherwise, [[null]].
: Use [[OCSP stapling]] request : [[true]]
: [[ALPN protocol names][ALPN protocol name]] : [VAR[alpn protocols]]
: Certificate database : [VAR[user agent]]'s [F[certificate database]]
: Additional verification for server certificate [VAR[cert]] :
Return the result of running the [[service identity verification steps]] with
[VAR[url]]'s [F[host]] and [VAR[cert]].
]FIG]
= [861] If failed, return a [[failure]] and abort these steps.
= [865] Let [VAR[alpn]] be the [[ALPN protocol name]] obtained by the TLS handshake.
= [872] Let [VAR[version]] be the [[TLS]] protocol version in use.
= [873] Let [VAR[cipher]] be the [[cipher suite]] and parameters in use.
= [866] If [VAR[alpn]] is [[null]] or [CODE[http/1.1]]:
== [867] Set [VAR[protocol]] to [CODE[http1]].
= [868] Otherwise, if [VAR[alpn]] is [CODE[h2]]:
== [869] Set [VAR[protocol]] to [CODE[http2]].
== [885] If one of the following conditions is met:
[FIG(list)[
- [887] [VAR[version]] is [CODE[1.0]] or [CODE[1.1]]
- [888] [VAR[cipher]]'s [[cipher suite]] is blacklisted by the [[HTTP/2]] specification
- [890] [VAR[cipher]]'s parameter is disallowed by the [[HTTP/2]] specification
]FIG]
===
@@ connection error [CODE[INADEQUATE_SECURITY]]
=== [886] Return a [[failure]] and abort these steps.
= [870] Otherwise:
== [871] Return a [[failure]] and abort these steps.
= [874] Let [VAR[certs]] be the received [[certificates][certificate]].
= [876] Let [VAR[ev]] be whether [VAR[certs]] contain a valid [[EV certificate]] or not.
= [985] Let [VAR[ocsp]] be the [[OCSP stapling]] response, if any, or [[null]].
= [993] For each [VAR[cert]] in [VAR[certs]]'s [[CA certificates][CA certificate]]:
== [994] If the result of running the [[certificate revocation verification steps]]
with [VAR[certificate]] set to [VAR[cert]], [VAR[certificate type]] set to ''CA certificate'',
and [VAR[ocsp]] set to [[null]], is [[false]]:
== [704] Return a [[failure]] and abort these steps.
= [862] If the result of running the [[certificate revocation verification steps]]
with [VAR[certificate]] set to [VAR[certs]]'s [[end entity certificate]],
[VAR[certificate type]] set to ''end entity'', and [VAR[ocsp]], is [[false]]:
== [704] Return a [[failure]] and abort these steps.
= [705] Apply [[PKP]] verification for [VAR[certs]] and [VAR[url]]'s [F[host]]
in [VAR[user agent]].
= [860] Let [VAR[tls transport]] be a [[transport]] that represents the [[TLS connection]],
with following states:
[FIG(list members)[
[FIGCAPTION[
[[Transport][transport]]
]FIGCAPTION]
: [F[protocol][transport's protocol]] : [CODE[tls]]
: [F[endpoint type][transport's endpoint type]] : [CODE[client]]
: [F[remote address or domain][transport's remote address or domain]] : [VAR[transport]]'s
[F[remote address or domain][transport's remote address or domain]]
: [F[remote port][transport's remote port]] : [VAR[transport]]'s 
[F[remote port][transport's remote port]]
: [F[http protocol][transport's http protocol]] : [VAR[protocol]]
: [F[is ev]] : [VAR[ev]]
: [F[remote certificates]] : [VAR[certs]]
]FIG]
= [859] Set [VAR[tls transport]]'s [F[HTTPS state][transport's HTTPS state]]
to [CODE[modern]] or [CODE[deprecated]], as determined by an implementation dependent
algorithm whose inputs are [VAR[version]], [VAR[cipher]], [VAR[certs]],
and whether there are TLS warnings or not.
= [906] Return [VAR[tls transport]].
]FIG]

;; [941] When [[SNI]] host is [[null]], the [[TLS]] client is not expected to
send any [[SNI]] [[extension][TLS extension]] in the handshake.

[895] The [DFN[certificate revocation verification steps]] for
[VAR[certificate]] (a [[certificate]]),
[VAR[certificate type]] (''CA certificate'' or ''end entity certificate''), and
[VAR[ocsp]] (an [[OCSP response]] or [[null]]) are these steps:
[FIG(steps)[
= [864] If the [[user agent]]'s [F[certificate database]] knows whether
[VAR[cert]] has been revoked or not:
== [875] Return [[true]] if [VAR[cert]] has been revoked,
or [[false]] otherwise, and abort these steps.
= [937] If [VAR[ocsp]] is a valid [[OCSP]] response:
== [999] Return [[true]] if [VAR[cert]] has been revoked according to [VAR[ocsp]],
or [[false]] otherwise, and abort these steps.
= [989] Otherwise, if [VAR[cert]] has the [[OCSP must-staple]] option enabled:
== [940] Return [[false]] and abort these steps.
= [990] Let [VAR[duration]] be [VAR[cert]]'s [F[[CODE[notAfter]]]] timestamp - 
[VAR[cert]]'s [F[[CODE[notBefore]]]] timestamp.
= [991] If [VAR[duration]] is less than 10 days (i.e. [VAR[cert]] is a [[short-lived certificate]]):
== [992] Return [[true]] and abort these steps.
= [863] Let [VAR[ocsp url]] be [VAR[cert]]'s [[OCSP]] [[URL]].
= [995] If [VAR[ocsp url]] is not [[null]],
the implementation [MAY[MAY]] run these substeps:
== [996] Send an [[OCSP]] request for [VAR[cert]] to [VAR[ocsp url]].
Set [VAR[ocsp]] to the result.
== [997] If [VAR[ocsp]] is a valid [[OCSP]] response:
=== [986] Let [VAR[result]] be [[true]] if [VAR[cert]] has been revoked according to [VAR[ocsp]],
or [[false]] otherwise.
=== [998] [MAY[Optionally]], save [VAR[result]] to the [[user agent]]'s 
[F[certificate database]] as the cached verification result for [VAR[cert]].
=== [988] Return [VAR[result]] and abort these steps.
=
@@ unset EV flag (and set HTTPS state to deprecated?)
= [987] Return [[true]].
]FIG]

@@ [938] [[HTTPS state]] steps

@@ [939] is EV flag

[384] A [[user agent]] has [F[[[TLS session]] cache]] and
[F[certificate database]].

@@ server:
[706] 確立の完了時に、次の情報をアプリケーションに引渡します。
[FIG(list)[
- [[TLS]] の版
- 選択された [[cipher suite]] と引数
- [[SNI]] ホスト名
- 選択された [[ALPN]] プロトコル
- 相手の[[証明書]]と[[中間証明書]] (あれば)
]FIG]

@@ server: OCSP stapling

[707] [VAR[transport]]からバイトを受信したら、[[バイト]]と[[緊急データ]]フラグを [[TLS]] に従い処理します。

[708] [[closure alert]] を受信したら、次のようにします。
[FIG(steps)[
= [709] 正常終了の受信を通知します。
]FIG]

[710] [[error alert]] を受信したら、次のようにします。
[FIG(steps)[
= [891] Set [VAR[connection]]'s [F[has alert]] to [[true]].
= [711] [[alert level]] が[[警告]] and [VAR[user agent]] does not have
[[HSTS policy]] or pin for [VAR[url]]'s [F[host]]:
== [712] 警告を通知します。
= [713] それ以外なら、
== [714] [VAR[送信閉じ済みフラグ]]を設定します。
== [715] [VAR[受信閉じ済みフラグ]]を設定します。
== [716] 中断を通知します。リセットフラグを設定します。
]FIG]

[717] [VAR[transport]]から正常終了を受信したら、次のようにします。
[FIG(steps)[
= [718] [VAR[受信閉じ済みフラグ]]が設定されていなければ、
== [719] [VAR[受信閉じ済みフラグ]]を設定します。
== [720] 正常終了の受信を通知します。
]FIG]

[721] [VAR[transport]]から中断を受信したら、次のようにします。
[FIG(steps)[
= [722] [VAR[受信閉じ済みフラグ]]と[VAR[送信閉じ済みフラグ]]のどちらかが未設定なら、
== [723] [VAR[送信閉じ済みフラグ]]を設定します。
== [724] [VAR[受信閉じ済みフラグ]]を設定します。
== [725] 中断を通知します。
]FIG]

[726] バイトの送信は、 [[TLS]] に従い処理します。

[727] バイトを送信できるかどうかは、新たなバイトを入力として [[TLS]]
で処理できるかどうかとします。

[728] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [729] [[closure alert]] を送信します。
= [730] [VAR[transport]]に正常終了の送信を指示します。
]FIG]

[731] 中断の指示があれば、[VAR[transport]]に中断を指示します。

[732] [[TLS]] の処理によりバイト列を送信するべきときは、
[VAR[transport]]で指定されたバイト列を送信します。

@@
[889] TLS renegotiation:
If protocol is http2 and after preface, connection error PROTOCOL_ERROR

[733] [[TLS]] の最初の [[handshake]] 
または[[再折衝]]により[[クライアント証明書]]を要求された時は、
次のようにします。
[FIG(steps)[
= [734] challenge の受信を通知します。
[FIG(list members)[
: [VAR[transport]] : [VAR[transport]]
:challenge:(サーバーなら) [CODE(HTTP)@en[[[ClientHello]]]]
や (クライアントなら) [CODE(HTTP)@en[[[CertificateRequest]]]]
に含まれる情報のうち必要なもの。
]FIG]
]FIG]

[735] credentials の送信は、次のようにします。
[FIG(steps)[
= [736] [[TLS]] が [[credentials]] を受け付ける状態でなければ、例外を投げて停止します。
= [737] そうでなければ、与えられた [[credentials]] を [[TLS]] の処理に引渡します。
]FIG]

* HTTP

[355] An [DFN[HTTP connection]] has following states:
[FIG(list members)[
: [DFN[[F[endpoint type][connection's endpoint type]]]] : [CODE[client]] or [CODE[server]].
: [DFN[[F[transport][connection's transport]]]] : A [[transport]].
]FIG]

[38] An [DFN[exit status]] has following states:
[FIG(list members)[
[FIGCAPTION[
[[Exit status][exit status]]
]FIGCAPTION]
:リセット:[[真]]か[[偽]]。既定値は[[偽]]。
:失敗:[[真]]か[[偽]]。
:[[WebSocket]] cleanly:[[真]]か[[偽]]か null。既定値は null。
:[[WebSocket]] [[状態符号]]:[[整数]]か null。既定値は null。
:[[WebSocket]] 理由:[[文字列]]か null。既定値は null。
: [DFN[[F[can retry][exit's can retry]]]] : A [[boolean]].  Initially, [[false]].
]FIG]

* HTTP/1

[34] An [[HTTP connection]] whose [F[protocol][connection's protocol]] is [CODE[http1]]
has following additional states:
[FIG(list members)[
:[VAR[状態]]:後述の状態遷移における状態のいずれか。初期値は「初期」。
:[VAR[要求の送信状態]]: 未送信、送信中、送信済みのいずれか。初期値は未送信。
:[VAR[要求締め切り]]フラグ:初期値は未設定です。
:[VAR[要求]]:[[要求]]か null。初期値は null です。
:[VAR[応答]]:[[応答]]か null。初期値は null です。
:[VAR[一時バッファー]]:バイト列。初期値は空。
:[VAR[最後のヘッダー]]:ヘッダーか null
:[VAR[残り長さ]]:[[非負整数]]か null か「chunked」かエラー。
: [F[response received][connection's response received]] :
A [[boolean]].  Initially, '''[[true]]'''.
:[VAR[要求の転送済]]:[[非負整数]]。初期値は 0。
:[VAR[要求の処理完了]]:[[Promise]] か null。初期値は null。
:[VAR[WebSocket接続の状態]]:[CODE[CONNECTING]]、[CODE[OPEN]]、
[CODE[CLOSING]]、[CODE[CLOSED]]、null のいずれか。初期値は null。
:[VAR[フレーム]]:[[WebSocketフレーム]]または null。初期値は null。
:[VAR[先頭フレーム]]:[[WebSocketフレーム]]または null。初期値は null。
:[VAR[送信待ちフレーム]]:[[WebSocketフレーム]]または null。初期値は null。
: [F[exit status][connection's exit status]] :  An [[exit status]] or [[null]].
Initially, [[null]].
:[VAR[切断タイマー]]:タイマー。
]FIG]

[314] タイマーは、初期状態では動作していません。時間と動作が設定されると、
指定時間経過後に指定の動作が実行されます。既に設定された動作は取り消され、実行されません。

[62] [[要求]]は、次のようなデータ構造です。
[FIG(list members)[
[FIGCAPTION[
[[要求]]
]FIGCAPTION]
:[[要求メソッド]]:バイト列。
:[[要求対象]]:バイト列。
:[[プロトコルの版]]:[CODE[1.1]]。
:[[ヘッダーリスト]]:0個以上の[[ヘッダー]]のリスト。
:[[本体]]:バイト列。初期値は空。
]FIG]

[63] [[応答]]は、次のようなデータ構造です。
[FIG(list members)[
[FIGCAPTION[
[[応答]]
]FIGCAPTION]
:[[プロトコルの版]]:[CODE[0.9]], [CODE[1.0]], [CODE[1.1]] のいずれか。初期値は [CODE[0.9]]。
:[[状態符号]]:[[非負整数]]。初期値は [CODE[200]]。
:[[理由句]]:[[バイト列]]。初期値は [CODE[OK]]。
:[[ヘッダーリスト]]:0個以上の[[ヘッダー]]のリスト。初期値は空。
: [DFN[[F[incomplete message][response's incomplete message]]]] :
A [[boolean]].  Initially, [[false]].
]FIG]

** アプリケーションからの指示

[49] [[HTTP connection]]に対して[[アプリケーション]]は、
[FIG(list)[
- [[要求]]の送信 (>>42)
- [[WebSocket]] メッセージ送信 (>>259)
- ping 送信 (>>260)
- [[トンネル]]への[[バイト]]送信 (>>107)
- [[接続]]の正常終了 (>>50)
- 接続の中断 (>>52)
]FIG]
... を指示できます。

[42] 要求の送信は、次のようにします。この処理は、[[要求]]である[VAR[送信する要求]]と、
[VAR[WebSocket]] フラグを入力として受け取ります。
[FIG(steps)[
= [90] 前提として、[VAR[送信する要求]]は次の条件を満たす必要があります。
[FIG(list)[
- [93] [[要求メソッド]]が空ではない。
- [94] [[要求メソッド]]に 0x09, 0x0A, 0x0D, 0x20 が含まれない。
- [95] [[要求対象]]が空ではない。
- [96] [[要求対象]]に 0x0A, 0x0D が含まれない。
- [97] [[要求対象]]の先頭と末尾が 0x09, 0x20 でない。
- [99] すべての[[ヘッダー]]について、
-- [100] 名前に 0x3A が含まれない。
-- [101] 名前が空ではない。
-- [103] 名前に 0x0A, 0x0D が含まれない。
-- [102] 名前の先頭と末尾が 0x09, 0x20 でない。
-- [104] 値に 0x0A, 0x0D が含まれない。
-- [105] 値の先頭と末尾が 0x09, 0x20 でない。
- [298] [CODE(HTTP)@en[[[Transfer-Encoding:]]]] [[ヘッダー]]がない。
- [91] [VAR[WebSocket]] フラグが設定されていれば、
-- [92] [[本体]]が空である。
- [261] [[本体]]が空の場合、
-- [262] [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]がないか、値が [CODE[0]] である。
- [267] [[本体]]が空でない場合、
-- [263] [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]があって、値が[[本体]]のバイト数である。
]FIG]
= [74] [VAR[要求締め切り]]フラグが設定されているなら、
== [75] エラーを返し、ここで停止します。
= [58] [VAR[状態]]が「初期」か「要求待ち」でなければ、
== [35] エラーを返し、ここで停止します。
= [61] [VAR[要求]]を、[VAR[送信する要求]]に設定します。
= [64] [VAR[応答]]を、新しい[[応答]]に設定します。
= [60] [VAR[一時バッファー]]を、空バイト列に設定します。
= [59] [VAR[状態]]を、「応答前」に設定します。
= [77] [VAR[要求]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
== [78] [VAR[要求締め切り]]フラグを設定します。
= [98] [VAR[WebSocket]] フラグが設定されていれば、
== [258] [VAR[WebSocket接続の状態]]を、 [CODE[[[CONNECTING]]]] に設定します。
== [265] 16バイトの無作為に決定したバイト列を [[RFC 4648]] [[Base64]]
[[符号化]]したものを[VAR[要求]]の [CODE(HTTP)@en[[[Sec-WebSocket-Key:]]]]
[[ヘッダー]]として追加します。
== [266] [VAR[要求]]に [CODE(HTTP)@en[[[Sec-WebSocket-Version:]]]]
[[ヘッダー]]を値 [CODE[[[13]]]] で追加します。
== [264] 
@@ 拡張
= [57] [VAR[要求の送信状態]]を、送信中に設定します。
= [45] [VAR[要求の処理完了]]を、新しい [[Promise]] に設定します。
= [48] [VAR[要求の処理完了]]を返します。
= [46] [[並列に]]、[VAR[要求]]の送信を行います。
]FIG]

[25] [VAR[要求]]の送信は、次のようにします。
[FIG(steps)[
= [47] [[HTTP/1.1]] に従い[VAR[要求]]の[[ヘッダー部]] (空行の [CODE[CRLF]] まで)
を表す[[バイト列]]の各[[バイト]]を順に、
== [VAR[connection]]'s [F[transport][connection's transport]] で[[バイト]]の送信を指示します。
== エラーが返されたら、ここで停止します。
= [1] [VAR[要求]]の[[メッセージ本体]]が存在する場合、各[[バイト]]を順に、
== [VAR[connection]]'s [F[transport][connection's transport]] で[[バイト]]の送信を指示します。
== エラーが返されたら、ここで停止します。
== [VAR[要求の転送済]]を、1だけ大きな値に設定します。
== [VAR[要求]]について要求の本体の一部の送信を通知して構いません。
= [VAR[要求の送信状態]]を、送信済みに設定します。
= [VAR[要求]]について要求の送信完了を通知します。
= [520] [VAR[状態]]が「要求送信中」なら、
== [521] 次の要求に進みます。
]FIG]

[259] [[WebSocket]] メッセージ送信は、次のようにします。
この処理は、[[バイト列]]である[VAR[データ]]と、[[テキスト]]または[[バイナリー]]のいずれかの[VAR[種別]]を引数として受け取ります。
[FIG(steps)[
= [278] 前提として、次の条件を満たす必要があります。
[FIG(list)[
- [289] [VAR[データ]]の長さは 2[SUP[63]] [[未満]]かつ実装の扱える範囲内である
]FIG]
= [271] [VAR[WebSocket接続の状態]]が [CODE[[[OPEN]]]] でなければ、
エラーを返して停止します。
= [268] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:[VAR[種別]]がテキストなら 1、バイナリーなら 2
:[[mask]]:1
:[[長さ]]:[VAR[データ]]のバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[データ]]
]FIG]
= [269] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
= [270] [VAR[connection]]'s [F[transport][connection's transport]] で [[WebSocketフレーム]]のバイト列を送信することとします。
]FIG]

[260] ping 送信は、次のようにします。
この処理は、バイト列である[VAR[データ]]と、[VAR[応答]]フラグを受け取ります。
[FIG(steps)[
= [287] 前提として、次の条件を満たす必要があります。
[FIG(list)[
- [288] [VAR[データ]]の長さは 2[SUP[63]] [[未満]]かつ実装の扱える範囲内である
]FIG]
= [272] [VAR[WebSocket接続の状態]]が [CODE[[[OPEN]]]] でなければ、
エラーを返して停止します。
= [273] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:[VAR[応答]]フラグが設定されていれば 10、されていなければ 9
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:指定されたバイト列
]FIG]
= [274] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
= [275] [VAR[connection]]'s [F[transport][connection's transport]] で [[WebSocketフレーム]]のバイト列を送信することとします。
]FIG]

[107] [[トンネル]]への[[バイト]]の送信は、次のようにします。
[FIG(steps)[
= [108] [VAR[状態]]が「トンネル」か「トンネル送信中」以外なら、
== [335] エラーを返し、ここで停止します。
= [109] [VAR[connection]]'s [F[transport][connection's transport]] で指定された[[バイト]]の送信を指示します。
= [110] エラーが返されたら、ここで停止します。
]FIG]

[50] [[接続]]の正常終了は、次のようにします。引数として[[非負整数]]または null
である[VAR[状態符号]]と、
[[バイト列]]である[VAR[理由]]を受け取ります。
[FIG(steps)[
= [286] 前提として、次の条件を満たす必要があります。
[FIG(list)[
- [285] [VAR[状態符号]]は2[SUP[16]] [[以下]]
- [283] [VAR[理由]]の長さは 2[SUP[63]] [[未満]]かつ実装の扱える範囲内である
- [276] [VAR[状態符号]]が null なら、[VAR[理由]]は空である
]FIG]
= [279] [VAR[WebSocket接続の状態]]が [CODE[[[OPEN]]]] か [CODE[[[CONNECTING]]]] なら、
== [281] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:8
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[状態符号]]が null なら空、
そうでなければ、[VAR[状態符号]]を表す[[16ビット符号無し整数]] ([[ネットワークバイト順]]) と、
それに続けて[VAR[理由]]
]FIG]
== [282] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
== [280] [VAR[WebSocket接続の状態]]が [CODE[[[CONNECTING]]]] なら、
=== [277] [VAR[送信待ちフレーム]]が null なら、[VAR[送信待ちフレーム]]を作成した[[WebSocketフレーム]]に設定します。
== [290] それ以外なら、
=== [297] [VAR[WebSocket接続の状態]]を、 [CODE[[[CLOSING]]]] に設定します。
=== [174] [VAR[要求]]について、WebSocket終了開始を通知します。
=== [284] [VAR[connection]]'s [F[transport][connection's transport]] で、作成した [[WebSocketフレーム]]のバイト列を送信することとします。
=== [315] [VAR[切断タイマー]]により20s後に次の要求に進むことにします。
= [72] [VAR[要求締め切り]]フラグを設定します。
= [66] [VAR[状態]]が「初期」か「要求待ち」か「トンネル」か「トンネル送信中」なら、
== [55] [VAR[connection]]'s [F[transport][connection's transport]] で正常終了の送信を指示します。
= [362] [VAR[状態]]が「トンネル」なら、
== [363] [VAR[状態]]を、「トンネル受信中」に設定します。
]FIG]

;; [73] これにより[[要求]]の送信側は閉じられますが、[[応答]]の受信はまだ続くかもしれません。

[52] [[接続]]の中断は、次のようにします。
[FIG(steps)[
= [44] [VAR[要求の締め切り]]フラグを設定します。
= [39] [VAR[要求の送信状態]]を送信済みに設定します。
= [51] [VAR[connection]]'s [F[transport][connection's transport]] を中断します。
]FIG]

** アプリケーションへの通知

[11] [[状態機械]]は、[[要求]]について次の通知を行います。
それぞれ、次に示す[[引数]] (あれば) 付きで通知されます。
[FIG(list)[
- 要求の本体の一部の送信の通知
[FIG(list members)[
:[[転送済]]:[VAR[要求の転送済]]。
]FIG]
- [526] 要求の送信完了の通知
-- [527] [[要求]]全体の送信が完了したことの通知です。
[[WebSocket]] や [CODE(HTTP)@en[[[CONNECT]]]] [[要求]]では、
[[要求ヘッダー]]後の[[空行]]まで送信した時点で発火されます。
- 応答のヘッダー受信完了の通知
[FIG(list members)[
:[[応答]]:[VAR[応答]]。
:[[WebSocket接続確立]]:[[真]]か[[偽]]。既定値は[[偽]]。
]FIG]
- [377] データ開始の通知
-- [535] [[応答本体]]や[[トンネル]]、
[[バイナリー]]の[[WebSocketメッセージ]]の受信開始前に発火されます。
- [528] データ受信の通知
[FIG(list members)[
:データ:[[バイト列]]。
]FIG]
-- [529] [[応答本体]]や[[トンネル]]、
[[バイナリー]]の[[WebSocketメッセージ]]として[[バイト列]]を受信した際に発火されます。
- [378] データ終了の通知
-- [536] [[応答本体]]や[[トンネル]]、
[[バイナリー]]の[[WebSocketメッセージ]]の受信終了後に発火されます。
- [531] 文字列開始の通知
-- [537] [[テキスト]]の[[WebSocketメッセージ]]の受信開始前に発火されます。
- [532] 文字列受信の通知
[FIG(list members)[
:データ:[[文字列]]。
]FIG]
-- [534] [[テキスト]]の[[WebSocketメッセージ]]の[[文字列]]を受信した際に発火されます。
- [533] 文字列終了の通知
-- [538] [[テキスト]]の[[WebSocketメッセージ]]の受信終了後に発火されます。
- [250] ping の通知
[FIG(list members)[
:返答:[[真]]か[[偽]]。既定値は[[偽]]。
:データ:[[バイト列]]。既定値は空。
]FIG]
- [329] WebSocket終了開始の通知
-- [317] [[WebSocket]] で [[Closeフレーム]]を初めに送信または受信したときに発火されます。
- [358] 完了の通知
[FIG(list members)[
:[[応答]]:[VAR[応答]]。
: [VAR[exit status]] : A [[exit status]].
]FIG]
]FIG]

[15] 各[[要求]]について、2種類の送信の通知と3種類の受信の通知をそれぞれこの順序で行うか、
その途中で失敗の通知で中断するかのいずれかです。
送信の通知と受信の通知はどちらもそれぞれ進行し、相互の順序は不定です。
送信の完了は通知されないことがあります (失敗の場合)。
データ受信の通知は、0回以上の任意の回数行います。
データ受信の通知のかわりに 0回以上の ping の通知がある場合があります。
[[トンネル]]では最初にデータ開始の通知、最後にデータ終了の通知があります。
完了の通知の前に、WebSocket終了開始の通知があるかもしれません。

[FIG(flow)[
:initial:要求の送信
:v:
:>>:3
:->:reqbody
:->:reqeof
:->:headers
:->:rerror
:->:reset

:reqbody:本体一部送信
:->:reqbody
:->:reqeof
:v:
:>>:2
:->:rerror
:->:reset

:reqeof:送信完了
:v:
:>>:1
:->:reset

:headers:ヘッダー受信
:v:
:>>:3
:->:body
:->:complete
:->:reset

:body:受信
:v:
:>>:4
:->:complete
:->:body
:->:reset

:complete:完了 (成功)
:v:
:>>:3

:reset:完了 (失敗)
:>>:5

]FIG]

;; [253] 図の「受信」は、データ受信、ping の受信、WebSocket終了開始、データ開始、データ終了を表します。

** The state machine

[68] [[クライアント]]は[[状態機械]]を持ちます。

[53] [VAR[connection]]'s [F[transport][connection's transport]] の[[バイト]]受信の通知があると、次のようにします。
ただし、[VAR[状態]]が「初期」なら、[VAR[状態]]が変化するまで待ってから実行します。
[FIG(steps)[
= [14] [[緊急データ]]フラグが設定されていなければ、
== [37] [VAR[状態]]により決まる処理を行います。
]FIG]

[40] 正常終了の受信の通知があると、次のようにします。
[FIG(steps)[
= [54] [VAR[状態]]により決まる正常終了処理を行います。
= [322] [VAR[状態]]が「トンネル送信中」以外なら、
== [224] [VAR[connection]]'s [F[transport][connection's transport]] を閉じることにします。
]FIG]

[13] 中断の通知があると、次のようにします。
[FIG(steps)[
= [359] リセットフラグが設定されていれば、
== [360] [VAR[要求]]が null でなければ、
=== [361] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[リセット]] and [F[失敗]] are [[true]].
== [522] [VAR[要求締め切り]]フラグを設定します。
== [523] [VAR[要求の送信状態]]を送信済みに設定します。
== [524] 次の要求に進みます。
= [41] それ以外なら、
== [525] [VAR[状態]]により決まる中断処理を行います。
= [225] [VAR[connection]]'s [F[transport][connection's transport]] を破棄します。
]FIG]

@@
[318] 送信するものがなくなった通知があると、次のようにします。
[FIG(steps)[
= [319] [VAR[状態]]が「トンネル」か「トンネル送信中」なら、
== [320] [VAR[要求]]について送信するものがなくなったことを通知します。
]FIG]

[252] [[WebSocketフレーム]]は、次のようなデータ構造です。
[FIG(list members)[
[FIGCAPTION[
[[WebSocketフレーム]]
]FIGCAPTION]
:[[FIN]]:0 か 1。
:[[RSV1]]:0 か 1。
:[[RSV2]]:0 か 1。
:[[RSV3]]:0 か 1。
:[[opcode]]:0-15 の[[整数]]。
:[[mask]]:0 か 1。
:長さ:[[非負整数]]。
:マスクキー:4バイトの[[バイト列]]または null。
:データ:[[バイト列]]または[[文字列]]。
]FIG]

*** 「初期」状態

[69] 正常終了か中断を受信したら、
[FIG(steps)[
= [VAR[要求締め切り]]フラグを設定します。
= [VAR[要求の送信状態]]を送信済みに設定します。
= 次の要求に進みます。
]FIG]

*** 「要求待ち」状態

[2] バイトを受信したら、何もせずに無視します。

[33] 正常終了か中断を受信したら、
[FIG(steps)[
= [VAR[要求締め切り]]フラグを設定します。
= [VAR[要求の送信状態]]を送信済みに設定します。
= 次の要求に進みます。
]FIG]

*** 「要求送信中」状態、「トンネル送信中」状態

[56] バイトを受信したら、何もせずに無視します。

[67] 正常終了 or 中断を受信したら、
[FIG(steps)[
= [76] [VAR[要求締め切り]]フラグを設定します。
= [586] [VAR[要求の送信状態]]を送信済みに設定します。
= [604] 次の要求に進みます。
]FIG]

*** 「応答前」状態

[24] バイトを受信したら、
[FIG(steps)[
= [130] Set [VAR[connection]]'s [F[response received][connection's response received]] to [[true]].
= [26] 受信したバイトを、[VAR[一時バッファー]]の末尾に連結します。
= [27] [VAR[一時バッファー]]の末尾4バイトが [CODE(HTTP)[HTTP]]
([[ASCII大文字・小文字不区別]]) なら、
== [VAR[応答]]の[[プロトコルの版]]を 1.0 に設定します。
== [VAR[状態]]を、「応答ヘッダー」に設定します。
== [VAR[一時バッファー]]を、空に設定します。
= [28] それ以外で、[VAR[一時バッファー]]の長さが8バイトなら、
== [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)@en[[[PUT]]]] か [CODE(HTTP)@en[[[CONNECT]]]] なら、
=== [VAR[要求締め切り]]フラグを設定します。
=== [VAR[要求の送信状態]]を送信済みに設定します。
=== [432] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[失敗]] is [[true]].
=== [433] 次の要求に進みます。
== それ以外なら、
=== [367] [VAR[要求]]についてデータ開始を通知します。
=== [922] [VAR[要求]]についてデータ受信を通知します。[VAR[一時バッファー]]を引渡します。
=== [452] [VAR[残り長さ]]を、 null に設定します。
=== [485] [VAR[状態]]を、「応答本体」に設定します。
]FIG]

[8] 正常終了か中断を受信したら、
[FIG(steps)[
= [132] [VAR[一時バッファー]]が[[空文字列]]なら、
== [134] [VAR[要求締め切り]]フラグを設定します。
== [135] [VAR[要求の送信状態]]を送信済みに設定します。
== [133] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[失敗]] is [[true]].
== [434] If not 中断 and [VAR[connection]]'s [F[response received][connection's response received]] is [[false]]:
=== [915] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s
[F[can retry][exit's can retry]] to [[true]].
== [136] 次の要求に進みます。
= [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)@en[[[PUT]]]] か [CODE(HTTP)@en[[[CONNECT]]]] なら、
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [435] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[失敗]] is [[true]].
== [436] 次の要求に進みます。
= [924] Otherwise:
== [925] [VAR[要求]]について[VAR[応答]]のヘッダー受信完了を通知します。
== [920] [VAR[要求]]についてデータ開始を通知します。
== [530] [VAR[要求]]についてデータ受信を通知します。[VAR[一時バッファー]]を引渡します。
== [921] [VAR[要求]]についてデータ終了を通知します。
== [918] 中断なら、
=== [919] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
=== [928] [VAR[要求の送信状態]]を送信済みに設定します。
== [926] [VAR[要求締め切り]]フラグを設定します。
== [437] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
== [438] 次の要求に進みます。
]FIG]

*** 「応答ヘッダー」状態

[36] バイトを受信したら、
[FIG(steps)[
= [VAR[一時バッファー]]の末尾に受信したバイトを追加します。
= [VAR[一時バッファー]]の末尾が 0x0A 0x0A または 0x0A 0x0D 0x0A なら、
== [137] ヘッダーの処理 (>>138) を行います。
= それ以外で、 [VAR[一時バッファー]]の長さが 2[SUP[18]]‐1 なら、
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [439] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[失敗]] is [[true]].
== [440] 次の要求に進みます。
]FIG]

[12] 正常終了か中断を受信したら、
[FIG(steps)[
= [445] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
= [139] ヘッダーの処理 (>>138) を行います。
= [442] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [141] [VAR[残り長さ]]が[[正]]で[VAR[応答]]の[[プロトコルの版]]が [CODE[1.1]] なら、
== [441] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to [[true]].
= [142] [VAR[要求締め切り]]フラグを設定します。
= [443] [VAR[要求の送信状態]]を送信済みに設定します。
= [444] 次の要求に進みます。
]FIG]

[138] ヘッダーの処理は、次のようにします。
[FIG(steps)[
= [140] [VAR[一時バッファー]]をヘッダー群として構文解析します。
= [113] [VAR[応答]]の[[プロトコルの版]]が [CODE[1.1]] で、
[CODE(HTTP)@en[[[Transfer-Encoding:]]]] [[ヘッダー]]があって、
[CODE(HTTP)@en[[[chunked]]]] ([[ASCII大文字・小文字不区別]]) が[[転送符号化]]として指定されていれば、
== [114] [VAR[残り長さ]]を、「chunked」に設定します。
= [115] それ以外なら、
== [32] [VAR[残り長さ]]を、[VAR[応答]]の [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]の処理の結果とします。
= [448] [VAR[残り長さ]]がエラーなら、
== [449] [VAR[要求締め切り]]フラグを設定します。
== [450] [VAR[要求の送信状態]]を送信済みに設定します。
== [446] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[失敗]] is [[true]].
== [447] 次の要求に進みます。
= [540] それ以外で、[VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)[[[CONNECT]]]] で、
[VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[200]]]] なら、
== [373] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
== [374] [VAR[要求]]についてデータ開始を通知します。
== [375] [VAR[要求締め切り]]フラグを設定します。
== [376] [VAR[状態]]を、「トンネル」に設定します。
= [143] それ以外で、[VAR[WebSocket接続の状態]]が [CODE[CONNECTING]] で、
[VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[101]]]] なら、
== [144] 
[FIG(list)[
- [299] [VAR[応答]]に [CODE(HTTP)@en[[[Upgrade:]]]] [[ヘッダー]]が無いか、 
[CODE(HTTP)@en[[[websocket]]]] ([[ASCII大文字・小文字不区別]]) が含まれていない
- [300] [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]が無いか、 
[CODE(HTTP)@en[[[Upgrade]]]] ([[ASCII大文字・小文字不区別]]) が含まれていない
- [301] [VAR[応答]]に [CODE(HTTP)@en[[[Sec-WebSocket-Accept:]]]] [[ヘッダー]]が無いか、 
値が[VAR[要求]]の [CODE(HTTP)@en[[[Sec-WebSocket-Key:]]]] の値に 
[CODE(HTTP)[[[258EAFA5-E914-47DA-95CA-C5AB0DC85B11]]]] を連結した値の 
[[SHA-1]] を [[Base64]] [[符号化]]したものでない
- [302] [VAR[応答]]の [CODE(HTTP)@en[[[Sec-WebSocket-Extensions:]]]] 
[[ヘッダー]]が存在する
- [303] [VAR[応答]]の [CODE(HTTP)@en[[[Sec-WebSocket-Protocol:]]]] [[ヘッダー]]が[VAR[要求]]の
[CODE(HTTP)@en[[[Sec-WebSocket-Protocol:]]]] [[ヘッダー]]の値のいずれかと一致しない
(一方が存在しない場合は、他方が存在している)
]FIG]
... のいずれかであれば、
=== [145] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
=== [248] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]]:
[FIG(list members)[
[FIGCAPTION[
[[Exit status][exit status]]
]FIGCAPTION]
:失敗:[[真]]。
:cleanly:[[偽]]。
:[[状態符号]]:[CODE[[[1006]]]]。
:理由:[[空文字列]]。
]FIG]
=== [245] [VAR[要求締め切り]]フラグを設定します。
=== [246] [VAR[要求の送信状態]]を送信済みに設定します。
=== [247] 次の要求に進みます。
== [146] それ以外なら、
=== [291] [VAR[WebSocket接続の状態]]を、 [CODE[OPEN]] に設定します。
=== [256] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
[[WebSocket接続確立]]を[[真]]にします。
=== [292] [VAR[要求締め切り]]フラグを設定します。
=== [293] [VAR[状態]]を、「WebSocketフレーム前」に設定します。
=== [147] [VAR[一時バッファー]]を、空に設定します。
=== [294] [VAR[送信待ちフレーム]]が null 以外なら、
==== [296] [VAR[WebSocket接続の状態]]を、 [CODE[[[CLOSING]]]] に設定します。
==== [295] [VAR[connection]]'s [F[transport][connection's transport]] で、[VAR[送信待ちフレーム]]のバイト列を送信することにします。
==== [316] [VAR[切断タイマー]]により20s後に次の要求に進むことにします。
= [106] それ以外で、 [VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[1xx]]]] なら、
== [337] [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)[[[CONNECT]]]] か、
[VAR[WebSocket接続の状態]]が [CODE[CONNECTING]] なら、
=== [255] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
=== [254] If [VAR[connection]]'s [F[exit status][connection's exit status]] is [[null]]:
==== [131] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
=== [339] [VAR[要求締め切り]]フラグを設定します。
=== [340] [VAR[要求の送信状態]]を送信済みに設定します。
=== [338] 次の要求に進みます。
== [341] それ以外なら、
=== [342] [VAR[応答]]の[[プロトコルの版]]、[[状態符号]]、[[理由句]]、[[ヘッダーリスト]]を初期値に設定します。
=== [382] [VAR[状態]]を、「応答前」に設定します。
=== [383] [VAR[一時バッファー]]を、空バイト列に設定します。
= [344] それ以外なら、
== [345] [VAR[要求]]について[[応答]]のヘッダー受信完了を通知します。
== [385] [VAR[要求]]についてデータ開始を通知します。
== [346] 
[FIG(list)[
- [348] [VAR[応答]]の[[状態符号]]が [CODE(HTTP)[[[204]]]], [CODE(HTTP)[[[205]]]],
[CODE(HTTP)[[[304]]]] のいずれかの場合か、
- [349] [VAR[要求]]の[[要求メソッド]]が [CODE(HTTP)@en[[[HEAD]]]] の場合
]FIG]
... のいずれかの場合、
=== [347] [VAR[残り長さ]]を、0に設定します。
== [87] [VAR[残り長さ]]が 0 なら、
=== [89] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
=== [79] [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
==== [80] [VAR[要求締め切り]]フラグを設定します。
=== [81] それ以外で、[VAR[応答]]の[[プロトコルの版]]が [CODE[1.0]] で、
[CODE(HTTP)@en[[[keep-alive]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定された
[CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]がなければ、
==== [82] [VAR[要求締め切り]]フラグを設定します。
=== [343] 次の要求に進みます。
== [116] それ以外で、 [VAR[残り長さ]]が「chunked」なら、
=== [117] [VAR[状態]]を、「塊前」に設定します。
== [88] それ以外なら、
=== [16] [VAR[状態]]を、「応答本体」に設定します。
]FIG]

*** 「応答本体」状態

[6] バイトを受信したら、
[FIG(steps)[
= [451] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
= [453] [VAR[残り長さ]]が[[正]]なら、
== [454] [VAR[残り長さ]]を1減らします。
== [386] [VAR[残り長さ]]が0なら、
=== [387] [VAR[要求]]についてデータ終了を通知します。
=== [251] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
=== [83] [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
==== [84] [VAR[要求締め切り]]フラグを設定します。
=== [85] それ以外で、[VAR[応答]]の[[プロトコルの版]]が [CODE[1.0]] で、
[CODE(HTTP)@en[[[keep-alive]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定された
[CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]がなければ、
==== [86] [VAR[要求締め切り]]フラグを設定します。
=== [244] 次の要求に進みます。
]FIG]

[7] 正常終了か中断を受信したら、
[FIG(steps)[
= [388] [VAR[残り長さ]]が[[正]]なら、
== [389] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
== [390] [VAR[要求の送信状態]]を送信済みに設定します。
== [395] [VAR[要求]]についてデータ終了を通知します。
== [455] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
== [391] [VAR[応答]]の[[プロトコルの版]]が [CODE[1.1]] なら、
=== [392] Set [VAR[connection]]'s [F[失敗]] to [[true]].
= [400] それ以外なら、
== [396] 中断なら、
=== [398] [VAR[残り長さ]]が0なら、
==== [397] [VAR[要求の送信状態]]を送信済みに設定します。
=== [399] Otherwise:
==== [916] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
== [401] [VAR[要求]]についてデータ終了を通知します。
== [402] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [403] [VAR[要求締め切り]]フラグを設定します。
= [404] 次の要求に進みます。
]FIG]

*** 「塊前」状態

[118] バイトを受信したら、
[FIG(steps)[
= [394] [[ASCII十六進数字]]なら、
== [456] [VAR[一時バッファー]]を、指定されたバイトに設定します。
== [457] [VAR[状態]]を、「塊サイズ」に設定します。
= [458] それ以外なら、
== [917] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [405] [VAR[要求]]についてデータ終了を通知します。
== [406] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
== [393] 次の要求に進みます。
]FIG]

[119] 正常終了か中断を受信したら、
[FIG(steps)[
= [459] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
= [460] [VAR[要求締め切り]]フラグを設定します。
= [461] [VAR[要求の送信状態]]を送信済みに設定します。
= [407] [VAR[要求]]についてデータ終了を通知します。
= [408] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [409] 次の要求に進みます。
]FIG]

*** 「塊サイズ」状態

[120] バイトを受信したら、
[FIG(steps)[
= [462] [[ASCII十六進数字]]なら、
== [463] [VAR[一時バッファー]]に、指定されたバイトを追加します。
= [464] それ以外なら、
== [465] [VAR[一時バッファー]]を、[[十六進数]]として解釈します。
== [466] [VAR[残り長さ]]を、得られた値に設定します。
== [467] [VAR[残り長さ]]がエラー ([[桁溢れ]]) なら、
=== [468] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
=== [469] [VAR[要求締め切り]]フラグを設定します。
=== [470] [VAR[要求の送信状態]]を送信済みに設定します。
=== [410] [VAR[要求]]についてデータ終了を通知します。
=== [411] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
=== [412] 次の要求に進みます。
== [428] それ以外で、[VAR[残り長さ]]が 0 なら、
=== [431] [VAR[要求]]についてデータ終了を通知します。
=== [429] [VAR[状態]]を、「trailer 前」に設定します。
=== [430] [VAR[一時バッファー]]を、空に設定します。
== [471] それ以外なら、
=== [472] バイトが 0x0A なら、
==== [473] [VAR[状態]]を、「塊」に設定します。
=== [474] それ以外なら、
==== [475] [VAR[状態]]を、「塊拡張」に設定します。
]FIG]

[122] 正常終了か中断を受信したら、
[FIG(steps)[
= [476] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
= [477] [VAR[要求締め切り]]フラグを設定します。
= [478] [VAR[要求の送信状態]]を送信済みに設定します。
= [413] [VAR[要求]]についてデータ終了を通知します。
= [414] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [415] 次の要求に進みます。
]FIG]

*** 「塊拡張」状態

[121] バイトを受信したら、
[FIG(steps)[
= [479] 0x0A なら、
== [480] [VAR[状態]]を、「塊」に設定します。
]FIG]

[123] 正常終了か中断を受信したら、
[FIG(steps)[
= [481] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
= [482] [VAR[要求締め切り]]フラグを設定します。
= [483] [VAR[要求の送信状態]]を送信済みに設定します。
= [416] [VAR[要求]]についてデータ終了を通知します。
= [417] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [418] 次の要求に進みます。
]FIG]

*** 「塊」状態

[124] バイトを受信したら、
[FIG(steps)[
= [249] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
= [486] [VAR[残り長さ]]を1減らします。
= [487] [VAR[残り長さ]]が0なら、
== [488] [VAR[状態]]を、「塊後」に設定します。
]FIG]

[125] 正常終了か中断を受信したら、
[FIG(steps)[
= [489] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
= [490] [VAR[要求締め切り]]フラグを設定します。
= [491] [VAR[要求の送信状態]]を送信済みに設定します。
= [419] [VAR[要求]]についてデータ終了を通知します。
= [420] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [421] 次の要求に進みます。
]FIG]

*** 「塊後」状態

[126] バイトを受信したら、
[FIG(steps)[
= [492] 0x0D なら、
== [493] [VAR[状態]]を、「塊 CR 後」に設定します。
= [494] 0x0A なら、
== [495] [VAR[状態]]を、「塊前」に設定します。
= [496] それ以外なら、
== [497] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
== [498] [VAR[要求締め切り]]フラグを設定します。
== [499] [VAR[要求の送信状態]]を送信済みに設定します。
== [422] [VAR[要求]]についてデータ終了を通知します。
== [423] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
== [424] 次の要求に進みます。
]FIG]

[127] 正常終了か中断を受信したら、
[FIG(steps)[
= [500] Set [VAR[connection]]'s [F[response][connection's response]]'s
[F[incomplete message][response's incomplete message]] flag to [[true]].
= [501] [VAR[要求締め切り]]フラグを設定します。
= [502] [VAR[要求の送信状態]]を送信済みに設定します。
= [425] [VAR[要求]]についてデータ終了を通知します。
= [426] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [427] 次の要求に進みます。
]FIG]

*** 「trailer 前」状態

[128] バイトを受信したら、
[FIG(steps)[
= [VAR[一時バッファー]]の末尾に受信したバイトを追加します。
= [VAR[一時バッファー]]の末尾が 0x0A 0x0A または 0x0A 0x0D 0x0A なら、
== [VAR[応答]]に [CODE(HTTP)@en[[[Connection:]]]] [[ヘッダー]]があって
[CODE(HTTP)@en[[[close]]]] ([[ASCII大文字・小文字不区別]]) [[接続オプション]]が指定されていれば、
=== [VAR[要求締め切り]]フラグを設定します。
== [503] [VAR[終了]]を、新しい終了に設定します。
== [504] 次の要求に進みます。
= それ以外で、 [VAR[一時バッファー]]の長さが 2[SUP[18]]‐1 なら、
== [VAR[要求締め切り]]フラグを設定します。
== [VAR[要求の送信状態]]を送信済みに設定します。
== [505] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
== [506] 次の要求に進みます。
]FIG]

[129] 正常終了か中断を受信したら、
[FIG(steps)[
= [509] [VAR[要求締め切り]]フラグを設定します。
= [510] [VAR[要求の送信状態]]を送信済みに設定します。
= [507] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [508] 次の要求に進みます。
]FIG]

*** 「WebSocket フレーム前」状態

[148] バイトを受信したら、
[FIG(steps)[
= [VAR[一時バッファー]]の末尾に、受信したバイトを追加します。
= [VAR[一時バッファー]]の長さが2未満なら、ここで停止します。
= [VAR[フレーム]]を、次のような新しい[[WebSocketフレーム]]に設定します。
[FIG(list members)[
:[[FIN]]:[VAR[一時バッファー]]の第1バイトの最上位ビット
:[[RSV1]]:[VAR[一時バッファー]]の第1バイトの上位から第2ビット目
:[[RSV2]]:[VAR[一時バッファー]]の第1バイトの上位から第3ビット目
:[[RSV3]]:[VAR[一時バッファー]]の第1バイトの上位から第4ビット目
:[[opcode]]:[VAR[一時バッファー]]の第1バイトの下位4ビットを[[整数]]としたもの
:[[mask]]:[VAR[一時バッファー]]の第2バイトの最上位ビット
:[[長さ]]:[VAR[一時バッファー]]の第2バイトの下位7ビットを[[整数]]としたもの
]FIG]
= [VAR[フレーム]]の[[長さ]]が126か127で、[[opcode]] が 8 [[以上]]なら、
== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[長さ]]が126なら、
== [VAR[一時バッファー]]の長さが4以上でなければ、ここで停止します。
== [VAR[フレーム]]の[[長さ]]を、[VAR[一時バッファー]]の第3、第4バイトを[[ネットワークバイト順]]の[[16ビット符号無し整数]]とした値に設定します。
== [VAR[フレーム]]の[[長さ]]が126未満なら、
=== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[長さ]]が127なら、
== [VAR[一時バッファー]]の長さが10以上でなければ、ここで停止します。
== [VAR[一時バッファー]]の第3バイトの最上位ビットが 1 なら、
=== 失敗とします。ここで停止します。
== [VAR[フレーム]]の[[長さ]]を、[VAR[一時バッファー]]の第3-8バイトを[[ネットワークバイト順]]の[[64ビット符号無し整数]]とした値に設定します。
== [VAR[フレーム]]の[[長さ]]が2[SUP[16]]未満なら、
=== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[長さ]]が実装の扱える範囲を超えていれば、
== 失敗とします。ここで停止します。
= [VAR[フレーム]]の[[mask]]が設定されていれば、
== [VAR[一時バッファー]]に次の4バイトがなければ、ここで停止します。
== [VAR[フレーム]]の[[マスクキー]]を、[VAR[一時バッファー]]のその4バイトに設定します。
= [150] If [VAR[connection]]'s [F[endpoint type][connection's endpoint type]] is [CODE[server]]
and [VAR[フレーム]]の [[mask]] が 0 なら、
== [153] 理由 [CODE[WebSocket Protocol Error]] で失敗とします。ここで停止します。
= [151] If [VAR[connection]]'s [F[endpoint type][connection's endpoint type]] is [CODE[client]]
and [VAR[フレーム]]の [[mask]] が 1 なら、
== [152] 理由 [CODE[Masked frame from server]] で失敗とします。ここで停止します。
= [154] [VAR[フレーム]]の FIN が 0 で [[opcode]] が 8, 9, 10 なら、
== [155] 失敗とします。ここで停止します。
= [156] [VAR[フレーム]]の RSV1, RSV2, RSV3 のいずれかでも 1 なら、
== [157] 理由 [CODE[Invalid reserved bit]] で失敗とします。ここで停止します。
= [158] [VAR[フレーム]]の [[opcode]] が 3-7, 11-15 なら、
== [159] 理由 [CODE[Unknown opcode]] で失敗とします。ここで停止します。
= [170] [VAR[先頭フレーム]]が null で、[VAR[フレーム]]の [[opcode]] が 0 なら、
== [171] 理由 [CODE[Unexpected continuation]] で失敗とします。ここで停止します。
= [172] [VAR[先頭フレーム]]が非 null で、[VAR[フレーム]]の [[opcode]] が 1 か 2 なら、
== [173] 理由 [CODE[Previous data frame unfinished]] で失敗とします。ここで停止します。
= [175] [[FIN]] が 0 で [[opcode]] が 1, 2 なら、
== [176] [VAR[先頭フレーム]]を、[VAR[フレーム]]に設定します。
= [195] [VAR[一時バッファー]]を、空に設定します。
= [160] [VAR[フレーム]]の長さが0なら、
== [190] [[WebSocketフレーム]]の処理 (>>189) を行います。途中で停止したら、ここで停止します。
== [192] [VAR[フレーム]]を、 null に設定します。
== [191] [VAR[状態]]を、「WebSocket フレーム前」に設定します。
== [193] [VAR[一時バッファー]]を、空に設定します。
= [161] それ以外なら、
== [196] [VAR[状態]]を、「WebSocket データ」に設定します。
]FIG]

[149] 正常終了か中断を受信したら、
[FIG(steps)[
= [226] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [227] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]]:
[FIG(list members)[
[FIGCAPTION[
[[Exit status][exit status]]
]FIGCAPTION]
:失敗:[[真]]
:cleanly:[[偽]]
:状態符号:[CODE[[[1006]]]]
:理由:[[空文字列]]
]FIG]
= [330] 次の要求に進みます。
]FIG]

*** 「WebSocket データ」状態

[163] バイトを受信したら、
[FIG(steps)[
= [164] [VAR[一時バッファー]]の末尾に、受信したバイトを追加します。
= [165] [VAR[フレーム]]の [[mask]] が1なら、
== [166] [VAR[フレーム]]のマスクキーの先頭から第
(([VAR[一時バッファー]]の長さ - 1) mod 4) バイト (先頭が第0バイトとして数えた時。)
を使って[VAR[一時バッファー]]の末尾のバイトを [[XOR]] したものに置き換えます。
= [167] [VAR[一時バッファー]]の[[長さ]]が[VAR[フレーム]]の[[長さ]]と等しくなければ、
ここで停止します。
= [188] [[WebSocketフレーム]]の処理 (>>189) を行います。途中で停止したら、ここで停止します。
= [184] [VAR[フレーム]]を、 null に設定します。
= [185] [VAR[状態]]を、「WebSocket フレーム前」に設定します。
= [186] [VAR[一時バッファー]]を、空に設定します。
]FIG]

@@ permessage-deflate

[162] 正常終了か中断を受信したら、
[FIG(steps)[
= [212] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [215] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]]:
[FIG(list members)[
[FIGCAPTION[
[[Exit status][exit status]]
]FIGCAPTION]
:失敗:[[真]]
:cleanly:[[偽]]
:状態符号:[CODE[[[1006]]]]
:理由:[[空文字列]]
]FIG]
= [331] 次の要求に進みます。
]FIG]

*** 「WebSocket 切断待ち」状態

[217] 「WebSocket フレーム前」状態、「WebSocket データ」状態で失敗するという時、
次のようにします。
[FIG(steps)[
= [229] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [230] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]]:
[FIG(list members)[
[FIGCAPTION[
[[Exit status][exit status]]
]FIGCAPTION]
:失敗:[[真]]
:cleanly:[[偽]]
:状態符号:[CODE[[[1002]]]]
:理由:指定された理由。指定がなければ [CODE[WebSocket Protocol Error]]。
]FIG]
= [231] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:8
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ: [VAR[connection]]'s [F[exit status][connection's exit status]]'s
[[状態符号]]を表す[[16ビット符号無し整数]] ([[ネットワークバイト順]]) と、
それに続けて理由
]FIG]
= [305] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
= [306] [VAR[connection]]'s [F[transport][connection's transport]] で、作成した[[WebSocketフレーム]]を送信することにします。
= [232] [VAR[状態]]を、「WebSocket切断待ち」に設定します。
= [233] 次の要求に進むことにします。
]FIG]

[214] バイトを受信したら、
[FIG(steps)[
= [234] If [VAR[connection]]'s [F[exit status][connection's exit status]]'s [F[失敗]]
is [[false]]:
== [235] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s [F[失敗]] to [[true]].
== [236] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s [[状態符号]]を [CODE[[[1006]]]] に設定します。
== [237] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s
理由を[[空文字列]]に設定します。
]FIG]

[220] 正常終了か中断を受信したら、
[FIG(steps)[
= [238] [VAR[WebSocket接続の状態]]を、[CODE[CLOSING]] に設定します。
= [239] If 中断 and [VAR[connection]]'s [F[exit status][connection's exit status]]'s
[[失敗]]が[[偽]]なら、
== [240] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s
[F[失敗]] to [[true]].
== [241] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s
[F[状態符号]] to [CODE[1006]].
== [242] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s
理由 to the [[empty string]].
= [332] 次の要求に進みます。
]FIG]

*** 「トンネル」状態

[111] バイトを受信したら、
[FIG(steps)[
= [484] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
]FIG]

[112] 正常終了か中断を受信したら、
[FIG(steps)[
= [371] [VAR[要求]]についてデータ終了を通知します。
= [328] [VAR[要求締め切り]]フラグを設定します。
= [321] 正常終了なら、
== [325] [VAR[状態]]を、「トンネル送信中」に設定します。
= [323] それ以外なら、
== [326] [VAR[要求の送信状態]]を送信済みに設定します。
== [324] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]] whose [F[失敗]] is [[true]].
== [327] 次の要求に進みます。
]FIG]

*** 「トンネル受信中」状態

[364] バイトを受信したら、
[FIG(steps)[
= [366] [VAR[要求]]についてデータ受信を通知します。受信したバイトを引渡します。
]FIG]

[365] 正常終了か中断を受信したら、
[FIG(steps)[
= [372] [VAR[要求]]についてデータ終了を通知します。
= [328] [VAR[要求締め切り]]フラグを設定します。
= [369] [VAR[要求の送信状態]]を送信済みに設定します。
= [511] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]].
= [368] If 中断:
== [923] Set [VAR[connection]]'s [F[exit status][connection's exit status]]'s
[F[異常]] to [[true]].
= [370] 次の要求に進みます。
]FIG]

*** 「停止済み」状態

[43] 次の要求に進むとは、次のようにします。
[FIG(steps)[
= [243] [VAR[状態]]が「停止済み」なら、ここで停止します。
= [336] [VAR[切断タイマー]]を停止させます。
= [379] [VAR[要求の送信状態]]が送信中なら、
== [380] [VAR[状態]]を、「要求送信中」に設定します。
= [381] それ以外なら、
== [512] [VAR[要求]]が null ではなく、[VAR[要求の送信状態]]が送信済みなら、
=== [513] [VAR[要求]]について完了を通知します。[VAR[connection]]'s [F[exit status][connection's exit status]]
を引渡します。
== [333] [VAR[要求]]を、 null に設定します。
== [334] [VAR[応答]]を、 null に設定します。
== [514] [VAR[要求の送信状態]]を、未送信に設定します。
== [515] [VAR[要求の処理完了]]が null でなければ、
=== [516] [VAR[要求の処理完了]]を[[解決]]します。
=== [517] [VAR[要求の処理完了]]を null に設定します。
== [518] [VAR[要求締め切り]]フラグが設定されていれば、
=== [351] [VAR[connection]]'s [F[transport][connection's transport]] の正常終了の送信を指示します。
=== [350] これ以後 [VAR[connection]]'s [F[transport][connection's transport]] の受信終了を指示して構いません。
=== [352] [VAR[状態]]を、「停止済み」に設定します。
== [519] それ以外なら、
=== [353] [VAR[状態]]を、「要求待ち」に設定します。
]FIG]

[70] バイトを受信したら、何もしません。

[71] 正常終了や中断を受信したら、何もしません。

** ヘッダー群として構文解析

[17] 入力を、 0x0D や 0x0A で区切られた[[行]]に分割します。
[[行]]には区切りの 0x0D, 0x0A は含めません。

[3] 最初の行を (あれば) 次のようにします。

[FIG(steps)[
= 先頭が [CODE[/]] なら、
== その次が[[ASCII数字]]列なら、これを[[十進整数]]として解釈します。
ただし[[先導0]]があるときは、 0 とみなします。
== その次が [CODE[.]] なら、
=== その次が [[ASCII数字]]列なら、これを[[十進整数]]として解釈します。
=== [19] 最初の[[整数]]が2[[以上]]か、
最初の[[整数]]が1と等しく次の[[整数]]が1[[以上]]なら、
==== [VAR[応答]]の[[プロトコルの版]]を、 1.1 に設定します。
== 次が1個以上の [CODE(charname)@en[[[SP]]]] であれば、すべて無視します。
== [21] 次に[[ASCII数字]]列があれば、[VAR[応答]]の[[状態符号]]をその[[十進整数]]値に設定します。
== [9] 次の1個以上の [CODE(charname)@en[[[SP]]]] があれば、
=== [4] [VAR[応答]]の[[理由句]]を、[[行]]のそれより後の部分に設定します。
== [5] それ以外なら、
=== [31] [VAR[応答]]の[[理由句]]を、[[空文字列]]に設定します。
= 先頭が1個[[以上]]の [CODE(charname)@en[[[SP]]]] 列なら、
== [20] 次に[[ASCII数字]]列があれば、[VAR[応答]]の[[状態符号]]をその[[十進整数]]値に設定します。
== [10] 次の1個以上の [CODE(charname)@en[[[SP]]]] があれば、
=== [22] [VAR[応答]]の[[理由句]]を、[[行]]のそれより後の部分に設定します。
== [29] それ以外なら、
=== [30] [VAR[応答]]の[[理由句]]を、[[空文字列]]に設定します。
]FIG]

[23] 更に、次のようにします。
[FIG(steps)[
= [VAR[最後のヘッダー]]を、 null に設定します。
= 残りの各行について順番に、
== 先頭の文字が 0x20 か 0x09 なら、
=== [VAR[最後のヘッダー]]が null 以外なら、
==== 行の先頭から 0x20 と 0x09 をすべて除去します。
==== [VAR[最後のヘッダー]]の値の末尾に、 0x20 と行の内容を追加します。
== 先頭の文字が 0x3A でなく、 0x3A が含まれるなら、
=== [VAR[最後のヘッダー]]を、 0x3A より前の部分を名前、 0x3A より後の部分を値とするヘッダーに設定します。
=== [VAR[応答]]の[[ヘッダーリスト]]の末尾に、[VAR[最後のヘッダー]]を追加します。
== それ以外なら、
=== [VAR[最後のヘッダー]]を、 null に設定します。
= [VAR[応答]]の[[ヘッダーリスト]]の各ヘッダーについて、
== 名前の末尾から 0x20 と 0x09 をすべて除去します。
== 値の先頭から 0x20 と 0x09 をすべて除去します。
== 値の末尾から 0x20 と 0x09 をすべて除去します。
]FIG]

** WebSocket フレームの処理

[189] [[WebSocketフレーム]]の処理は、次のようにします。
[FIG(steps)[
= [168] [VAR[フレーム]]の [[opcode]] が 8 なら、
== [199] [VAR[一時バッファー]]の長さが1なら、
=== [201] 理由[[空文字列]]で失敗とします。ここで停止します。
== [202] [VAR[一時バッファー]]が空でないなら、
=== [203] [VAR[フレーム]]の[[状態符号]]を、
[VAR[一時バッファー]]の先頭2バイトを[[ネットワークバイト順]]の[[符号無し16ビット整数]]として解釈した値とします。
=== [206] [VAR[フレーム]]の[[状態符号]]が [CODE[[[1005]]]] か [CODE[[[1006]]]] なら、
==== [207] 理由[[空文字列]]で失敗とします。ここで停止します。
=== [208] [VAR[フレーム]]の[[理由]]を、[VAR[一時バッファー]]から先頭2バイトを除いたものを入力として
[[utf-8復号器]]をエラーモード致死的で実行した出力とします。
=== [209] 失敗の場合は、理由 [CODE[Invalid UTF-8 in Close frame]] で失敗とします。ここで停止します。
== [213] [VAR[WebSocket接続の状態]]が [CODE[CLOSING]] でなければ、
=== [210] [VAR[WebSocket接続の状態]]を、 [CODE[CLOSING]] に設定します。
=== [211] [VAR[要求]]について、WebSocket終了開始を通知します。
=== [216] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:8
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[フレーム]]に[[状態符号]]がなければ空。そうでなければ、
[VAR[フレーム]]の[[状態符号]]を表す[[16ビット符号無し整数]] ([[ネットワークバイト順]]) と、
それに続けて理由
]FIG]
=== [307] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
=== [308] [VAR[connection]]'s [F[transport][connection's transport]] で、作成した[[WebSocketフレーム]]を送信することにします。
== [218] [VAR[状態]]を、「WebSocket切断待ち」に設定します。
== [228] Set [VAR[connection]]'s [F[exit status][connection's exit status]] to an
[[exit status]]:
[FIG(list members)[
[FIGCAPTION[
[[Exit status][exit status]]
]FIGCAPTION]
:失敗:[[偽]]
:cleanly:[[真]]
:状態符号:[VAR[フレーム]]の[[状態符号]] (なければ [CODE[1005]])
:理由:[VAR[フレーム]]の理由 (なければ[[空文字列]])
]FIG]
== [219] [VAR[connection]]'s [F[endpoint type][connection's endpoint type]] is [CODE[server]]:
=== [311] 次の要求に進みます。
== [312] それ以外なら、
=== [313] [VAR[切断タイマー]]で、 1s 後に次の要求に進むことにします。
= [168] [VAR[フレーム]]の [[opcode]] が 9 なら、
== [222] [VAR[要求]]について、 ping を通知します。[VAR[一時バッファー]]をデータとして引き渡します。
== [223] [[WebSocketフレーム]]を作成します。
[FIG(list members)[
:[[FIN]]:1
:[[RSV1]]:0
:[[RSV2]]:0
:[[RSV3]]:0
:[[opcode]]:10
:[[mask]]:1
:[[長さ]]:データのバイト数
:[[マスクキー]]:無作為に決定した4バイトのバイト列
:データ:[VAR[一時バッファー]]
]FIG]
== [309] 作成した [[WebSocketフレーム]]のデータの各[[バイト]]について、
先頭から [VAR[i]] バイト目 (先頭が0バイト) であれば、
[[マスクキー]]の [VAR[i]] [[mod]] 4 バイト目 (先頭が0バイト)
と [[XOR]] した結果に差し替えます。
== [310] [VAR[connection]]'s [F[transport][connection's transport]] で、作成した[[WebSocketフレーム]]を送信することにします。
= [168] [VAR[フレーム]]の [[opcode]] が 10 なら、
== [221] [VAR[要求]]について、 ping を通知します。返答フラグを設定し、
[VAR[一時バッファー]]をデータとして引き渡します。
= [168] [VAR[フレーム]]の [[opcode]] が 0, 1, 2 なら、
== [169] [VAR[フレーム]]の [[opcode]] が 0 なら、
=== [177] [VAR[先頭フレーム]]のデータの末尾に[VAR[一時バッファー]]を追加します。
=== [194] ただし実装の扱える長さを超える場合は、失敗とします。ここで停止します。
== [197] それ以外なら、
=== [198] [VAR[フレーム]]のデータを、[VAR[一時バッファー]]に設定します。
== [181] [VAR[フレーム]]の FIN が 1 なら、
=== [182] [VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]の [[opcode]]、
それ以外なら[VAR[フレーム]]の [[opcode]] が 1 なら、
==== [180] [[utf8復号器]]を実行します。
入力を、[VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]のデータ、
それ以外なら[VAR[フレーム]]のデータとします。
エラーモードを致死的に設定します。
==== [178] 失敗なら、理由 [CODE[Invalid UTF-8 in text frame]] で失敗とします。ここで停止します。
==== [183] [VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]のデータ、
それ以外なら[VAR[フレーム]]のデータを、結果に設定します。
=== [179] [VAR[要求]]について、データ受信を通知します。
[VAR[フレーム]]の [[opcode]] が 0 なら[VAR[先頭フレーム]]のデータ、
それ以外なら[VAR[フレーム]]のデータを引き渡します。
=== [187] [VAR[先頭フレーム]]を、 null に設定します。
]FIG]

* HTTP/2

@@

@@ server push

* FTP

[639] An [DFN[FTP connection]] has following states:
[FIG(list members)[
: [DFN[[F[endpoint type][FTP connection's endpoint type]]]] : [CODE[client]]
: [DFN[[F[transport][FTP connection's transport]]]] : A [[transport]].
: [DFN[[F[read buffer][FTP connection's read buffer]]]] : A [[byte string]].
Initially, an empty [[byte string]].
: [DFN[[F[state][FTP connection's state]]]] : Initially, ''connected state''.
: [DFN[[F[username][FTP connection's username]]]] : A [[string]].
: [DFN[[F[password][FTP connection's password]]]] : A [[string]].
: [DFN[[F[established promise][FTP connection's established promise]]]] : A [[promise]].
Initially, an unresolved [[promise]].
: [DFN[[F[path][FTP connection's path]]]] : A [[byte string]].
: [DFN[[F[object type][FTP connection's object type]]]] : Either ''unknown'',
''file'', or ''directory''.  Initially, ''unknown''.
: [DFN[[F[file length][FTP connection's file length]]]] : Either an [[integer]] or
[[null]].  Initially, [[null]].
]FIG]

[1068] An [DFN[FTP reply]] has following states:
[FIG(list members)[
: [DFN[[F[code][FTP reply's code]]]] : A [[string]].
: [DFN[[F[text][FTP reply's text]]]] : A [[byte string]].
]FIG]

[1110] The [[FTP reply]]'s [DFN[[F[first code]]]] is its [F[code][FTP reply's code]]'s
first character.

@@ [574] 
[FIG(steps)[
= [VAR[利用者名]]を、 [[null]] に設定します。
= [VAR[合言葉]]を、 [[null]] に設定します。
= [VAR[credentials]] が [[null]] でなければ、
== [VAR[UA]] が [[IE]] で [VAR[credentials]] が[[匿名]]なら、
=== [VAR[利用者名]]を [CODE[Anonymous]] に設定します。
=== [VAR[合言葉]]を [CODE[ieuser@microsoft.com]] に設定します。
== それ以外なら、
=== [VAR[利用者名]]を、 [VAR[credentials]] の[F[利用者名]]に設定します。
=== [VAR[合言葉]]を、 [VAR[credentials]] の[F[合言葉]]に設定します。
= それ以外で、 [VAR[URL]] の[F[利用者名]]が[[空文字列]]でなければ、
== [VAR[利用者名]]を、[VAR[URL]] の[F[利用者名]]に設定します。
== [VAR[合言葉]]を、 [VAR[URL]] の[F[合言葉]]に設定します。
= それ以外なら、
== [VAR[利用者名]]を、 [CODE[anonymous]] に設定します。
== [VAR[合言葉]]を、 [VAR[UA]] により次の値に設定します。
[FIG(switch)[
: [[Firefox]] : [CODE[mozilla@example.com]]
: [[Chrome]] : [CODE[chrome@example.com]]
: [[IE]] : [CODE[User@]]
]FIG]

]FIG]

[573] To [DFN[initiate an FTP connection]] with
a [[transport]] [VAR[transport]],
a [[string]] [VAR[username]], and a [[string]] [VAR[password]],
run these steps:
[FIG(steps)[
= [575] Let [VAR[ftp]] be a [[FTP connection]].
[FIG(list members)[
[FIGCAPTION[
[[FTP connection]]
]FIGCAPTION]
: [F[endpoint type][FTP connection's endpoint type]] : [CODE[client]]
: [F[transport][FTP connection's transport]] : [VAR[transport]]
: [F[username][FTP connection's username]] : [VAR[username]]
: [F[password][FTP connection's password]] : [VAR[password]]
]FIG]
= [1067] Let [VAR[current code]] be [[null]].
= [1066] Let [VAR[current text]] be an empty [[byte string]].
= [911] Configure [VAR[transport]] to run these substeps whenever
it notifies of [[バイト]]の受信 with [VAR[byte]] and [VAR[urgent data flag]]:
[FIG(steps)[
= [912] If [VAR[urgent data flag]] is set, abort these substeps.
= [1062] Append [VAR[byte]] to [VAR[ftp]]'s [F[read buffer][FTP connection's read buffer]].
= [1094] Optionally, abort these substeps.
= [1063] If [VAR[byte]] contains a [CODE[0x0A]] byte:
== [1064] Split [VAR[ftp]]'s [F[read buffer][FTP connection's read buffer]]
into two substrings at the first [CODE[0x0A]] byte.
Set [VAR[line]] to the first substring and [VAR[ftp]]'s 
[F[read buffer][FTP connection's read buffer]] to the second substring,
not including the [CODE[0x0A]] separator.
== [1065] Remove the [CODE[0x0D]] byte at the end of [VAR[line]], if any.
== [1075] If [VAR[line]] has three [CODE[0x30]]-[CODE[0x39]] bytes followed by
a [CODE[0x20]] or [CODE[0x2D]] byte at the beginning:
=== [1076] Let [VAR[code]] be the first three bytes of [VAR[line]].
=== [1069] Let [VAR[continue]] be whether the fourth byte of [VAR[line]] is [CODE[0x2D]] or not.
=== [1077] Remove first four bytes from [VAR[line]].
=== [1078] If [VAR[current code]] is [[null]]:
==== [1079] Set [VAR[current code]] to [VAR[code]].
==== [1081] Set [VAR[current text]] to [VAR[line]] followed by [CODE[0x0D]] [CODE[0x0A]].
=== [1082] Otherwise, [VAR[current code]] is [VAR[code]]:
==== [1083] Append [VAR[line]] followed by [CODE[0x0D]] [CODE[0x0A]] to [VAR[current text]].
=== [1084] Otherwise:
==== [1085] Set [VAR[current code]] to an [[error]].
=== [1086] If [VAR[current code]] is not an [[error]]:
==== [1087] Let [VAR[reply]] be an [[FTP reply]]:
[FIG(list members)[
: [F[code][FTP reply's code]] : A string obtained by replacing bytes
in [VAR[current code]] by [[code point]]s with same values.
: [F[text][FTP reply's text]] : [VAR[current text]]
]FIG]
==== [1091] Run the [[FTP client state machine]] with [VAR[ftp]] and [VAR[reply]].
== [1070] Otherwise:
=== [1072] Set [VAR[current code]] be [[null]].
=== [1071] Set [VAR[current text]] be an empty [[byte string]].
]FIG]
= [913] Configure [VAR[transport]] to run these substeps whenever
it notifies of 正常終了の受信 or 中断 with [VAR[reset flag]]:
[FIG(steps)[
= [1060] Set [VAR[is abort]] be whether the notification is about 中断 or not.
= [1090] Let [VAR[exit]] be
@@
=
@@
= [1089] Reject [VAR[ftp]]'s [F[established promise][FTP connection's established promise]]
with [VAR[exit]].
]FIG]
= [1088] Return [VAR[ftp]].
]FIG]

@@ 
[1073] [VAR[UA]] が [[Chrome]] で、[CODE[RETR]] と [CODE[LIST]] 以外で2つ目の[[返答]]を受信したら、
異常終了として、ここで停止します。

[1104] To [DFN[send FTP command]] [VAR[command]] with argument [VAR[text]] over [VAR[ftp]],
run these steps:
[FIG(steps)[
= [1105] If [VAR[text]] is [[null]]:
== [1106] Send [VAR[text]] followed by [CODE[0x0D]] [CODE[0x0A]] over [VAR[ftp]].
= [1107] Otherwise:
== [1108] Send [VAR[text]] followed by [VAR[text]] followed by [CODE[0x0D]] [CODE[0x0A]]
over [VAR[ftp]].
]FIG]

[910] To [DFN[establish an FTP data connection]] for [VAR[ftp]] and [VAR[port]],
run these steps:
[FIG(steps)[
= [1188] If [VAR[port]] is less than [N[1024]], is greater than [N[65535]],
or is one of [[bad ports]]:
== [1189] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1184] Let [VAR[host]] be [VAR[ftp]]'s [F[transport][FTP connection's transport]]'s
[F[remote address or domain][transport's remote address or domain]].
= [1185] Let [VAR[proxy]] be [VAR[ftp]]'s [F[transport][FTP connection's transport]]'s
[F[proxy configuration][transport's proxy configuration]].
= [1187] Let [VAR[url]] be a [[URL record]] whose [F[scheme][URL scheme]] is [CODE[ftp][ftp:]],
[F[host][URL's host]] is [VAR[host]], and [F[port][URL's port]] is [VAR[port]].
= [1186] Let [VAR[transport]] be the result of 
[[creating a transport for proxy][create a transport for a proxy configuration]]
[VAR[proxy]] with [VAR[url]].
= [1156] If [VAR[transport]] is a [[failure]]:
== [1190] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1191] Set [VAR[ftp]]'s [F[data transport][FTP connection's data transport]] to
[VAR[transport]].
= [1201] Set [VAR[ftp]]'s [F[data state][FTP connection's data state]] to ''initial state''.
= [1195] Configure [VAR[transport]] to run these substeps whenever
it notifies of [[バイト]]の受信 with [VAR[byte]] and [VAR[urgent data flag]]:
[FIG(steps)[
= [1196] If [VAR[urgent data flag]] is set, abort these steps.
= [1200] Switch by [VAR[ftp]]'s [F[data state][FTP connection's data state]]:
[FIG(switch)[
: ''initial state'' :
[[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
: ''[CODE[RETR]] data state'' :
[FIG(steps)[
=
@@ data event
=
@@ If length is ...
]FIG]
: ''[CODE[LIST]] data state'' :
[FIG(steps)[
@@
]FIG]
]FIG]
]FIG]
= [1197] Configure [VAR[transport]] to run these substeps whenever
it notifies of 正常終了の受信 or 中断 with [VAR[reset flag]]:
[FIG(steps)[
= [1198] Set [VAR[is abort]] be whether the notification is about 中断 or not.
= [1199] Let [VAR[exit]] be
@@
= [1202] If [VAR[ftp]]'s [F[data state][FTP connection's data state]] is
''initial state'':
== [1203] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1204] Otherwise:
==
@@ If length is ...
==
@@ end event
== [1211] Set [VAR[ftp]]'s [F[data state][FTP connection's data state]] to ''exit state''.
==
@@ Close transport.
]FIG]
]FIG]

[1061] To [DFN[set FTP state]] of [[FTP connection]] [VAR[ftp]] to [VAR[state]],
run these steps:
[FIG(steps)[
= [1096] If [VAR[ftp]]'s [F[read buffer][FTP connection's read buffer]] is not empty:
== [1097] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1098] Otherwise:
== [1095] Set [VAR[ftp]]'s [F[state][FTP connection's state]] to [VAR[state]].
]FIG]

[1092] The [DFN[FTP client state machine]] of [[FTP connection]] [VAR[ftp]]
run these steps with [[FTP reply]] [VAR[reply]],
switched by [VAR[ftp]]'s [F[state][FTP connection's state]]:
[FIG(switch)[
: ''Connected state'' : 
[FIG(steps)[
= [1099] If [VAR[reply]] is not [[null]]:
== [1100] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[USER]] reply state''.
== [1103] [[Send FTP command][send FTP command]] `[CODE[USER]]` and
[[UTF-8 encoded][UTF-8 encode]] [VAR[ftp]]'s [F[username][FTP connection's username]]
over [VAR[ftp]].
= [1101] Otherwise:
== [1102] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
: ''[CODE[USER]] reply state'' :
[FIG(steps)[
= [1109] If [VAR[reply]] is not [[null]]:
== [1111] If [VAR[reply]]'s [F[first code]] is [CODE[2]]:
=== [1157] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''authenticated state''.
=== [1126] Resolve [VAR[ftp]]'s [F[established promise][FTP connection's established promise]].
== [1112] Otherwise, [VAR[reply]]'s [F[first code]] is [CODE[3]]:
=== [1118] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''before [CODE[PASS]] reply state''.
=== [1119] [[Send FTP command][send FTP command]] `[CODE[PASS]]` with
[[UTF-8 encoded][UTF-8 encode]] [VAR[ftp]]'s [F[password][FTP connection's password]]
over [VAR[ftp]].
== [1113] Otherwise:
=== [1116] [[Request FTP authentication][request FTP authentication]] for [VAR[ftp]].
= [1114] Otherwise:
== [1115] [[Request FTP authentication][request FTP authentication]] for [VAR[ftp]].
]FIG]
: ''[CODE[PASS]] reply state'' :
[FIG(steps)[
= [1120] If [VAR[reply]] is not [[null]]:
== [1121] If [VAR[reply]]'s [F[first code]] is [CODE[2]]:
=== [1127] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''authenticated state''.
=== [1158] Resolve [VAR[ftp]]'s [F[established promise][FTP connection's established promise]].
== [1122] Otherwise:
=== [1123] [[Request FTP authentication][request FTP authentication]] for [VAR[ftp]].
= [1124] Otherwise:
== [1125] [[Request FTP authentication][request FTP authentication]] for [VAR[ftp]].
]FIG]
: ''[CODE[TYPE]] reply state'' :
[FIG(steps)[
= [1130] If [VAR[reply]] is not [[null]] and
[VAR[reply]]'s [F[first code]] is [CODE[2]]:
== [1137] If [VAR[ftp]]'s [F[transport][FTP connection's transport]]'s
[F[remote address or domain][transport's remote address or domain]] is an 
[[IPv6 address]]:
=== [1140] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[PASV]] reply state''.
=== [1138] [[Send FTP command][send FTP command]] `[CODE[EPSV]]` with [CODE[null]]
over [VAR[ftp]].
== [1139] Otherwise:
=== [1132] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[EPSV]] reply state''.
=== [1136] [[Send FTP command][send FTP command]] `[CODE[PASV]]` with [CODE[null]]
over [VAR[ftp]].
= [1134] Otherwise:
== [1135] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
: ''[CODE[PASV]] reply state'' :
[FIG(steps)[
= [1141] If [VAR[reply]] is not [[null]] and
[VAR[reply]]'s [F[first code]] is [CODE[2]] :
== [1131] If [VAR[reply]]'s [F[text]] matches to the pattern
[CODE[0x28 [VAR[digits]] 0x2C [VAR[digits]] 0x2C [VAR[digits]] 0x2C [VAR[digits]] 0x2C [VAR[digits]] 0x2C [VAR[digits]] 0x29]],
where [VAR[digits]] represents one or more bytes in range [0x30, 0x39]:
=== [1133] Let [VAR[p1]] and [VAR[p2]] be the first such match's last two
[VAR[digits]] substrings, respectively, interpreted as decimal integers encoded in [[UTF-8]].
=== [1143] Let [VAR[port]] be [VAR[p1]] × 256 + [VAR[p2]].
=== [1144] 
[[Establish an FTP data connection][establish an FTP data connection]] for [VAR[ftp]] and
and [VAR[port]].
===
@@
== [1154] Otherwise:
=== [1155] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1142] Otherwise:
== [1145] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
: ''[CODE[EPSV]] reply state'' :
[FIG(steps)[
= [1146] If [VAR[reply]] is not [[null]] and
[VAR[reply]]'s [F[first code]] is [CODE[2]] :
== [1147] If [VAR[reply]]'s [F[text]] matches to the pattern
[CODE[0x28 0x7C 0x7C 0x7C [VAR[digits]] 0x7C 0x29]],
where [VAR[digits]] represents one or more bytes in range [0x30, 0x39]:
=== [1148] Let [VAR[port]] be the first such match's [VAR[digits]] substring,
interpreted as a decimal integer encoded in [[UTF-8]].
=== [1149] 
[[Establish an FTP data connection][establish an FTP data connection]] for
[VAR[ftp]] and [VAR[port]].
===
@@
== [1152] Otherwise:
=== [1153] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1150] Otherwise:
== [1151] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
: ''Authenticated state'' :
[[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
: ''[CODE[TYPE]] reply state'' :
[FIG(steps)[
= [1172] If [VAR[reply]] is not [[null]] and
[VAR[reply]]'s [F[first code]] is [CODE[2]]:
== [1175] If [VAR[ftp]]'s [F[object type][FTP connection's object type]] is ''directory'':
=== [1214] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[CWD]] reply state''.
=== [1215] [[Send FTP command][send FTP command]] `[CODE[CWD]]` with [VAR[ftp]]'s
[F[path][FTP connection's path]] over [VAR[ftp]].
== [1176] Otherwise:
=== [1177] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[SIZE]] reply state''.
=== [1178] [[Send FTP command][send FTP command]] `[CODE[SIZE]]` with [VAR[ftp]]'s
[F[path][FTP connection's path]] over [VAR[ftp]].
= [1173] Otherwise:
== [1174] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
: ''[CODE[SIZE]] reply state'' :
[FIG(steps)[
= [1170] If [VAR[reply]]'s [F[first code]] is [CODE[2]] and
[VAR[reply]]'s [F[text][FTP reply's text]] is one or more bytes in range [0x30, 0x39]:
== [1171] Set [VAR[ftp]]'s [F[file length][FTP connection's file length]] to 
[VAR[reply]]'s [F[text][FTP reply's text]], interpreted as a decimal integer
encoded in [[UTF-8]].
=
@@wait
= [1179] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[RETR]] reply state''.
= [1206] If [VAR[ftp]]'s [F[data connection][FTP connection's data state]] is [[null]] or
[VAR[ftp]]'s [F[data state][FTP connection's data state]] is not ''initial state'':
== [1207] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
= [1208] Otherwise:
== [1205] Set [VAR[ftp]]'s [F[data state][FTP connection's data state]] to ''[CODE[RETR]] data state''.
== [1180] [[Send FTP command][send FTP command]] `[CODE[RETR]]` with [VAR[ftp]]'s
[F[path][FTP connection's path]] over [VAR[ftp]].
== 
@@ event
==
@@ If length is zero
]FIG]
: ''[CODE[RETR]] reply state'' :
[FIG(steps)[
= [1181] If [VAR[reply]]'s [F[first code]] is not [CODE[1]] or [CODE[2]]:
== [1209] If [VAR[ftp]]'s [F[object type][FTP connection's object type]] is [CODE[file]]:
=== [1183] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
== [1210] Otherwise:
===
@@ abort data connection
===
@@ establish
=== [1213] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[CWD]] reply state''.
=== [1212] [[Send FTP command][send FTP command]] `[CODE[CWD]]` with [VAR[ftp]]'s
[F[path][FTP connection's path]] over [VAR[ftp]].
]FIG]
: ''[CODE[CWD]] reply state'' :
[FIG(steps)[
= [1216] If [VAR[reply]] is not [[null]] and
[VAR[reply]]'s [F[first code]] is [CODE[2]]:
==
@@wait
== [1219] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[LIST]] reply state''.
== [1220] If [VAR[ftp]]'s [F[data connection][FTP connection's data state]] is [[null]] or
[VAR[ftp]]'s [F[data state][FTP connection's data state]] is not ''initial state'':
=== [1221] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
== [1222] Otherwise:
=== [1223] Set [VAR[ftp]]'s [F[data state][FTP connection's data state]] to ''[CODE[LIST]] data state''.
=== [1224] [[Send FTP command][send FTP command]] `[CODE[LIST]]` with [[null]] over [VAR[ftp]].
=== 
@@ event
?raw
= [1217] Otherwise:
== [1218] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
: ''[CODE[RETR]] reply state'' :
[FIG(steps)[
= [1225] If [VAR[reply]]'s [F[first code]] is not [CODE[1]] or [CODE[2]]:
== [1226] [[Abort FTP connection][abort FTP connection]] [VAR[ftp]].
]FIG]
]FIG]

[1074] To [DFN[send an FTP request]] [VAR[request]] over [VAR[ftp]],
run these steps:
[FIG(steps)[
= [1159] Assertion: [VAR[ftp]]'s [F[state][FTP connection's state]] has to be
''authenticated state''.
= [1165] Let [VAR[type]] be `[CODE[I]]`.
= [1160] Let [VAR[path]] be concatenation of [VAR[request]]'s [F[url][request's url]]'s 
[F[path]]'s items, separated with [CODE[/]], in order.  This can be the [[empty string]].
= [1161] If [VAR[path]] contains a [CODE[;]] character:
== [1162] Let [VAR[param]] be the first [CODE[;]] character and the following characters
in [VAR[path]].  Remove them from [VAR[path]].
== [1163] Switch by [VAR[param]]:
[FIG(switch)[
: [CODE[;type=a]] :
Set [VAR[ftp]]'s [F[object type][FTP connection's object type]] to ''file''.
Set [VAR[type]] to `[CODE[A]]`.
: [CODE[;type=i]] :
Set [VAR[ftp]]'s [F[object type][FTP connection's object type]] to ''file''.
: [CODE[;type=d]] :
Set [VAR[ftp]]'s [F[object type][FTP connection's object type]] to ''directory''.
]FIG]
= [1166] Set [VAR[path]] be the result of applying [[UTF-8 encode]] to [VAR[path]].
= [1167] Set [VAR[path]] be the result of applying [[percent decode]] to [VAR[path]].
= [1168] If the last byte of [VAR[path]], if any, is 0x2F:
== [1169] Set [VAR[ftp]]'s [F[object type][FTP connection's object type]] to ''directory''.
= [1164] Set [VAR[ftp]]'s [F[path][FTP connection's path]] to [VAR[path]].
= [1128] [[Set FTP state][set FTP state]] of [VAR[ftp]] to ''[CODE[TYPE]] reply state''.
= [1129] [[Send FTP command][send FTP command]] `[CODE[TYPE]]` with [VAR[type]] over 
[VAR[ftp]].
]FIG]


@@
[FIG(steps)[

== [VAR[UA]] が [[Chrome]] なら、
=== 命令を送信します。 [CODE[LIST]] と [CODE[-l]] を引数とします。
@@ [[VMS]] なら、 [CODE[-l]] ではなく [CODE[*.*;0]] を指定します。
== それ以外なら、
=== 命令を送信します。 [CODE[LIST]] と [[null]] を引数とします。
== [VAR[返答]]を、返答の取得の結果に設定します。
== [VAR[UA]] が [[Firefox]] なら、
=== [VAR[返答]]の[F[符号]]の先頭が [CODE[2]] なら、
==== 何かを待ち続けます。
=== それ以外で、[VAR[返答]]の[F[符号]]の先頭が [CODE[1]] 以外なら、
==== 異常終了とし、ここで停止します。
=== それ以外なら、
==== [VAR[種別]]がファイル以外なら、
===== [VAR[URL]] の[F[パス]]を、[VAR[パス]]に [CODE[/]] を連結したものに設定します。
===== [VAR[URL]] への[[リダイレクト]]を返し、ここで停止します。
==== それ以外なら、
===== [VAR[データ接続]]から受信したデータを [CODE(MIME)@en[application/http-index-format]]
に変換したものを返し、ここで停止します。
[CODE(HTTP)@en[Content-Type]] を、 [CODE(MIME)@en[application/http-index-format]]
に設定します。
応答の[F[状態]]を [CODE[200]]、[F[理由句]]を [CODE[OK]] に設定します。
以後返答を受信したら、[VAR[返信]]の[F[符号]]の先頭が [CODE[2]] 以外なら、
[[ネットワークエラー]]として扱います。
== [VAR[UA]] が [[IE]] なら、
=== [VAR[返答]]の[F[符号]]の先頭が [CODE[1]] か [CODE[2]] 以外なら、
==== 異常終了とし、ここで停止します。
=== それ以外なら、
==== [VAR[種別]]がファイル以外なら、
===== [VAR[URL]] の[F[パス]]を、[VAR[パス]]に [CODE[/]] と[VAR[引数]]を連結したものに設定します。
===== [VAR[URL]] について再帰的に本アルゴリズムを実行します。 (同じ接続を再利用します。)
その結果を返し、ここで停止します。
==== それ以外なら、
===== [VAR[データ接続]]から受信したデータを返し、ここで停止します。
[[FTP]] [[ディレクトリー]]一覧としてレンダリングします。
[VAR[パス]]の末尾が [CODE[/]] でない場合、 [CODE[/]] を付加したものを[[ディレクトリー]]の[[パス]]とみなします。
以後返答を受信し、その[F[符号]]の先頭が [CODE[2]] 以外なら、
[[ネットワークエラー]]として扱います。
== [VAR[UA]] が [[Chrome]] なら、
=== [VAR[返答]]の[F[符号]]の先頭が [CODE[1]] か [CODE[2]] 以外なら、
==== 異常終了とし、ここで停止します。
=== それ以外なら、
==== [VAR[データ接続]]から受信したデータを返し、ここで停止します。
[VAR[URL]] の[F[クエリー]]が [CODE[raw]] なら、テキストとしてレンダリングします。
それ以外なら、 [[FTP]] [[ディレクトリー]]一覧としてレンダリングします。
応答の[F[状態]]を [CODE[0]]、[F[理由句]]を[[空文字列]]に設定します。
= [VAR[UA]] が [[Chrome]] なら、
== [CODE[QUIT]]
== ここで停止します。
]FIG]

@@
[1117] To [DFN[request FTP authentication]] of [VAR[ftp]],

@@
[1093] To [DFN[abort FTP connection]] [VAR[ftp]]
[FIG(steps)[
= 接続を閉じます。
= [1192] If [VAR[ftp]]'s [F[data transport][FTP connection's data transport]] is not [[null]]:
== [1193] Let [VAR[ftp]]'s [F[data transport][FTP connection's data transport]] 接続の中断.
== [1194] Set [VAR[ftp]]'s [F[data transport][FTP connection's data transport]] to [[null]].
= If datastart was sent, send dataend
= [[ネットワークエラー]]を返します。
]FIG]



* References

[1044] The terms
[DFN[[[encoding]]]], [DFN[[[UTF-8]]]], [DFN[[[UTF-8 encode]]]], and
[DFN[[[decode]]]] are defined in the [CITE[Encoding Standard]].

[621] The terms 
[DFN[[[C0 controls and space]]]],
[DFN[[[serialize an integer]]]], 
[DFN[[[IPv4 address]]]], 
[DFN[[[IPv4 serializer]]]],
[DFN[[[IPv6 address]]]], [DFN[[[domain]]]],
[DFN[[[host]]]], [DFN[[[host parser]]]], [DFN[[[equals][host equivalence]]]],
[DFN[[[percent decode]]]],
[DFN[scheme][URL scheme (syntax)]],
[DFN[[[URL parser]]]],
[DFN[[[URL record]]]],
[DFN[[F[scheme][URL scheme]]]], [DFN[[F[host]]][URL's host]], [DFN[[F[port]]][URL's port]], and
[DFN[[F[query][URL query]]]]
are defined in the [CITE[URL Standard]].

[981] The term [DFN[[[ICANN DOMAINS]]]] is defined in the [CITE[Public Suffix List]].

[354] The terms
[DFN[[[bad ports]]]],
[DFN[[[request]]]],
[DFN[[F[current url]]]],
[DFN[[F[method][request method]]]],
[DFN[[F[header list][request's header list]]]],
[DFN[[F[body][request body]]]],
[DFN[[[response]]]],
[DFN[[F[status][status code]]]],
[DFN[[F[status message]]]],
[DFN[[F[body][response body]]]],
[DFN[[F[header list][response's header list]]]],
[DFN[[F[HTTPS state]]]],
[DFN[network error]],
[DFN[[[connection]]]],
[DFN[[[obtain a connection]]]],
[DFN[[[obtain a WebSocket connection]]]],
[DFN[[[HTTP-network-or-cache fetch]]]], and
[DFN[[[HTTP-network fetch]]]]
are defined in the [CITE[Fetch Standard]].

[961] The term 
[DFN[[[converted to ASCII lowercase]]]]
is defined in the [CITE[DOM Standard]].

[942] [DFN[[ABBR@en[[[SNI]]][Server Name Indication]]]] is specified in [[RFC 6066]].

[1007] [[WPAD]] is defined by the [[Internet Draft]].

[1008] Someday [[PAC]] might be defined at somewhere.

* XXX

@@
[65] 
- reset vs abort
- [[flagged as full]]
- [CODE[451]]