



[12] [[Perl]] の [CODE(perl)@en[[[Encode]]]] [[モジュール]]には「[[utf8]]」と「[[utf-8]]」
があります。「[[utf8]]」は [[UTF-8]] っぽい[[符号化方式]]を使った [[Perl]]
の[[内部コード]]、「[[utf-8]]」は [[Unicode]] の [[UTF-8]] です。

[SEE[ [[Unicodeの符号空間]] ]]


* utf8 旗と utf8 文字列

@@ ・・・


* [CODE(perl)@en[utf8]] 符号化

[66] [[Perl]] の [CODE(perl)@en[[[Encode]]]] [[モジュール]]は[[文字符号化]]の名前として
「[CODE(perl)@en[[[utf8]]]]」 と 「[CODE(perl)@en[[[utf-8]]]]」に対応しています。
前者は [[Perl]] の[[文字列]]の[[内部符号化]]方式としての [[UTF-8]]
(の[[バイト文字列]]としての表現)、
後者は [[Unicode]] の[[文字符号化方式]]である [[UTF-8]] を表しています。


* [CODE(perl)@en[:utf8]] PerlIO 層

[67] [KBD@en[[[perldoc]] [[PerlIO]]]] にもちゃんと書いてありましたが、
[[PerlIO]] [[層]] [CODE(perl)@en[:[[utf8]]]] を使った入力は不正な入力も黙って受け入れます。
読み込むファイルが [[UTF-8]] として不正な[[バイト列]]であったとしても、警告も何も無しで、
黙って [[utf8]] [[旗]]を立てた SV にするみたいです。なので、入力が不正なバイト列である可能性がある場合、
[CODE(perl)@en[:[[encoding]]([[utf8]])]] を使う必要があります。
こちらは不正なバイト列を [CODE(example)[\x[VAR[HH]]]] に置き換えるようです。

おそらく [CODE(perl)@en[:[[utf8]]]] の方が早いのでしょうが、もし不正なバイト列が混入していた場合、
読み込みの時点では何も起こらず、その後読み込んだ文字列に対して何らかの操作を行おうとした時点で
[Q@en[Malformed UTF-8 character (fatal)]]
というエラーが出ますので、デバッグが難しくなるかもしれません。


* EBCDIC 環境との関係

@@ ・・・




* [CODE[use utf8]] (プラグマ)

** 適用範囲

[1] [CODE[use utf8]] [[プラグマ]]の適用範囲は[[字句スコープ]]内全部だと思ってたのですけど、
([[クロージャー]]でない) [CODE[sub]] 内には適用されないみたい。
知らんかった。

[2] 
でもファイル全体の[[地の文]] (どの[[ブロック]]より外側) に書いたらその内側の
([[クロージャー]]でない) [CODE[sub]] 内にも適用されるよねえ。
[[ブロック]]内の [CODE[use utf8]] はそれとは挙動違うんかあ。

[3] 
特定の ([[大域変数]]ではないが [CODE[sub]] にも属さない) [[字句変数]]と
特定の [CODE[sub]] にだけ [CODE[use utf8]] したいから[[ブロック]]で囲って
[CODE[use utf8]] しても思ったように動かなかった次第。

** [CODE(perl)@en[use encoding]] との関係

@@ ・・・

** メモ

[4] 
[CODE[use utf8]] かどうかと無関係に [CODE[utf8]] 扱いしてくれるオプションが[[文字列リテラル]]につくと嬉しいんだけどなあ。

* メモ


[68] [CITE[Perl, utf8 フラグ, ハッシュ, リテラル, =&gt; - 冬通りに消え行く制服ガールは、夢物語にリアルを求めない。 - subtech]]
([TIME[2010-03-25 09:56:06 +09:00]] 版)
<https://subtech.g.hatena.ne.jp/cho45/20100323/1269329227>


