[1] 
[[文字]]や[[文字列]] (を表す[[グリフ]]や[[グリフ]]の列)
の[[座標空間]]は複雑です。

* 基線

[SEE[ [[基線]] ]]

* OpenType の座標

[115] 
[[OpenType]]
の[[グリフ]]は、
[[座標空間]]上の[[点]]の[[集合]]として記述されます。

[116] 
1つの[[グリフ]]データは、
1つの[[座標空間]]上に配置されています。
このデータを適宜、[[文字]]を[[レンダリング]]するべき位置に配置 (= [[行]]の[[座標空間]]に変換) し、
次の[[文字]]の配置処理へと進んだり、前後の[[文字]]との関係を調整したりすることになります。




[4] [[フォント単位]]

[70] [CODE[kern]]

[REFS[
- [3] [CITE@ja-jp[[[GPOS]] — Glyph Positioning Table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-06T11:34:46.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/gpos>
]REFS]


[71] [CITE@ja-jp[[[LTSH]] - Linear Threshold (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-09T12:24:42.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/ltsh>

[73] [CODE[OS/2][OS/2 (OpenType)]],
[CODE[post][post (OpenType)]],
[CODE[sbix]],
[CODE[STAT][STAT (OpenType)]]

** 前進

[117] 
[[グリフ]]は、
[DFN[[F[[RUBYB[[[前進幅]]][advance width]]]]]],
[DFN[[F[[RUBYB[[[前進高]]][advance height]]]]]]の
2つの[RUBYB[[[前進]]][advance]]の値を持ちます。

[118] 
素朴には、[[原点]] (0, 0) と ([F[前進幅]], [F[前進高]]) 
が[[グリフ]]の描画域と考えることができます。

;; [119] 実際には[[基線]]の関係で [VAR[y]] 方向はもう少し複雑です。

[120] 
[[文字のレンダリング]]の処理では、
[[現在位置]]に[[グリフ]]の[[原点]]を揃えて配置し、
次の[[グリフ]]のために[[現在位置]]を[F[前進幅]]または[F[前進高]]の分だけ移動します。
(より厳密には >>5)

[121] 
現在の一般的な[[仮名]]や[[漢字]]のような[[正方形]]の[[文字]]の場合は、
[[グリフ]]は[F[前進幅]]や[F[前進高]]の範囲に収まるように設計するのが普通です。
つまり[[グリフ]]の[F[外接箱]]は[F[前進幅]]や[F[前進高]]の範囲より小さくなります。

[122] 
しかしそうでない[[グリフ]]も作ることが出来ます。その場合、前後の[[グリフ]]と重なる可能性があります。
[[文字]]によっては (もちろん重なり方は調整しつつ) 意図的にそうすることがあります。


[123] 
[F[前進幅]], [F[前進高]]は[[グリフ]]ごとに固定です。
前後の[[グリフ]]の組み合わせによって[[字間]]を調整したいときは、
[[kerning]] 機能のような他の仕組みを使うことになります。


[42] 
[CODE[hdmx]] [[表][OpenType表]]は[[グリフ]]の [[advance width]]
を各[[フォントサイズ]]における[[画素]]単位の[[整数]]に変換した値を格納しています。
[SRC[>>41]]




[58] 
[CODE[CFF ]] ([[CFF]] 1) [[outline]] は [[advance width]] を持ちます。
[[PostScript]] processor はこれを使います。
[[OpenType]] はこれを使いません。
[SRC[>>43]]

[59] 
[CODE[CFF2]] [[outline]] は [[advance width]] を持ちません。
[SRC[>>43]]

[104] 
[[グリフ]]の [[advance width]] は
[CODE[hmtx]] [[表][OpenType表]]に格納できます。
[SRC[>>43]]


[105] 
[[TrueType outline]] の[[グリフ]]の
[[advance width]]
は、
[[TrueType rasterizer]] 
の計算する[[グリフ]]の
[[phantom point]] 
から得られます。
[CODE[hmtx]] [[表][OpenType表]]からも得られます。
[SRC[>>43]]


[130] 
[CODE[hhea]]
に
[DFN[[F[[CODE[advanceWidthMax]]]]]]
があります。
[CODE[hmtx]]
の[[前進幅]]の最大値とされます。
[SRC[>>124]]



[REFS[

- [41] 
[CITE@ja-jp[[[hdmx]] - Horizontal Device Metrics (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T06:01:54.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/hdmx>
-
[44] 
[CITE@ja-jp[[[glyf]] - Glyf data table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T06:52:01.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/glyf>
-
[52] 
[CITE@ja-jp[[[head]] - Font header table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T07:10:10.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/head>
- [43] 
[CITE@ja-jp[[[hmtx]] - Horizontal metrix table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T06:51:33.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/hmtx>
]REFS]

** 外接箱


[54] 
[[グリフ]]の[DFN[[RUBYB[[RUBY[外][がい]][RUBY[接][せつ]][RUBY[箱][ばこ]]][bounding box]]]]は、
[[グリフ]]のすべての[[制御点]]を含む最小の[[矩形]]です。
[SRC[>>52]]


[45] 
[CODE[glyf]] [[表][OpenType表]]の [[TrueType outline]] [[グリフ]]データは、
[DFN[[F[[CODE[xMin]]]]]],
[DFN[[F[[CODE[yMin]]]]]],
[DFN[[F[[CODE[xMax]]]]]],
[DFN[[F[[CODE[yMax]]]]]]
の4つの [CODE[int16]] 値を持ちます。
[SRC[>>44]]

[62] 
[[TrueType outline]] の[[グリフ]]の [F[[CODE[xMin]]]] と [F[[CODE[xMax]]]] は、
[CODE[glyf]] [[表][OpenType表]]の[[グリフ]]データによります。
[SRC[>>43]]


[47] 
[[TrueType outline]] [[グリフ]]のこの4値は[[グリフ]]の点 
[WEAK[([[on-curve point]] も [[off-curve point]] も)]]
の[[座標]]データから直接得ます。
[[rasterrizer]] が計算した [[phantom point]] は算入しません。
[SRC[>>44]]




[46] 
[[TrueType outline]] [[グリフ]]の[DFN[[RUBYB[[RUBY[外][がい]][RUBY[接][せつ]][RUBY[矩][く]][RUBY[形][けい]]][bounding rectangle]]]]は、
左下 ([F[[CODE[xMin]]]], [F[[CODE[yMin]]]])、
右上 ([F[[CODE[xMax]]]], [F[[CODE[yMax]]]])
の[[方形]]です。
[SRC[>>44]]



[53] 
[CODE[head][head (OpenType)]] [[表][OpenType表]]は、
[DFN[[F[[CODE[xMin]]]]]],
[DFN[[F[[CODE[yMin]]]]]],
[DFN[[F[[CODE[xMax]]]]]],
[DFN[[F[[CODE[yMax]]]]]]
の4つの [CODE[int16]] 値を持ちます。
[SRC[>>52]]

[55] 
[CODE[head][head (OpenType)]] [[表][OpenType表]]のこの4値は、
[[フォント]]中のすべての[[グリフ]]を含む[[外接箱]]を表します。
[[contour]] なき[[グリフ]]は無視します。
[SRC[>>52]]


;; [48] 
[[制御点]]により定義される[[外接箱]]は[[outline]]を含むことが保証されます。
[[outline]] に接するとは限りません。
[SRC[>>44]]

;; [56] [[外接箱]]、[[外接矩形]]の2種類の語が使われていますが、表記揺れで同じ概念と思われます。

;; [112] [[contour]] のない、つまり[[空白]]の[[グリフ]]では定義されません。
各定義により [N[0]] などの値になります。

[132] 
[CODE[hhea]]
に
[DFN[[F[[CODE[xMaxExtent]]]]]]
があります。
lsb + (xMax - xMin)
の最大値を表します。
[SRC[>>124]]


[125] 
[F[[CODE[xMaxExtent]]]]
は、
[[contour]]
を持つ[[グリフ]]のみを使って計算する[RUBYB[べきです][should]]。
[SRC[>>124]]

-*-*-

[106] 
[DFN[side bearing]] は[[グリフ]]の [[contour]] の外側の[[アキ]]を指します。
上下左右にあるうち、

- [107] [DFN[left side bearing]] ([DFN[LSB]]) は [VAR[x]] = [N[0]] から [[contour]]
の左端までの長さです。 [[contour]] が[[負]]の領域まで伸びているときは[[負]]の値になります。
- [108] [DFN[right side bearing]] ([DFN[RSB]]) は[[グリフ]]の [[advance width]]
から [[contour]] の右端までの長さです。 [[contour]] が [[advance width]]
を超えて右に伸びているときは[[負]]の値になります。

;; [109] [[contour]] のない、つまり[[空白]]の[[グリフ]]では定義されません。
各定義により [N[0]] などの値になります。

;; [113] [[外接箱]]が [[off-curve point]] を含む[[点]]に[[外接]]するものだったのに対し、
[[side bearing]] は [[contour]] までの距離なので、
最外が [[off-curve point]] のとき両者は一致しません。
[[LSB]]
と 
[CODE[xMin]]
が等しい、
つまり最左が [[on-curve point]] 
であること
(>>65 の [VAR[pp1]] = 0)
を表すのが
[CODE[head]]
の
[F[[CODE[flags]]]]
の第1ビットです。
[SRC[>>114]]


[110] 
究極的には[[グリフ]]データそのものから計算できますが、
[[グリフ]]の格納形式によっては計算された値が保存されていることがあります。
また、[[フォント]]の[[グリフ]]群全体の統計値が保存されていることがあります。

;; [111] 実際の値と保存されている値が食い違っているときにどう動作するべきなのかは定かではありません。
処理の効率化のために計算値を保存しているのでしょうから、
性能低下を招いたり、表示がずれたりする可能性があるのでしょうか。


[57] 
[[グリフ]]の [[left side bearing]] と [[advance width]] は
[CODE[hmtx]] [[表][OpenType表]]に格納できます。
[SRC[>>43]]



[60] 
[CODE[CFF ]] や [CODE[CFF2]] の[[グリフ]]データには 
[CODE[xMin]] = [[lsb]], [CODE[xMax]] を明示的には含みません。
[[side bearing]] は [CODE[CharString]] データに暗示的に含まれていて、
[CODE[CFF ]] / [CODE[CFF2]] [[rasterizer]] から得られます。
[SRC[>>43]]


[61] 
[[フォント]]生成ツールは、
[[layout engine]] によっては [CODE[hmtx]] の [[left side bearing]]
を使うかも知れませんから、
[[left side bearing]] 
と
[CODE[CFF ]] / [CODE[CFF2]] [[outline]] の
[CODE[CharString]] が暗示する [CODE[xMin]] が一致するようにする[RUBYB[べきです][should]]。
[SRC[>>43]]



[51] 
[[variable font]] の場合は記述された[[外接箱]]が得られた[[グリフ]]のものを表すとは限りません
[SRC[>>44, >>52]]。
必要なら得られた[[グリフ]]の[[制御点]]等から計算する必要があります。
[[side bearing]] は
[[phantom point]]
を使って、あるいは [CODE[HVAR]] のデータから計算できます
[SRC[>>43]]。
[CODE[CFF2]] [[outline]] の [[variable font]] の
[[left side bearing]] と [[advance width]]
は
[[non-default instance]]
では
[CODE[hmtx]] と [CODE[HVAR]]
を総合して得る[RUBYB[べきです][should]]。
[SRC[>>43]]


[49] 
[F[[CODE[xMin]]]] が [[lsb]] と等しくなるように[[グリフ座標]]を取ると
[[scaler]] には都合がいいです。 
[SRC[>>44]]
すべての[[フォント]]がそうである場合には
[CODE[head][head (OpenType)]] [[表]]のその旨のフラグを設定できます
[SRC[>>52]]。
[[TrueType outline]] を持つ [[variable font]] ではこのフラグを設定しなければ[RUBYB[なりません][must]]し、
[[グリフ]]をそのように設計しなければ[RUBYB[なりません][must]]。
[SRC[>>52]]




[50] 
[[right side bearing]] は [[left side bearing]] と [[advance width]] から求められます。
[[bottom side bearing]] は [[top side bearing]] と [[advance height]] から求められます。
[SRC[>>44]]



[63] 
[[TrueType outline]] の[[グリフ]]の
[[advance width]] ([DFN[[VAR[aw]]]])
と
[[left side bearing ([DFN[[VAR[lsb]]]])
は、
[[TrueType rasterizer]] 
の計算する[[グリフ]]の
[[phantom point]] 
から得られます。
[CODE[hmtx]] [[表][OpenType表]]からも得られます。
[SRC[>>43]]

[64] 
[[right side bearing]] ([DFN[[VAR[rsb]]]]) は、次の式によります。
[SRC[>>43]]

[FIG(math)[
[VAR[rsb]] = [VAR[aw]] - ([VAR[lsb]] + [F[[CODE[xMax]]]] - [F[[CODE[xMin]]]])
]FIG]

[65] 
[VAR[pp1]], [VAR[pp2]] を [VAR[lsb]], [VAR[rsb]] を制御する
[[TrueType]] [[phantom point]]
とするとき、
その [[X軸]]方向の初期位置は、次の式によります。
[SRC[>>43]]

[FIG(math)[

[VAR[pp1]] = [F[[CODE[xMin]]]] - [VAR[lsb]]

[VAR[pp2]] = [VAR[pp1]] + [VAR[aw]]

]FIG]

[66] 
[[グリフ]]が [[contour]] を持たないとき、 [F[[CODE[xMin]]]], [F[[CODE[xMax]]]]
は定義されません。
[CODE[hmtx]] の [[left side bearing]] は [N[0]] とする[RUBYB[べきです][should]]。
[SRC[>>43]]


[131] 
[CODE[hhea]]
には
[DFN[[F[[CODE[minLeftSideBearing]]]]]],
[DFN[[F[[CODE[minRightSideBearing]]]]]]
があり、
[CODE[hmtx]]
のうち [[contour]]
がある[[グリフ]]の
[[lsb]],
[[rsb]] = aw - (lsb + xMax - xMin)
の最小値をそれぞれ表します。
[SRC[>>124]]

[126] 
[F[[CODE[minLeftSideBearing]]]],
[F[[CODE[minRightSideBearing]]]]
は、
[[contour]]
を持つ[[グリフ]]のみを使って計算する[RUBYB[べきです][should]]。
[SRC[>>124]]


[REFS[

- [114] 
[CITE@en-us[[[head]] - Font header table (OpenType 1.9.1) - Typography | Microsoft Learn]], [[PeterCon]], [TIME[2024-05-31T17:42:29.000Z]], [TIME[2024-11-26T12:48:16.060Z]] <https://learn.microsoft.com/en-us/typography/opentype/spec/head>

]REFS]

** ascender と descender

[127] 
[CODE[hhea]] には
[DFN[[F[[CODE[ascender]]]]]]
と
[DFN[[F[[CODE[descender]]]]]]
があり、それぞれ
[[typographic ascent]]
と
[[typographic descent]]
を表します。
[[Apple]] 
が使います。
[SRC[>>124]]

[136] 
[CODE[OS/2]]
には
[CODE[sTypoAscender]],
[CODE[sTypoDescender]]
があり、
[[Windows]]
が使います。
[SRC[>>124]]


[139] 
新たな text-layout 実装は [CODE[OS/2]] の方が[RUBYB[推奨][recommended]]されます。
[[フォント]]開発者は[RUBYB[一貫した配置][consistent layout]]のため対象の応用の動作を評価して双方を使う[RUBYB[べきです][should]]。
[SRC[>>124]]


** 横書き用座標値

[REFS[

- [124] 
[CITE@en-us[[[hhea]] - Horizontal header table (OpenType 1.9.1) - Typography | Microsoft Learn]], [[PeterCon]], [TIME[2024-05-31T17:42:19.000Z]], [TIME[2024-11-27T11:22:38.342Z]] <https://learn.microsoft.com/en-us/typography/opentype/spec/hhea>

]REFS]

** 縦書き用座標値

[77] 
[[横書き]]用の[[座標]]値を格納する [CODE[hhea]], [CODE[hmtx]] に対して、
[[縦書き]]用の [DFN[[CODE[vhea]]]] と [DFN[[CODE[vmtx]]]] があります。

[79] 
[[縦書き]]用の[[フォント]]では [CODE[vhea]] を使うことになっていますが [SRC[>>78]]、
[[Windows]] の [[Chrome]], [[Firefox]] とも [CODE[vhea]]
がないからといって[[縦書き]]表示に特別支障となることは無さそうです。
[TIME[2023-11-11T11:24:49.00Z]]

[80] 
[CODE[vhea]] には [CODE[vmtx]] 用の[[グリフ]]数の欄がありますが、
[[Chrome]], [[Firefox]] とも [CODE[vmtx]] が存在しなくてもエラーにはならないようです。
(一方 [CODE[hmtx]] がないとエラーになります。)


[REFS[

- [78] 
[CITE@en-us[[[vhea]] — Vertical header table (OpenType 1.9.1) - Typography | Microsoft Learn]], [[PeterCon]], [TIME[2024-05-31T17:42:16.000Z]], [TIME[2024-11-26T11:33:55.547Z]] <https://learn.microsoft.com/en-us/typography/opentype/spec/vhea>
- [103] [CITE@en-us[[[vmtx]] — Vertical metrics table (OpenType 1.9.1) - Typography | Microsoft Learn]], [[PeterCon]], [TIME[2024-05-31T17:42:32.000Z]], [TIME[2024-11-26T11:35:50.160Z]] <https://learn.microsoft.com/en-us/typography/opentype/spec/vmtx>



]REFS]

** グリフ位置決定

[5] 
[[TrueType]] 
では、
[[グリフ]]の位置は基準となる
[[pen point]]
([[pen position]])
からの[RUBYB[[[配置]]][placement]]と[RUBYB[[[前進]]][advance]]の2値で決まります。
すなわち、
現在の [[pen point]] から[RUBYB[[[テキスト]]][text]]の線に対して、
[[配置]]量だけ移動したところに[[グリフ]]を置きます。
そして次の[[グリフ]]の [[pen point]]
を[[前進]]量だけ移動したところに置きます。
[SRC[>>3]]

[8] 
[[TrueType]]
における[[配置]]と[[前進]]は、
[[横書き]]では[[X軸]], [[縦書き]]では[[Y軸]]の1次元値です。
[SRC[>>3]]

- [7] 
[[左横書き]]では[[配置]]量は [[left side bearing]] ([CODE[horiBearingX]])
となります。
[[前進]]量は [[advance width]] ([CODE[horiAdvance]])
となります。
[SRC[>>3]]
[[グリフ]]は最初の [[pen point]] から右へ右へと並べられていきます。
-
[9] 
[[上縦書き]]では[[配置]]量は [CODE[vertBearingY]]
となります。
[[前進]]量は [CODE[vertAdvance]]
となります。
[SRC[>>3]]
[[グリフ]]は最初の [[pen point]] から下へ下へと並べられていきます。

[10] 
[[TrueType]] では、
[CODE[kern]] [[表][OpenType表]]を使って2つの[[グリフ]]の間の空間の増減を指定できます。
[SRC[>>3]]
前の[[グリフ]]の[[前進]]量に [CODE[kern]] による調整量を足し合わせることで適切なスペースに調整できます。

[11] 
[[OpenType]] では、
[CODE[GPOS]] [[表][OpenType表]]を使って[[配置]]と[[前進]]を
[[X軸]],
[[Y軸]]の2次元で指定できます。
値は[[フォント単位]]によります。
[SRC[>>3]]

- [13] 
[[配置]]は一般的な[RUBYB[[[直交座標系]]][Cartesian coordinate system]]によります。
[[書字方向]]に関わらず、
[[原点]]は[[左]]側の[[基線]]となります。
[SRC[>>3]]
- [14] 
[[前進]]は[[左横書き]]では[[X軸]]方向に [[advance width]] 分[[加算]] ([[右]]移動) し、
[[右横書き]]では[[X軸]]方向に [[advance width]] 分[[減算]] ([[左]]移動) します。
[SRC[>>3]]
[[上縦書き]]では[[Y軸]]方向に [[advance height]] 分[[加算]] ([[下]]移動) します。



[12] 
[CODE[GPOS]] [[表][OpenType表]]では更に[[装置]]依存の調整もできます。
[SRC[>>3]]

[17] 
[CODE[GPOS]] による位置調整は、 [[lookup]] によって一致条件と一致した場合の挙動が記述されますが
[SEE[ [[lookup]] ]]、
同じ[[グリフ]]に対する複数の [[lookup]] による指定は、蓄積されていきます。 [SRC[>>3]]

[EG[
[18] 
[[機能][フォント機能]]1により [[X軸]]方向に3前進し、
[[機能][フォント機能]]2により [[Y軸]]方向に6前進し、
[[機能][フォント機能]]3により [[X軸]]方向に-2前進すると、
[[X軸]]方向には1前進し、
[[Y軸]]方向には6前進することになります。

]EG]

- [19] [CODE[GPOS]] [CODE[lookupType]] [N[1]] では、
単一の[[グリフ]]に対して、
[[X軸]]と[[Y軸]]の[[配置]]と[[前進]] (のそれぞれの[[加算]]量) 
を指定できます。
[SRC[>>3]]
- [20] [CODE[GPOS]] [CODE[lookupType]] [N[2]] では、
2つの[[グリフ]]の[[組]]におけるそれぞれの[[グリフ]]に対して、
[[X軸]]と[[Y軸]]の[[配置]]と[[前進]] (のそれぞれの[[加算]]量) 
を指定できます。
[SRC[>>3]]

[75] 
[CODE[GPOS]] では [CODE[kern]] [[機能][フォント機能]]で[[カーニング]]指定ができますが、
その他の[[機能][フォント機能]]でも同様の位置調整を行えます。

[68] 
[[JstfMax lookup]] では [[justification]] 
において加除する[[X軸]]と[[Y軸]]の[[配置]]と[[前進]]の最大値を指定できます。
実装はこれを使って 0 [[以上]]指定された値[[以下]]の調整を行えます。
[SRC[>>67]]


[76] 
[[結合文字]]関係固有の挙動は、[[結合文字]]のレンダリングの項を参照。

[REFS[
- [67] 
[CITE@ja-jp[[[JSTF]] — Justification Table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T13:21:33.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/jstf#justification-language-system-table>
]REFS]

[74] 
[CITE@ja[GPOSのCursive Attachment Positioningについて - にせねこメモ]], [TIME[2023-11-06T08:49:59.000Z]] <https://nixeneko.hatenablog.com/entry/2017/01/14/200258>

[CODE[curs]] 

** 添付点

[6] 
[[OpenType]] では、
[CODE[GPOS]] [[表][OpenType表]]を使って[RUBYB[[[グリフ添付点]]][glyph attachment point]]による[[グリフ]]間の位置調整も可能です。
[SRC[>>3]]

[16] 
[[添付点]]は[[基底グリフ]]と[[ダイアクリティカルマーク]]の位置調整のために、
あるいは[RUBYB[[[続け字]]][cursive]]における前後の[[グリフ]]の位置調整のために使えます。
[SRC[>>3]]

[15] 
[[OpenType]]
では[[グリフ]]は0個以上の[RUBYB[添付点][attachment point]]を持つことが出来ます。
[SRC[>>3]]
それぞれ上の[[ダイアクリティカルマーク]]位置、
下の[[ダイアクリティカルマーク]]位置といったように使います。


[21] [CODE[GPOS]] [CODE[lookupType]] [N[3]] 
(cursive attachment positioning)
では、
[[グリフ]]の 
[[entry point]] [[anchor]]
と
[[exit point]] [[anchor]]
を設定できます。
両
point [[anchor]]
は、
位置 
[WEAK[([[X軸]]座標と [[Y軸]]座標の組)]]
を指定します。
[SRC[>>3]]


[24] 
2つの[[グリフ]]を並べるとき、1つ目の[[グリフ]]の [[exit point]] から
2つ目の[[グリフ]]の [[entry point]] へと続くようにします。

[23] 
[[line-layout direction]] の調整については、
[[論理順]]で1つ目の[[グリフ]]の[[前進]]を調整します。
結果的に2つ目の[[グリフ]]が移動されて anchor 位置を揃えます。
[SRC[>>3]]

[25] 
[[cross-stream direction]] の調整については、
一方の[[グリフ]]の[[配置]]を調整して他方の[[グリフ]]と anchor 位置を揃えます。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[0]] の場合、
2つ目の[[グリフ]]を調整します。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[1]] の場合、
1つ目の[[グリフ]]を調整します。
[SRC[>>3]]


[26] 
[[entry point]] / [[exit point]] の指定された[[グリフ]]が続く場合、
その[[グリフ]]列全体の配置が連続的に影響されていきます。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[0]] なら、 
最初の[[グリフ]]が[[基線]]基準で配置され、
以後どんどんずれていく形になります。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[1]] なら、 
最後の[[グリフ]]が[[基線]]基準で配置され、
それに向けてどんどんずれが解消してく形になります。

[27] 
[DFN[[F[[CODE[RIGHT_TO_LEFT]]]]]]
[[フラグ]]は
[[lookup]] の [F[[CODE[lookupFlag]]]] [[ビット欄]]の第0ビットです。
[SRC[>>28]]
[[lookup]] の条件を記述する他の[[フラグ]]と違って
[F[[CODE[RIGHT_TO_LEFT]]]]
[[フラグ]]は 
[F[[CODE[lookupType]]]] [N[3]]
の[[グリフ]]位置調整にだけ作用します。

;; [29] 名前に反して[[右横書き]]にはあまり関係ありません。
が巷の[[フォント]]では 
[F[[CODE[lookupType]]]]
と無関係に[[右横書き]]向けの[[グリフ]]が収容された
[[lookup]]
にこのフラグが設定されていたりするようです。
([F[[CODE[lookupType]]]] [N[3]] 以外では指定されていてもいなくても動作は変わりません。)

;; [30] 
[[entry point]] と [[exit point]] 
は、[[書字方向]]によって違う位置にしなければならないのが普通です。
1つの [[lookup]] で同じ[[グリフ]]に対して複数の[[書字方向]]用の
anchor は記述できませんから、
[[書字方向]]ごとの [[lookup]] を用意しなければなりません。
([[続け字]]で同じ[[グリフ]]で違う[[書字方向]]にそのまま適用できる例の方が稀かもしれませんが。)

[31] 
[CODE[GPOS]] [F[[CODE[lookupType]]]] [N[4]]
(Mark-to-Base Attachment Positioning, MarkBasePos)
は、
[[基底グリフ]]と[[マークグリフ]]の組み合わせについて、
両[[グリフ]]にそれぞれの [[anchor point]] を指定するものです。
[SRC[>>3]]

[34] 
[CODE[GPOS]] [F[[CODE[lookupType]]]] [N[5]]
(Mark-to-Ligature Attachment Positioning, MarkLigPos)
は、
[[合字グリフ]]と[[マークグリフ]]の組み合わせについて、
両[[グリフ]]にそれぞれの [[anchor point]] を指定するものです。
[SRC[>>3]]

[37] 
[CODE[GPOS]] [F[[CODE[lookupType]]]] [N[6]]
(Mark-to-Mark Attachment Positioning, MarkMarkPos)
は、
基底となる[[マークグリフ]] mark2 とそれに付加する[[マークグリフ]] mark1
の組み合わせについて、
両[[グリフ]]にそれぞれの [[anchor point]] を指定するものです。
[SRC[>>3]]


[35] 
[[基底グリフ]]の場合は [[anchor point]] は1組だけ指定できます。
[[合字グリフ]]は見かけ上複数の[RUBYB[構成部品][component]]があるかもしれないので、
[[anchor point]] をそれに合わせて複数組設定できます。
[SRC[>>3]]

[32] [[マークグリフ]]は、[[基底グリフ]]と互いの [[anchor point]]
が揃うように[[配置]]を調整します。
[[マークグリフ]]の位置決定は、
[[基底グリフ]]の[[前進]]後の [[pen point]] を基準とします。
[[基底グリフ]]の[[配置]]は変更しません。
両[[グリフ]]の[[前進]]は変更しません。
[SRC[>>3]]

[36] 
[[合字グリフ]]の場合も[[基底グリフ]]と同じようにします。
[SRC[>>3]]
ただし[[合字グリフ]]のときは複数組ある(かもしれない) [[anchor point]]
のいずれを選ぶかが問題となります。
[SEE[ [[文字のレンダリング]] ]]

[38] 
[[マークグリフ]]同士の場合も基底となる[[マークグリフ]] mark2 
に対して同じようにします。
[SRC[>>3]]

;; [33] 
[[lookup]] の機能的に求められる[[基底グリフ]]、
[[合字グリフ]]、
[[マークグリフ]]といった[[グリフ級]]と、
実際に [[lookup]] に記述された[[グリフ]]に割り当てられた[[グリフ級]]は、
一致しないことも[[データ構造]]上はあり得ます。
そのような場合にどうするべきかは言及もされていません。
素直に考えると、これらの [[lookup]] は[[グリフ級]]によって使う、
使わないがまず判断されるのですから、
[[グリフ級]]が一致しないデータが混じっていても単に無視されるだけなのが好ましい実装でしょうか。


[22] 
複数の [[lookup]] の指定は蓄積されることになっていますが [SRC[>>3]]、
適用されるべき
[[entry point]] anchor, [[exit point]] anchor,
[[マークグリフ]]用の [[anchor point]]
が重複するときどう処理するべきかは不明です。
そのような指定は意味を持ちませんから、
[[フォント]]はそのような [[lookup]] を持つべきではないのでしょう。

[39] 
[[基底グリフ]]または[[合字グリフ]]と[[マークグリフ]]との関係による 
[[anchor point]] 
と[[マークグリフ]]と[[マークグリフ]]との関係による
[[anchor point]]
の両方が適用可能なときは、 
[[マークグリフ]]と[[マークグリフ]]の
[[anchor point]]
が優先されることを意図していると考えるのが自然です。

;; [40] こちらの場合は[[基底グリフ]]と[[マークグリフ]]の単体の組み合わせも意味があるのですから、
[[マークグリフ]]と[[マークグリフ]]の [[anchor]] 
との衝突は [[lookup]] の設計の誤りではなく、
優先度が仕様上明確でないことの問題です。


[69] 
[[JstfMax lookup]] で[[添付点]]を指定することは
[CITE[OpenType]] 仕様上明確に禁止されていませんが、
その意味が定められていません。 [SRC[>>103]]
[[添付点]]と「最大値」という [[JstfMax lookup]] の性質はなじまないので、
利用ではないかもしれません。 ([[justification]] によって[[添付点]]が変化するべきなら、
[[JstfMax lookup]] ではなく有効または無効にするべき [[lookup]]
として別に記述できます。 [SEE[ [[JSTF]] ]])


[REFS[
- [28] 
[CITE@ja-jp[OpenType layout common table formats (OpenType 1.9) - Typography | [[Microsoft]] Docs]], [[PeterCon]], [TIME[2022-09-07T09:25:47.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/chapter2#lookupTable>
]REFS]

** 可変フォント

[SEE[ [[HVAR]], [[VVAR]], [[MVAR]] ]]


* SVG 字形配置

[86] 
[CODE[SVG ]]
の[[グリフ]]は、
[[SVG文書]]内の[[座標系]]によって配置された図形を[[文字列]] (の[[グリフ]]列)
の座標空間に配置することになります。

[87] 
[[SVG文書]]の default units は、[[フォント]]の font design units と[RUBYB[等しい][equivalent]]です。
[SRC[>>85]]

[88] 
[[SVG]] の[[原点]] (0, 0) は、[[フォント]]側の design grid の[[原点]]に揃えます。
[VAR[y]] = 0 は、 text layout に使う既定の水平[[基線]]です。
[SRC[>>85]]

[89] 
[[フォント]]側では [VAR[y]] 軸は下方向が[[正]]となりますが、
[[SVG]] の[[座標系]]では [VAR[y]] 軸は上方向が[[正]]となります。
[SRC[>>85]]
従って [[SVG文書]]単体で表示するのと上下逆転することになります。

[93] 
このため字形の大部分は [VAR[x]] が[[正]]、[VAR[y]] が[[負]]の[[象限]]に配置されることがあります。
一般的な図形編集では [VAR[x]] が[[正]]、[VAR[y]] が[[正]]の[[象限]]に配置するので、
例えば [CODE[svg]] [[要素]]の [CODE[viewBox]] [[属性]]を
[CODE[0 1000 1000 1000]]
のように設定して、 [[SVG]] [[座標系]]を [VAR[y]] 軸方向に
[N[1000]]
ずらしておく技法があります。
あるいは対象となる[[要素]]に
[CODE[[[transform]]="translate(0,-1000)"]]
と指定することでずらす技法があります。
[[フォント]]開発工具は、
設計環境から[[フォント]]内の形式へと適切に移すことが期待されています。
[SRC[>>85 (Note, 例示)]]



[90] 
[[SVG文書]]の initial viewport の size は、 em square です。
すなわち、 [[高さ]] = [[幅]] = [CODE[head][head (OpenType)]] の [F[[CODE[unitsPerEm]]]]
です。
[SRC[>>85]]

[91] 
[CODE[svg]] [[要素]]の [CODE[viewBox]] 
[[属性]]で[[幅]]と[[高さ]]が指定されていて >>90 と異なるときは、
[[SVG]] [[利用者座標系]]の scale transformation の効果を持つことになります。
[CODE[svg]] [[要素]]の [CODE[height]] [[属性]]や [CODE[width]] [[属性]]が指定されているときは、
やはり[[座標系]]の scale transformation の効果を持つことになります。
[SRC[>>85]]

[92] 
initial viewport の size は em square ですが、
[[viewport]] を [[clip]] しては[RUBYB[なりません][must not]]。
[CODE[svg]] [[要素]]は [CODE[clip]] [[特性]]の値が [CODE[auto]]、
[CODE[overflow]] [[特性]]の値が [CODE[visible]]
があるものとみなします。
[CODE[svg]] [[要素]]に [CODE[clip]] [[特性]]や [CODE[overflow]]
[[特性]]の違う値が指定されていても、無視しなければ[RUBYB[なりません][must]]。
[[フォント]]は [CODE[svg]] [[要素]]に
[CODE[clip]] [[特性]]や [CODE[overflow]] [[特性]]を指定する[RUBYB[べきではありません][should not]]。
[SRC[>>85]]



[94] 
[[グリフ]]の [[advance width]] は [CODE[hmtx]] の、
[[advance height]] は [CODE[vmtx]] の指定によります。
[SRC[>>85]]

;; [95] つまり他の形式の[[グリフ]]の場合と共通です。

[96] 
[[SVGアニメーション]]や[[CSSアニメーション]]に対応している場合でも、
[[グリフ]]の advance は[[アニメーション]]で変化しては[RUBYB[なりません][must not]]。
[SRC[>>85]]

[98] 
[[グリフ]]の [[bounding box]] は[[フォント]]内に明示的には記述されません。
[[bounding box]] が必要なときは[[レンダリング]]した[[グリフ]]の “ink” bounding box
を使う[RUBYB[べきです][should]]。
これは animated rendering と static rendering で違うかもしれません。
[SRC[>>85]]


[97] 
[CODE[hmtx]] の [[left side bearing]],
[CODE[vmtx]] の [[top side bearing]],
[CODE[head][head (OpenType)]] の [F[[CODE[flags]]]] の第1ビットは、
[[SVG]] [[グリフ]]では使いません。
[SRC[>>85]]






[REFS[

- [85] 
[CITE@en-us[SVG - Scalable vector graphics table (OpenType 1.9.1) - Typography | Microsoft Learn]], [[PeterCon]], [TIME[2024-05-31T17:42:32.000Z]], [TIME[2024-11-18T08:09:48.421Z]] <https://learn.microsoft.com/en-us/typography/opentype/spec/svg>

]REFS]

* 選択と hit testing

[81] 
少なくても [[Windows]] の [[Chrome]] では、 [CODE[OS/2]] の 
[F[[CODE[usWinAscent]]]]
と
[F[[CODE[usWinDescent]]]]
の[[行箱]]の上下の決定に寄与しているように見えます。

[82] [[縦書き]]の左右位置にも影響しているのかいないのか。
[SEE[ [[基線]] ]]

* ブロック軸方向の位置と大きさ

[100] 
[[Windows]] では [CODE[OS/2]] の [F[[CODE[usWinAscent]]]]
と [F[[CODE[usWinDescent]]]] 
を使って
maximum black height を決定します。
[[Windows]]
はこの両者の距離を Font Height
といいます。
[SRC[>>99]]


[101] 
ただし 
[[Windows]] は
[F[[CODE[yMax]]]] と [F[[CODE[yMin]]]]
の外側の [[pixel]]
をくり抜きます。
[[TrueType]] instruction は actual scaled and rounded values と異なる
Font Height を生じることがあって、
Font Height を厳密に [F[[CODE[yMax]]]] と [F[[CODE[yMin]]]] に置くと
「lost pixel」
が生じることになります。
[SRC[>>99]]

[102] この grid fitting の lost pixel 問題を避けるために [DFN[[CODE[VDMX]]]]
[[表][表 (OpenType)]]に修正した高さを記述できます。
[SRC[>>99]]



[REFS[

- [99] 
[CITE@en-us[[[VDMX]] - Vertical Device Metrics (OpenType 1.9.1) - Typography | Microsoft Learn]], [[PeterCon]], [TIME[2024-05-31T17:42:16.000Z]], [TIME[2024-11-26T11:21:58.885Z]] <https://learn.microsoft.com/en-us/typography/opentype/spec/vdmx>

]REFS]

-*-*-

[128] 
[CODE[hhea]] には
[DFN[[CODE[lineGap]]]]
があり、
[[typographic line gap]]
を表します。
[[Apple]]
が使います。
[SRC[>>124]]

[129] 
[[負]]の値は、 [N[0]] として扱う legacy platform があります。
[SRC[>>124]]

[137] 
[CODE[OS/2]]
に
[CODE[sTypoLineGap]]
があり、
[[Windows]]
が使います。
[SRC[>>124]]

[138] 
新たな text-layout 実装は [CODE[OS/2]] の方が[RUBYB[推奨][recommended]]されます。
[[フォント]]開発者は[RUBYB[一貫した配置][consistent layout]]のため対象の応用の動作を評価して双方を使う[RUBYB[べきです][should]]。
[SRC[>>124]]


** [CODE[vertical-align]] 

[83] [[CSS]] の [CODE[vertical-align]] ([CODE[baseline-shift]])
では、選ばれた[[基線]]を基準に、上方 ([[横書き]]の[[上]]) を[[正]]とする値を使います。

[84] その移動量は [CODE[<length>]] か [CODE[<percentage>]] で、後者のときは
[CODE[line-height]] に対する割合となります。

* caret

[133] 
[CODE[hhea]]
に
[DFN[[F[[CODE[caretSlopeRise]]]]]],
[DFN[[F[[CODE[caretSlopeRun]]]]]]
があります。
[SRC[>>124]]

[134] 
[[cursor]] の [[slope]] を [FRAC[rise][run]] として表すとされます。
[[垂直]]のとき [F[[CODE[caretSlopeRise]]]] を [N[1]] とし、
[F[[CODE[caretSlopeRun]]]] を [N[0]] とします。
[SRC[>>124]]

[140] 
[[可変フォント]]に於いては [CODE[MVAR]]
に
[DFN[[CODE[hcrs]]]],
[DFN[[CODE[hcrn]]]]
があります。
[SRC[>>124]]

[135] 
[CODE[hhea]] 
に
[DFN[[F[[CODE[caretOffset]]]]]]
があります。
[[グリフ]]における [[slanted]] highlight の[RUBYB[見栄えが最も良くなる][best appearance]]ために[RUBYB[ずらす][shifted]]べき量を表します。
非 [[slanted]] な[[フォント]]では [N[0]] とします。
[SRC[>>124]]

[141] 
[[可変フォント]]に於いては [CODE[MVAR]]
に
[DFN[[CODE[hcof]]]]
があります。



* ヲコト点

[2] [[ヲコト点座標]]

* 関連

[72] [[Adobe Font Metrics File Format]]

* メモ