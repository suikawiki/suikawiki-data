[1] 
[[文字]]や[[文字列]] (を表す[[グリフ]]や[[グリフ]]の列)
の[[座標空間]]は複雑です。

* 基線

[SEE[ [[基線]] ]]

* OpenType の座標


[4] [[フォント単位]]

[REFS[
- [3] [CITE@ja-jp[[[GPOS]] — Glyph Positioning Table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-06T11:34:46.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/gpos>
]REFS]

[42] 
[CODE[hdmx]] [[表][OpenType表]]は[[グリフ]]の [[advance width]]
を各[[フォントサイズ]]における[[画素]]単位の[[整数]]に変換した値を格納しています。
[SRC[>>41]]


[REFS[
- [41] 
[CITE@ja-jp[[[hdmx]] - Horizontal Device Metrics (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T06:01:54.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/hdmx>
]REFS]


[53] 
[CODE[haed][head (OpenType)]] [[表][OpenType表]]は、
[DFN[[F[[CODE[xMin]]]]]],
[DFN[[F[[CODE[yMin]]]]]],
[DFN[[F[[CODE[xMax]]]]]],
[DFN[[F[[CODE[yMax]]]]]]
の4つの [CODE[int16]] 値を持ちます。
[SRC[>>52]]

[45] 
[CODE[glyf]] [[表][OpenType表]]の [[TrueType outline]] [[グリフ]]データは、
[DFN[[F[[CODE[xMin]]]]]],
[DFN[[F[[CODE[yMin]]]]]],
[DFN[[F[[CODE[xMax]]]]]],
[DFN[[F[[CODE[yMax]]]]]]
の4つの [CODE[int16]] 値を持ちます。
[SRC[>>44]]

[54] 
[[グリフ]]の[DFN[[RUBYB[[RUBY[外][がい]][RUBY[接][せつ]][RUBY[箱][ばこ]]][bounding box]]]]は、
[[グリフ]]のすべての[[制御点]]を含む最小の[[矩形]]です。
[SRC[>>52]]

[55] 
[CODE[haed][head (OpenType)]] [[表][OpenType表]]のこの4値は、
[[フォント]]中のすべての[[グリフ]]を含む[[外接箱]]を表します。
[[contour]] なき[[グリフ]]は無視します。
[SRC[>>52]]

[47] 
[[TrueType outline]] [[グリフ]]のこの4値は[[グリフ]]の点 
[WEAK[([[on-curve point]] も [[off-curve point]] も)]]
の[[座標]]データから直接得ます。
[[rasterrizer]] が計算した [[phantom point]] は算入しません。
[SRC[>>44]]

[46] 
[[TrueType outline]] [[グリフ]]の[DFN[[RUBYB[[RUBY[外][がい]][RUBY[接][せつ]][RUBY[矩][く]][RUBY[形][けい]]][bounding rectangle]]]]は、
左下 ([F[[CODE[xMin]]]], [F[[CODE[yMin]]]])、
右上 ([F[[CODE[xMax]]]], [F[[CODE[yMax]]]])
の[[方形]]です。
[SRC[>>44]]

;; [48] 
[[制御点]]により定義される[[外接箱]]は[[outline]]を含むことが保証されます。
[[outline]] に接するとは限りません。
[SRC[>>44]]

;; [56] [[外接箱]]、[[外接矩形]]の2種類の語が使われていますが、表記揺れで同じ概念と思われます。

[51] 
[[variable font]] の場合は記述された[[外接箱]]が得られた[[グリフ]]のものを表すとは限りません
[SRC[>>44, >>52]]。
必要なら得られた[[グリフ]]の[[制御点]]から計算する必要があります。



[49] 
[F[[CODE[xMin]]]] が [[lsb]] と等しくなるように[[グリフ座標]]を取ると
[[scaler]] には都合がいいです。 
[SRC[>>44]]
すべての[[フォント]]がそうである場合には
[CODE[head][head (OpenType)]] [[表]]のその旨のフラグを設定できます
[SRC[>>52]]。
[[TrueType outline]] を持つ [[variable font]] ではこのフラグを設定しなければ[RUBYB[なりません][must]]し、
[[グリフ]]をそのように設計しなければ[RUBYB[なりません][must]]。
[SRC[>>52]]


[50] 
[[right side bearing]] は [[left side bearing]] と [[advance width]] から求められます。
[[bottom side bearing]] は [[top side bearing]] と [[advance height]] から求められます。
[SRC[>>44]]



[REFS[
-
[44] 
[CITE@ja-jp[[[glyf]] - Glyf data table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T06:52:01.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/glyf>
-
[52] 
[CITE@ja-jp[[[head]] - Font header table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T07:10:10.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/head>
- [43] 
[CITE@ja-jp[[[hmtx]] - Horizontal metrix table (OpenType 1.9) - Typography | Microsoft Docs]], [[PeterCon]], [TIME[2022-09-08T06:51:33.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/hmtx>
]REFS]

** グリフ位置決定

[5] 
[[TrueType]] 
では、
[[グリフ]]の位置は基準となる
[[pen point]]
([[pen position]])
からの[RUBYB[[[配置]]][placement]]と[RUBYB[[[前進]]][advance]]の2値で決まります。
すなわち、
現在の [[pen point]] から[RUBYB[[[テキスト]]][text]]の線に対して、
[[配置]]量だけ移動したところに[[グリフ]]を置きます。
そして次の[[グリフ]]の [[pen point]]
を[[前進]]量だけ移動したところに置きます。
[SRC[>>3]]

[8] 
[[TrueType]]
における[[配置]]と[[前進]]は、
[[横書き]]では[[X軸]], [[縦書き]]では[[Y軸]]の1次元値です。
[SRC[>>3]]

- [7] 
[[左横書き]]では[[配置]]量は [[left side bearing]] ([CODE[horiBearingX]])
となります。
[[前進]]量は [[advance width]] ([CODE[horiAdvance]])
となります。
[SRC[>>3]]
[[グリフ]]は最初の [[pen point]] から右へ右へと並べられていきます。
-
[9] 
[[上縦書き]]では[[配置]]量は [CODE[vertBearingY]]
となります。
[[前進]]量は [CODE[vertAdvance]]
となります。
[SRC[>>3]]
[[グリフ]]は最初の [[pen point]] から下へ下へと並べられていきます。

[10] 
[[TrueType]] では、
[CODE[kern]] [[表][OpenType表]]を使って2つの[[グリフ]]の間の空間の増減を指定できます。
[SRC[>>3]]
前の[[グリフ]]の[[前進]]量に [CODE[kern]] による調整量を足し合わせることで適切なスペースに調整できます。

[11] 
[[OpenType]] では、
[CODE[GPOS]] [[表][OpenType表]]を使って[[配置]]と[[前進]]を
[[X軸]],
[[Y軸]]の2次元で指定できます。
値は[[フォント単位]]によります。
[SRC[>>3]]

- [13] 
[[配置]]は一般的な[RUBYB[[[直交座標系]]][Cartesian coordinate system]]によります。
[[書字方向]]に関わらず、
[[原点]]は[[左]]側の[[基線]]となります。
[SRC[>>3]]
- [14] 
[[前進]]は[[左横書き]]では[[X軸]]方向に [[advance width]] 分[[加算]] ([[右]]移動) し、
[[右横書き]]では[[X軸]]方向に [[advance width]] 分[[減算]] ([[左]]移動) します。
[SRC[>>3]]
[[上縦書き]]では[[Y軸]]方向に [[advance height]] 分[[加算]] ([[下]]移動) します。



[12] 
[CODE[GPOS]] [[表][OpenType表]]では更に[[装置]]依存の調整もできます。
[SRC[>>3]]

[17] 
[CODE[GPOS]] による位置調整は、 [[lookup]] によって一致条件と一致した場合の挙動が記述されますが
[SEE[ [[lookup]] ]]、
同じ[[グリフ]]に対する複数の [[lookup]] による指定は、蓄積されていきます。 [SRC[>>3]]

[EG[
[18] 
[[機能][フォント機能]]1により [[X軸]]方向に3前進し、
[[機能][フォント機能]]2により [[Y軸]]方向に6前進し、
[[機能][フォント機能]]3により [[X軸]]方向に-2前進すると、
[[X軸]]方向には1前進し、
[[Y軸]]方向には6前進することになります。

]EG]

- [19] [CODE[GPOS]] [CODE[lookupType]] [N[1]] では、
単一の[[グリフ]]に対して、
[[X軸]]と[[Y軸]]の[[配置]]と[[前進]] (のそれぞれの[[加算]]量) 
を指定できます。
[SRC[>>3]]
- [20] [CODE[GPOS]] [CODE[lookupType]] [N[2]] では、
2つの[[グリフ]]の[[組]]におけるそれぞれの[[グリフ]]に対して、
[[X軸]]と[[Y軸]]の[[配置]]と[[前進]] (のそれぞれの[[加算]]量) 
を指定できます。
[SRC[>>3]]


** 添付点

[6] 
[[OpenType]] では、
[CODE[GPOS]] [[表][OpenType表]]を使って[RUBYB[[[グリフ添付点]]][glyph attachment point]]による[[グリフ]]間の位置調整も可能です。
[SRC[>>3]]

[16] 
[[添付点]]は[[基底グリフ]]と[[ダイアクリティカルマーク]]の位置調整のために、
あるいは[RUBYB[[[続け字]]][cursive]]における前後の[[グリフ]]の位置調整のために使えます。
[SRC[>>3]]

[15] 
[[OpenType]]
では[[グリフ]]は0個以上の[RUBYB[添付点][attachment point]]を持つことが出来ます。
[SRC[>>3]]
それぞれ上の[[ダイアクリティカルマーク]]位置、
下の[[ダイアクリティカルマーク]]位置といったように使います。


[21] [CODE[GPOS]] [CODE[lookupType]] [N[3]] 
(cursive attachment positioning)
では、
[[グリフ]]の 
[[entry point]] [[anchor]]
と
[[exit point]] [[anchor]]
を設定できます。
両
point [[anchor]]
は、
位置 
[WEAK[([[X軸]]座標と [[Y軸]]座標の組)]]
を指定します。
[SRC[>>3]]


[24] 
2つの[[グリフ]]を並べるとき、1つ目の[[グリフ]]の [[exit point]] から
2つ目の[[グリフ]]の [[entry point]] へと続くようにします。

[23] 
[[line-layout direction]] の調整については、
[[論理順]]で1つ目の[[グリフ]]の[[前進]]を調整します。
結果的に2つ目の[[グリフ]]が移動されて anchor 位置を揃えます。
[SRC[>>3]]

[25] 
[[cross-stream direction]] の調整については、
一方の[[グリフ]]の[[配置]]を調整して他方の[[グリフ]]と anchor 位置を揃えます。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[0]] の場合、
2つ目の[[グリフ]]を調整します。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[1]] の場合、
1つ目の[[グリフ]]を調整します。
[SRC[>>3]]


[26] 
[[entry point]] / [[exit point]] の指定された[[グリフ]]が続く場合、
その[[グリフ]]列全体の配置が連続的に影響されていきます。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[0]] なら、 
最初の[[グリフ]]が[[基線]]基準で配置され、
以後どんどんずれていく形になります。
[F[[CODE[RIGHT_TO_LEFT]]]] が [N[1]] なら、 
最後の[[グリフ]]が[[基線]]基準で配置され、
それに向けてどんどんずれが解消してく形になります。

[27] 
[DFN[[F[[CODE[RIGHT_TO_LEFT]]]]]]
[[フラグ]]は
[[lookup]] の [F[[CODE[lookupFlag]]]] [[ビット欄]]の第0ビットです。
[SRC[>>28]]
[[lookup]] の条件を記述する他の[[フラグ]]と違って
[F[[CODE[RIGHT_TO_LEFT]]]]
[[フラグ]]は 
[F[[CODE[lookupType]]]] [N[3]]
の[[グリフ]]位置調整にだけ作用します。

;; [29] 名前に反して[[右横書き]]にはあまり関係ありません。
が巷の[[フォント]]では 
[F[[CODE[lookupType]]]]
と無関係に[[右横書き]]向けの[[グリフ]]が収容された
[[lookup]]
にこのフラグが設定されていたりするようです。
([F[[CODE[lookupType]]]] [N[3]] 以外では指定されていてもいなくても動作は変わりません。)

;; [30] 
[[entry point]] と [[exit point]] 
は、[[書字方向]]によって違う位置にしなければならないのが普通です。
1つの [[lookup]] で同じ[[グリフ]]に対して複数の[[書字方向]]用の
anchor は記述できませんから、
[[書字方向]]ごとの [[lookup]] を用意しなければなりません。
([[続け字]]で同じ[[グリフ]]で違う[[書字方向]]にそのまま適用できる例の方が稀かもしれませんが。)

[31] 
[CODE[GPOS]] [F[[CODE[lookupType]]]] [N[4]]
(Mark-to-Base Attachment Positioning, MarkBasePos)
は、
[[基底グリフ]]と[[マークグリフ]]の組み合わせについて、
両[[グリフ]]にそれぞれの [[anchor point]] を指定するものです。
[SRC[>>3]]

[34] 
[CODE[GPOS]] [F[[CODE[lookupType]]]] [N[5]]
(Mark-to-Ligature Attachment Positioning, MarkLigPos)
は、
[[合字グリフ]]と[[マークグリフ]]の組み合わせについて、
両[[グリフ]]にそれぞれの [[anchor point]] を指定するものです。
[SRC[>>3]]

[37] 
[CODE[GPOS]] [F[[CODE[lookupType]]]] [N[6]]
(Mark-to-Mark Attachment Positioning, MarkMarkPos)
は、
基底となる[[マークグリフ]] mark2 とそれに付加する[[マークグリフ]] mark1
の組み合わせについて、
両[[グリフ]]にそれぞれの [[anchor point]] を指定するものです。
[SRC[>>3]]


[35] 
[[基底グリフ]]の場合は [[anchor point]] は1組だけ指定できます。
[[合字グリフ]]は見かけ上複数の[RUBYB[構成部品][component]]があるかもしれないので、
[[anchor point]] をそれに合わせて複数組設定できます。
[SRC[>>3]]

[32] [[マークグリフ]]は、[[基底グリフ]]と互いの [[anchor point]]
が揃うように[[配置]]を調整します。
[[マークグリフ]]の位置決定は、
[[基底グリフ]]の[[前進]]後の [[pen point]] を基準とします。
[[基底グリフ]]の[[配置]]は変更しません。
両[[グリフ]]の[[前進]]は変更しません。
[SRC[>>3]]

[36] 
[[合字グリフ]]の場合も[[基底グリフ]]と同じようにします。
[SRC[>>3]]
ただし[[合字グリフ]]のときは複数組ある(かもしれない) [[anchor point]]
のいずれを選ぶかが問題となります。
[SEE[ [[文字のレンダリング]] ]]

[38] 
[[マークグリフ]]同士の場合も基底となる[[マークグリフ]] mark2 
に対して同じようにします。
[SRC[>>3]]

;; [33] 
[[lookup]] の機能的に求められる[[基底グリフ]]、
[[合字グリフ]]、
[[マークグリフ]]といった[[グリフ級]]と、
実際に [[lookup]] に記述された[[グリフ]]に割り当てられた[[グリフ級]]は、
一致しないことも[[データ構造]]上はあり得ます。
そのような場合にどうするべきかは言及もされていません。
素直に考えると、これらの [[lookup]] は[[グリフ級]]によって使う、
使わないがまず判断されるのですから、
[[グリフ級]]が一致しないデータが混じっていても単に無視されるだけなのが好ましい実装でしょうか。


[22] 
複数の [[lookup]] の指定は蓄積されることになっていますが [SRC[>>3]]、
適用されるべき
[[entry point]] anchor, [[exit point]] anchor,
[[マークグリフ]]用の [[anchor point]]
が重複するときどう処理するべきかは不明です。
そのような指定は意味を持ちませんから、
[[フォント]]はそのような [[lookup]] を持つべきではないのでしょう。

[39] 
[[基底グリフ]]または[[合字グリフ]]と[[マークグリフ]]との関係による 
[[anchor point]] 
と[[マークグリフ]]と[[マークグリフ]]との関係による
[[anchor point]]
の両方が適用可能なときは、 
[[マークグリフ]]と[[マークグリフ]]の
[[anchor point]]
が優先されることを意図していると考えるのが自然です。

;; [40] こちらの場合は[[基底グリフ]]と[[マークグリフ]]の単体の組み合わせも意味があるのですから、
[[マークグリフ]]と[[マークグリフ]]の [[anchor]] 
との衝突は [[lookup]] の設計の誤りではなく、
優先度が仕様上明確でないことの問題です。



[REFS[
- [28] 
[CITE@ja-jp[OpenType layout common table formats (OpenType 1.9) - Typography | [[Microsoft]] Docs]], [[PeterCon]], [TIME[2022-09-07T09:25:47.000Z]] <https://docs.microsoft.com/ja-jp/typography/opentype/spec/chapter2#lookupTable>
]REFS]

* ヲコト点

[2] [[ヲコト点座標]]

* メモ