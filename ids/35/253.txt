[35] 
[[Unicode]]
には
[DFN[annotation characters]]
と称する[[特別][Specials]]な[[文字]]があります。
[[ルビ]]を記述することを想定したようですが、
ほとんど使われていません。

* 代替

[25] ほとんど実装されていないので、使うべきではありません。
[[ルビ]]は [[HTML]] の [CODE[ruby]] [[要素]]など、
[[マーク付け言語]]などの機能によって記述するべきです。

* 仕様書

[REFS[
- [33] 
[CITE[The Unicode Standard, Version 13.0 - ch23.pdf]], [TIME[2020-03-09T17:53:52.000Z]], [TIME[2020-12-13T07:28:31.667Z]] <https://www.unicode.org/versions/latest/ch23.pdf#G27446>
- [1] [CITE[[[The Unicode Standard]], Version 12.0 - ch23.pdf]] ([TIME[2019-03-02 07:15:46 +09:00]]) <https://www.unicode.org/versions/latest/ch23.pdf#G15944>
]REFS]

* 意味

[2] 
[DFN[interlinear annotation]]
は、
[DFN[annotated]] [[文字]]群の列に関係付けられた
[DFN[annotating text]]
によって構成されます。
[SRC[>>1]]
[[paired stateful controls]] です。

[3] 
通常の[[編集]]や[[テキスト処理]]のアルゴリズムにあっては、
[[annotated]]
[[文字]]群は[[テキストストリーム]]の一部として扱います。
[SRC[>>1]]

[8] 
[[適合実装]]は、
[[annotation character]]
に[[対応]]する場合にあっては、
base text
を annotate されていない[[テキストストリーム]]の一部である場合と同様に解釈します。
[SRC[>>1]]



[7] 
[[annotating text]]
も[[内容]]の一部ですが、
[[テキスト処理]]の一部または全部においては[RUBYB[主たる][main]][[テキストストリーム]]の一部を構成しません。
[SRC[>>1]]

[4] 
ただし、
[[annotating text]]
中の[[文字]]は、
[RUBYB[基底テキスト][base text]]と同種の[[配置]]、
[[テキスト処理]]、
[[編集]]のアルゴリズムでアクセス可能です。
[SRC[>>1]]

[9] 
[[適合実装]]は、
[[annotation character]]
に[[対応]]する場合にあっては、
[[annotating text]]
中の
annotating character
を通常の [[Unicode]] の[RUBYB[[[意味]]][semantics]]によって解釈します。
[SRC[>>1]]


[5] 
[[annotation character]] は、
[[annotating text]] と
[[annotated]] text
を区切り、
これを annotation の一部として示すものです。 [SRC[>>1]]

[REFS[
- [32] [[annotation characters]]
の一覧
<https://chars.suikawiki.org/set/%24unicode%3Aannotation-characters>

]REFS]

[10] 
[DFN[[CODE(char)[U+FFF9]]]]
[DFN[[CODE(charname)@en[INTERLINEAR ANNOTATION ANCHOR]]]]
は、
[[interlinear annotation]] の前に来る anchor [[文字]]です。
[SRC[>>1]]

[11] 
[DFN[[CODE(char)[U+FFFA]]]]
[DFN[[CODE(charname)@en[INTERLINEAR ANNOTATION SEPARATOR]]]]
は、
[[テキストストリーム]]中の base character 群を次の
[[annotation character]] 群から区切るものです。
[SRC[>>1]]

[12] [CODE(char)[U+FFFA]] は複数あっても構わず、
[RUBYB[複数部分][multipart]]の [[annotating text]]
の各部を区切ります。
[SRC[>>1]]

[13] 
[DFN[[CODE(char)[U+FFFB]]]]
[DFN[[CODE(charname)@en[INTERLINEAR ANNOTATION TERMINATOR]]]]
は、
annotation object を終端する
(通常の[[テキストストリーム]]に復帰する) ものです。
[SRC[>>1]]



[6] 
[[annotation character]] は、
[RUBYB[外部][out-of-band]]情報が[[文字ストリーム]]に関連付けられているときに内部処理で使います。
[[annotation]]
の正確な性質や[RUBYB[書式付け][formatting]]は、
[[平文ストリーム]]の一部ではない追加の情報に依存します。
これは [CODE(char)[U+FFFC]] [CODE(charname)@en[OBJECT REPLACEMENT CHARACTER]]
とよく似ていますが、
[CODE(char)[U+FFFC]]
はこの[[文字]]によって不透明なオブジェクトを隠すのに対し、
annotation の場合それ自体はテキストなのであります。
[SRC[>>1]]

;; [26] [CITE[Unicode Standard]] の規定はあやふやで用語も揺れまくっていて、
[[行間を読む]]他ない惨状です。 [[HTML]] の [CODE[ruby]]
を知っていれば、だいたい何をやりたかったのかは推測できます。

* 構文

[17] 
anchor 文字は、
対応する
terminator 文字の前になければなりません。
[SRC[>>1]]

[19] 
annotation
は入れ子にして構いません。
[SRC[>>1]]

[FIG(railroad)[ [27] [[interlinear annotation]]
= [CODE[U+FFF9]]
= [[annotated]]
= +
== [CODE[U+FFFA]]
== [[annotating text]]
= [CODE[U+FFFB]]

]FIG]

[29] 
[[annotated]] と
[[annotating text]]
に[[改段落]]を含むことはできません (>>16)。
[[空文字列]]でも良いのかは定かではありません。

* 文脈

[28] 
[[annotation character]]
は、
通常は[[末端利用者]]に直接[[入力]]、[[編集]]されません。
一般的には[[応用]]が[[テキスト]]の[[選択]]と[RUBYB[注釈付け][annotating]]の[[利用者インターフェイス]]を提示し、
挿入と管理を行うものです。
[SRC[>>1]]


[14] 
[[annotation character]]
の[[平文]]における使用は、
[[送受信者間の事前の合意][当事者間の合意]]がある場合を除き、
[[内容]]が誤解されるおそれがあるため、
[RUBYB[強く非推奨][strongly discouraged]]です。
[SRC[>>1]]

[15] 
[[annotation character]]
を除去するだけでは読めない結果が生成されたり、
最悪、意味が逆になってしまうかもしれません。
[[平文]]の受信者は、
入力中のすべての[[文字]]をそのまま残すか、
[[interlinear annotation character]] と [[annotating text]]
を削除するかのいずれかとするべきです。
[[平文]]の出力時に送信者が受信者を知らない場合、
[[interlinear annotation character]] と [[annotating text]]
を削除するべきです。
[SRC[>>1]]

* 処理

[16] 
[[実装]]は、
anchor 文字の後、
terminator 文字の前に[[改段落]]が出現した場合、
開いている [[annotation]] を閉じなければなりません。
[SRC[>>1]]

[18] 
組になっていない
anchor 文字や
terminator 文字は、
無視するべきです。
[SRC[>>1]]


[20] 
anchor 文字と
terminator 文字の組の外側に出現した 
separator 文字は、
無視するべきです。
[SRC[>>1]]

[30] 
[[照合]]では、
annotation
を[[整列キー]]として使うことを想定する特殊な場合を除き、
無視するか、
任意選択により前処理して [[tie breaker]] としてのみ使うこととするのが普通です。
annotation base character 群は無視せず、
通常の[[テキスト]]として扱うことが重要であります。
[SRC[>>1]]


* レンダリング

[21] 
[RUBYB[書式付け][formatting]]に関する情報は、
[[上位層プロトコル]]によって提供されます。
[[配置]]の詳細は[[実装定義]]です。
正確な書式付けのために必要な追加情報は[[文字ストリーム]]中に現れず、
[RUBYB[外部][out-of-band]]に示されるかもしれません。
従って annotation marker は別情報源の情報にアクセスできる実装のための
[[placeholder]]
として機能するのです。
[SRC[>>1]]

[22] 
書式付けその他[[行組版]]の特殊機能については [[JIS X 4051]]
で議論されています。
[SRC[>>1]]
と説明されていますが、
[[JIS X 4051]]
の[[ルビ]]のモデルに
[[annotation characters]]
がどう当てはまりどう処理しどう表示するべきなのか、
説明が無さすぎます。

[23] 
[CITE[Unicode Standard]] の利用例図 [SRC[>>1]]
にある通り、 [[ルビ]]として[[レンダリング][文字のレンダリング]]されることが想定されていますが、
利用方法は実装依存となっていて [CITE[Unicode Standard]]
は完全に丸投げしています。

[24] 
意図通りに正しくレンダリングする実装があるのかは不明であり、
主要な実装では皆無です。外部情報が必要とされ、
具体的なことは何も定められていないのですから、
実装できるはずもありません。

[34] 
未対応の実装は、
通常の未対応の[[文字]]のときのように、
可視的なグリフを表示する[RUBYB[べき][should]]です。
そうしなければ境目がわからなくなって誤読を招くおそれがあります。
[SRC[>>33]]


[31] 
[[bidi]] アルゴリズムは、
[[interlinear annotation]]
を
[[annotated text]] 
に置き換えた上で各々の [[annotated text]]
が視覚的に連続するよう
[[bidirectional format control character]]
で囲んだ主たるテキストに適用するべきであり、
更にそれぞれの [[annotating text]]
に別個に適用するべきであります。
[SRC[>>1]]


* メモ

[36] 
この機能は[[プレインテキスト]]での使用は強く非推奨とされています。
特定の[[アプリケーション]]で、あるいは内部処理で利用することが想定されているようです。
しかしながら、
この機能で記述できる[[ルビ]]は、現実に利用されるもののごく一部でしかなく、
貧弱です。
[[アプリケーション]]依存の情報を追加して利用することが想定されているようですが、
[[アプリケーション]]依存の仕組みによるのであれば、
[[アプリケーション]]のネイティブの仕組みの方が扱いやすいでしょうから、
敢えてこの機能を使う理由がありません。
実際に
[[HTML]]
はこの機能を使わず、
[[HTML]]
の[[要素]]の仕組みに載せた
[CODE[ruby]]
[[要素]]を使っています。
つまるところ、
この機能が便利に使える場面はありません。

[37] 
もうちょっとうまいことモデル化して定義してあれば、
[[bidi]]
制御用の文字のように[[プレインテキスト]]でもそれ以外でも[[ルビ]]状構造をうまく扱える世界が実現していたかもしれないのに、
残念なことです。



