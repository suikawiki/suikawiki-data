[3] 
[[ISO/IEC 2022]]
には
[[7ビット符号]]と[[8ビット符号]]があります。

[1] [[歴史的経緯]]以外に7ビット符号と8ビット符号の2種類あって嬉しいことってあるんだろうか?
(確かに一部の世界・プロトコルではその「歴史的経緯」
が重たいのではありますが。)

[2] むしろ7ビットと8ビットで [[ISO/IEC 2022]] の 
[[符号化文字データ要素]]の解釈が微妙に変化する部分がある 
(例外とはいえ。) 方が弊害が大きいですよね。 
(今更どうにもなりませんけどね。)


*8ビット符号から7ビット符号へ
-[[最上位ビット]]が 0 の時はそのままで OK
-[[CR]] → ESC Fe
-[[GR]] → [[GL]], 適切なシフト機能。
-単独シフト + [[GR]] → 単独シフト + [[GL]]

([[ISO/IEC2022]] 1994 11)

*7ビット符号から8ビット符号へ
-最上位ビットを 0 にし、残り7ビットはそのままで OK
-必要なら8ビット符号→7ビット符号の逆の操作をしてもよい(may)

8ビット符号から変換された7ビット符号の時は、 LS1R,
LS2R, LS3R が出現するかもしれないから、それを復元する
必要があるかも(may)。

([[ISO/IEC2022]] 1994 11)

*変換に関係する例外的規定



[[ISO/IEC2022]] 系の7ビット符号と8ビット符号は、
両者間の変換の便宜のために、ちょいと困った例外規定があります。

[4] [CITE[Standard master - ECMA-48_5th_edition_june_1991.pdf]], [TIME[2021-01-16T09:56:56.000Z]], [TIME[2022-05-15T03:32:51.727Z]] <https://www.ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf#page=88>

次の場所は本来左を使いますが、8ビット符号では右を使っても構いません。
([[ISO/IEC6429]] 9)

-[[制御列]]の P,I,F バイト
-[[制御文字列]]の命令列または文字列
-単独シフト制御機能の対象

(かつて [[EUC]] はこの規定を根拠に SS2, SS3 の後で [[GR]]
を使っていました。(と解釈されていました。) これは後の [[ISO/IEC2022]]
の改訂で例外扱いでは無しに、 SS + GR を使えることになりました。)

7ビット符号では次のところに SI や SO が来ても構いません。 ([[ISO/IEC6429]] 9)

-制御列の CSI と終端バイトの間
-制御文字列の開始区切子と ST の間
-単独シフト制御機能と対象の間

(制御文字列では元々 00/14 と 00/15 は使えると思うんですが...
それと区別する必要があるんですかね? (あるとしても無理だが。))

7ビット符号では次のところに [[GL]] が来ても構いません。
([[ISO/IEC2022]] 1994 11)

-LS1R, LS2R, LS3R と次の固定シフトの間

これらの規定が設けられたのは、おそらく古い ISO/IEC 2022
の規定に従って設計された7ビット←→8ビット変換器を[[CCデータ要素]]
が通過した時に、新しい ISO/IEC 2022 の機能を使っていても
最終的に新しい ISO/IEC 2022 の受信装置が理解出来るように、
ということだと思われます。

ところで、 SI や SO って [[C0]] 制御文字集合に何を使うかによって
符号位置が変化する(可能性がある)んじゃないですか... めんどいなぁ。
- [1] この規定のせいで、7単位符号と8単位符号では[[受信装置]]側の処理が少し違ってきてしまいます。これが困った点です。
- [2] [[SI]]/[[SO]] は登録されている[[C0文字集合]]では同じ[[符号位置]]ですね。これは仮定してもいいかもしれません。 (変なC0集合作る人なんていないでしょ。) ただし、 SI/SO が存在''しない'' C0 集合は''ある''ので注意です。

* メモ