[1] 本項で言う[DFN[下位層の接続]]とは、 [[TCP]] の[[接続]]やそれに類するものを言います。
[[信頼性]]のある[[全二重]]の[[バイト列]]の[[輸送路]]です。

* 仕様書

[REFS[
- [176] [CITE[Web Transports]]
]REFS]

* プロトコル

[2] 次のような具体的な[[プロトコル]]があります。
[FIG(short list)[
- [[TCP]]
- [[TLS]]
- [[HTTP/1.x]] [CODE(HTTP)@en[[[CONNECT]]]]
- [[HTTP/2]] [CODE(HTTP)@en[[[CONNECT]]]]
- [[SOCKS]]4
- [[SOCKS]]5
- [[Unix domain socket]]
]FIG]

* 状態と API

[18] [[接続]]の端点は、その種類に依存した[[接続]]確立の処理によって作成されます。
[[接続]]の確立完了時に、接続の種類に依存した情報を[[アプリケーション]]に引渡します。

[3] [[接続]]の端点は、次の状態を持ちます。
[FIG(list members)[
:[VAR[種別]]:「サーバー」または「クライアント」。
:[VAR[送信閉じ済みフラグ]]:初期状態では未設定。
:[VAR[受信閉じ済みフラグ]]:初期状態では未設定。
:[VAR[送信待ちバッファー]]:初期状態では空のリスト。
]FIG]

[6] [[アプリケーション]]は、[[接続]]の端点に次の指示を行えます。
[FIG(list)[
- [[バイト]]の送信の指示
- 正常終了の送信の指示
- 中断の指示
- credentials の送信の指示
]FIG]

[7] [[バイト]]の送信の指示は、送信する[[バイト]] (0-255 のいずれかの値)と、
[[緊急データ]]か否かのフラグ (既定値は未設定。)
を[[引数]]とし、次のように処理します。
[FIG(steps)[
= [41] [VAR[送信閉じ済みフラグ]]が設定されていれば、[[例外]]を投げて停止します。
= [19] [VAR[送信待ちバッファー]]が満杯なら、[[例外]]を投げて停止します。
= [21] [[緊急データ]]フラグが設定されていて、
接続の種類が[[緊急データ]]に対応していないものなら、
[[例外]]を投げて停止します。
= [20] [VAR[送信待ちバッファー]]の末尾に、
引数の[[バイト]]、
引数の[[緊急データ]]か否かのフラグ、
[[約束]]の組を追加します。
= [22] 追加した[[約束]]を返します。
]FIG]

;; [23] 返された[[約束]]は、[[バイト]]が送信された際に[[解決]]されます。

[24] [[バイト列]]を送信するとは、当該[[バイト列]]について先頭の[[バイト]]から順に[[バイト]]の送信の指示を行い、最後の[[バイト]]が返した[[約束]]を返す
(空バイト列なら[[解決]]済みの[[約束]]を返す) ことをいいます。

[31] 正常終了の送信の指示は、次のように処理します。
[FIG(steps)[
= [39] [VAR[送信閉じ済みフラグ]]が設定されていれば、[[例外]]を投げて停止します。
= [36] [VAR[送信閉じ済みフラグ]]を設定します。
= [35] [[接続]]の種類に応じた処理を行います。
]FIG]

[32] 中断の指示は、次のように処理します。
[FIG(steps)[
= [40] [VAR[送信閉じ済みフラグ]]と[VAR[受信閉じ済みフラグ]]の両方が設定されていれば、
[[例外]]を投げて停止します。
= [37] [VAR[送信閉じ済みフラグ]]を設定します。
= [38] [VAR[受信閉じ済みフラグ]]を設定します。
= [33] [VAR[送信待ちバッファー]]の先頭の項目から順に、
[[約束]]を[[拒絶]]していきます。
= [34] [[接続]]の種類に応じた処理を行います。
= [57] 中断の通知を行います。リセットフラグを設定します。
]FIG]

[90] [[credentials]] の送信の指示は、
接続の種類に応じた処理を実行します。そのようなものがなければ、
[[例外]]を投げます。
なお引数として、接続の種類に応じた [[credentials]] を受け取ります。

[4] [[接続]]の端点は、[[アプリケーション]]に対して次の通知を行います。
[FIG(list)[
- [5] [[バイト]]の受信の通知
[FIG(list members)[
:[[バイト]]:受信した[[バイト]]。 0-255 のいずれかの値。
:[[緊急データ]]フラグ: [[TCP]] [[緊急データ]]か否か。既定値は[[偽]]。
]FIG]
- [43] 正常終了の受信の通知
- [14] 中断の通知
[FIG(list members)[
:[[リセット]]フラグ:[[TCP]] [CODE[[[RST]]]] 相当のものであるか否か。既定値は[[偽]]。
]FIG]
- [60] 警告の通知
- [91] challenge の受信の通知
[FIG(list members)[
:接続:認証を行う接続の端点。
:[[challenge]]:プロトコル依存の [[challenge]] データ。
]FIG]
]FIG]

[25] [[接続]]の種類に依存した方法で次の[[バイト]]を送信可能であると判断したら、
次のようにします。
[FIG(steps)[
= [26] [VAR[送信待ちバッファー]]が空なら、ここで停止します。
= [27] [VAR[送信待ちバッファー]]の先頭の項目を取得し、バッファーからは削除します。
= [28] [[接続]]の種類に依存した方法で取得した項目の[[バイト]]を送信します。
(あれば) [[緊急データ]]フラグを引渡します。
= [29] 取得した項目の[[約束]]を[[解決]]します。
]FIG]

* TCP の場合

[58] [[接続]]の確立は、送受信者の [[IPアドレス]]と[[ポート番号]]を決定し
[[handshake]] を適切に行い、正常に完了することによります。
端点における[[フロー制御]]その他のオプションも適切に設定します。

[85] 確立の完了時に、相手の [[IPアドレス]]と[[ポート番号]]を[[アプリケーション]]に通知します。

[8] [[TCP]] の[[セグメント]]を受信したら、次のようにします。
[FIG(steps)[
= [54] [[TCP]] に従い処理し、不適切と判断すればここで停止します。
= [53] [CODE[[[RST]]]] フラグが設定されていれば、
== [44] [VAR[送信閉じ済みフラグ]]を設定します。
== [45] [VAR[受信閉じ済みフラグ]]を設定します。
== [47] 中断を通知します。リセットフラグを設定します。
= [49] データの各[[バイト]]について、順に、
== [48] [[バイト]]の受信を通知します。当該[[バイト]]の値を渡します。
[[緊急ポインター]]が本[[バイト]]を指していれば、[[緊急データ]]フラグも設定します。
= [50] [CODE[[[FIN]]]] フラグが設定されていれば、
== [52] [VAR[受信閉じ済みフラグ]]を設定します。
== [51] 正常終了の受信を通知します。
]FIG]

[9] [[タイムアウト]]その他の理由で[[接続]]が利用できないことを検知したら、
次のようにします。
[FIG(steps)[
= [46] [VAR[送信閉じ済みフラグ]]を設定します。
= [55] [VAR[受信閉じ済みフラグ]]を設定します。
= [56] 中断を通知します。
]FIG]

[30] [[バイト]]を送信できるかどうかは、[[フロー制御]]、[[輻輳制御]]その他の状況により決定します。

[10] [[バイト]]の送信は、次のようにします。
[FIG(steps)[
= [[緊急データ]]フラグが設定されていれば、
== 指定された[[バイト]]をデータとして含み、[[緊急ポインター]]が当該[[バイト]]を指す[[セグメント]]を送信することにします。
= それ以外なら、
== 指定された[[バイト]]をデータとして含む[[セグメント]]を送信することにします。
]FIG]

;; [11] 実際の送信時には、前後の[[バイト]]とまとめた[[セグメント]]で送信されたり、
必要に応じて[[再送]]されたりします。

[92] [[緊急データ]]に対応しています。

[12] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [42] [CODE[[[FIN]]]] フラグが設定された[[セグメント]]を送信することにします。
]FIG]

[13] 中断の指示があれば、次のようにします。
[FIG(steps)[
= [17] 必要に応じて [CODE[[[FIN]]]] フラグが設定された[[セグメント]]を送信することにします。
= [96] [[TCP]] で受信したデータの処理を以後行わないことにします。
]FIG]

* TLS の場合

[59] 接続の確立は、指定された[VAR[下位の[[接続]]]]において、 [[TLS handshake]]
を適切に行い、正常に完了することによります。

;; [61] [[警告]]を受信していれば、アプリケーションにその旨を通知します。

[89] 確立の完了時に、次の情報をアプリケーションに引渡します。
[FIG(list)[
- [[TLS]] の版
- 選択された [[cipher suite]] と引数
- ([VAR[種別]]が「サーバー」の場合) [[SNI]] ホスト名
- 選択された [[ALPN]] プロトコル
- 相手の[[証明書]]と[[中間証明書]] (あれば)
]FIG]

[73] [VAR[下位の接続]]からバイトを受信したら、[[バイト]]と[[緊急データ]]フラグを [[TLS]] に従い処理します。

[67] [[closure alert]] を受信したら、次のようにします。
[FIG(steps)[
= [68] 正常終了の受信を通知します。
]FIG]

[15] [[error alert]] を受信したら、次のようにします。
[FIG(steps)[
= [63] [[alert level]] が[[警告]]なら、
== [66] 警告を通知します。
= [65] それ以外なら、
== [106] [VAR[送信閉じ済みフラグ]]を設定します。
== [107] [VAR[受信閉じ済みフラグ]]を設定します。
== [64] 中断を通知します。リセットフラグを設定します。
]FIG]

[62] [VAR[下位の接続]]から正常終了を受信したら、次のようにします。
[FIG(steps)[
= [69] [VAR[受信閉じ済みフラグ]]が設定されていなければ、
== [70] [VAR[受信閉じ済みフラグ]]を設定します。
== [71] 正常終了の受信を通知します。
]FIG]

[72] [VAR[下位の接続]]から中断を受信したら、次のようにします。
[FIG(steps)[
= [74] [VAR[受信閉じ済みフラグ]]と[VAR[送信閉じ済みフラグ]]のどちらかが未設定なら、
== [108] [VAR[送信閉じ済みフラグ]]を設定します。
== [109] [VAR[受信閉じ済みフラグ]]を設定します。
== [75] 中断を通知します。
]FIG]

[76] バイトの送信は、 [[TLS]] に従い処理します。

[83] バイトを送信できるかどうかは、新たなバイトを入力として [[TLS]]
で処理できるかどうかとします。

[78] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [79] [[closure alert]] を送信します。
= [80] [VAR[下位の接続]]に正常終了の送信を指示します。
]FIG]

[81] 中断の指示があれば、[VAR[下位の接続]]に中断を指示します。

[77] [[TLS]] の処理によりバイト列を送信するべきときは、
[VAR[下位の接続]]で指定されたバイト列を送信します。

[84] [[TLS]] の最初の [[handshake]] 
または[[再折衝]]により[[クライアント証明書]]を要求された時は、
次のようにします。
[FIG(steps)[
= [86] challenge の受信を通知します。
[FIG(list members)[
:接続:この[[接続]]。
:challenge:(サーバーなら) [CODE(HTTP)@en[[[ClientHello]]]]
や (クライアントなら) [CODE(HTTP)@en[[[CertificateRequest]]]]
に含まれる情報のうち必要なもの。
]FIG]
]FIG]

[82] credentials の送信は、次のようにします。
[FIG(steps)[
= [87] [[TLS]] が [[credentials]] を受け付ける状態でなければ、例外を投げて停止します。
= [88] そうでなければ、与えられた [[credentials]] を [[TLS]] の処理に引渡します。
]FIG]

* HTTP/1 [CODE(HTTP)@en[CONNECT]] の場合

[120] 状態として、次のものを持ちます。
[FIG(list members)[
:[VAR[HTTP]]:[[HTTP接続]]の[[クライアント]]。[[HTTP接続の処理]]参照。
:[VAR[接続確立済みフラグ]]:初期値は未設定。
]FIG]

[97] 接続の確立は、[VAR[target]] について、次のようにします。
[FIG(steps)[
= [98] [VAR[種別]]が「クライアント」の場合、
== [121] [VAR[HTTP]] を、引数として受け取った[[HTTP接続]]の[[クライアント]]に設定します。
== [100] [VAR[HTTP]] に、[[要求]]を送信します。ただし[[クライアント]]が適切な状態になく[[要求]]を送信できないときは、
[[例外]]を投げて停止します。
[FIG(list members)[
: [F[method][request method]] : [CODE[CONNECT]]
: [F[request target]] : [VAR[target]]
: [F[header list]] :
[FIG(list members)[
: [CODE[Host]] : [VAR[target]]
: [CODE[Proxy-Connection]] : [CODE[keep-alive]]
: [CODE[User-Agent]] : [[default `[CODE[User-Agent]]` value]]
]FIG]
]FIG]
== [101] [VAR[HTTP]] からの通知を、次のように処理します。
=== [102] [[要求]]のヘッダー受信完了の通知の場合、
==-= [127] 応答の状態符号が [CODE(HTTP)[[[200]]]] なら、
==-== [130] [VAR[接続確立済みフラグ]]を設定します。
==-== [110] 接続が確立されたとします。
==-= [128] それ以外なら、
==-== [129] 接続の確立は失敗とします。
=== [104] [[要求]]のデータ受信の通知の場合、
==== [131] [VAR[接続確立済みフラグ]]が設定されていれば、
===-= [94] データの各バイトについて、順に、
===-== [95] バイトの受信を通知します。当該バイトの値を渡します。
=== [105] [[要求]]のデータ終了の通知の場合、
==== [132] [VAR[接続確立済みフラグ]]が設定されていれば、
===-= [117] [VAR[受信閉じ済みフラグ]]を設定します。
===-= [116] 正常終了の受信を通知します。
=== [103] [[要求]]の完了の通知の場合、
==-= [115] 終了の失敗フラグが設定されていれば、
==-== [111] [VAR[接続確立済みフラグ]]が設定されていれば、
==-=== [16] [VAR[送信閉じ済みフラグ]]を設定します。
==-=== [93] [VAR[受信閉じ済みフラグ]]を設定します。
==-=== [114] 中断を通知します。
==-== [113] それ以外なら、
==-=== [112] 接続の確立は失敗とします。
= [99] [VAR[種別]]が「サーバー」の場合、
==
@@
]FIG]

[118] バイトは常に送信可能とします。

[119] バイトの送信は、次のようにします。
[FIG(steps)[
= [122] [VAR[HTTP]] でトンネルに指定されたバイトを送信します。
]FIG]

[123] 正常終了の送信の指示があれば、次のようにします。
[FIG(steps)[
= [124] [VAR[HTTP]] に接続の正常終了を指示します。
]FIG]

[126] 中断の指示があれば、次のようにします。
[FIG(steps)[
= [125] [VAR[HTTP]] に中断を指示します。
]FIG]

* HTTP/2 [CODE[CONNECT]]

@@

* SOCKS4 の場合

[145] 接続の確立は、次のようにします。下位層の接続[VAR[接続]]、
宛先[[IPv4アドレス]][VAR[ホスト]]、宛先[[ポート]]番号[VAR[ポート]]を引数として受け取ります。
[FIG(steps)[
= [146] [VAR[種別]]が「クライアント」の場合、
== [148] [VAR[接続]]で 0x04 0x01 [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] [VAR[a[SUB[1]]]] [VAR[a[SUB[2]]]]
[VAR[a[SUB[3]]]] [VAR[a[SUB[4]]]] 0x00 を送信します。
==- [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] は[VAR[ポート]]を[[16ビット符号無し整数]]
([[ネットワークバイト順]]) としたものです。
==- [VAR[a[SUB[1]]]] [VAR[a[SUB[2]]]] [VAR[a[SUB[3]]]] [VAR[a[SUB[4]]]]
は[VAR[ホスト]]を[[32ビット符号無し整数]] ([[ネットワークバイト順]]) としたものです。
== [149] [VAR[接続]]から8バイト受信するのを最大30s待ちます。
== [150] 受信した最初の2バイトが 0x00 0x5A でなければ、
=== [151] [VAR[接続]]の中断を指示します。
=== [152] 接続の確立を失敗とします。ここで停止します。
== [153] 接続を確立できたとします。
= [147] [VAR[種別]]が「サーバー」の場合、
== 
@@
]FIG]

[154] 接続確立後は、指示は[VAR[接続]]への指示とし、
[VAR[接続]]からの通知があればそれを通知します。

* SOCKS5 の場合

[155] 接続の確立は、次のようにします。下位層の接続[VAR[接続]]、
宛先[[ドメイン名]] (長さ255[[以下]]の[[バイト列]]) または
[[IPv4アドレス]]または[[IPv6アドレス]][VAR[ホスト]]、
宛先[[ポート]]番号[VAR[ポート]]を引数として受け取ります。
[FIG(steps)[
= [156] [VAR[種別]]が「クライアント」の場合、
== [157] [VAR[接続]]で 0x05 0x01 0x00 を送信します。
== [158] [VAR[接続]]から2バイト受信するのを最大30s待ちます。
== [159] 受信したのが 0x05 0x00 でなければ、
=== [160] [VAR[接続]]の中断を指示します。
=== [161] 接続の確立を失敗とします。ここで停止します。
== [162] [VAR[接続]]で 0x05 0x01 0x00 [VAR[A]] [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]]
を送信します。
==- [VAR[A]] は、
==-= [VAR[ホスト]]が[[ドメイン名]]の場合、[VAR[ホスト]]の前に[VAR[ホスト]]のバイト数を[[8ビット符号無し整数]]としたものです。
==-= [VAR[ホスト]]が[[IPv4アドレス]]の場合、[VAR[ホスト]]を[[32ビット符号無し整数]] ([[ネットワークバイト順]]) としたものです。
==-= [VAR[ホスト]]が[[IPv6アドレス]]の場合、[VAR[ホスト]]を16バイトのバイト列としたものです。
==- [VAR[p[SUB[1]]]] [VAR[p[SUB[2]]]] は[VAR[ポート]]を[[16ビット符号無し整数]]
([[ネットワークバイト順]]) としたものです。
== [163] [VAR[接続]]から5バイト受信するのを最大30s待ちます。
== [164] 受信した最初の3バイトが 0x05 0x00 0x00 でないか、
第4バイトが 0x01, 0x03, 0x04 のいずれでもないか、
5バイトに満たなければ、
=== [165] [VAR[接続]]の中断を指示します。
=== [166] 接続の確立を失敗とします。ここで停止します。
== [167] 第4バイトが 0x01 なら、[VAR[接続]]から5バイト受信するのを最大30s待ちます。
== [168] 第4バイトが 0x03 なら、第5バイトを[[8ビット符号無し整数]]として解釈し、
[VAR[接続]]からそのバイト数 + 2 バイト分受信するのを最大30s待ちます。
== [169] 第4バイトが 0x04 なら、[VAR[接続]]から17バイト受信するのを最大30s待ちます。
== [170] 得られたのが指定のバイト数に満たなければ、
=== [171] [VAR[接続]]の中断を指示します。
=== [172] 接続の確立を失敗とします。ここで停止します。
== [173] 接続を確立できたとします。
= [174] [VAR[種別]]が「サーバー」の場合、
== 
@@
]FIG]

[175] 接続確立後は、指示は[VAR[接続]]への指示とし、
[VAR[接続]]からの通知があればそれを通知します。

* UNIX domain socket の場合

[133] 接続の確立は、次のようにします。
[FIG(steps)[
= [134] [VAR[種別]]が「クライアント」の場合、
== [136] [[ソケットAPI]]を使って新たに接続します。
[[アドレス族]]は [CODE[[[AF_UNIX]]]]、パス名は引数で指定された[[パス]]、
[[ソケット型]]は [CODE[[[SOCK_STREAM]]]] とします。
== [137] 接続に失敗すれば、確立は失敗とします。そうでなければ、確立できたとします。
= [135] [VAR[種別]]が「サーバー」の場合、
@@
]FIG]

[138] バイトが送信可能かどうかは、 [CODE[[[send]]]] によりバイト列を送信できるかどうかとします。

[139] バイトの送信は、 [CODE[[[send]]]] によります。

[140] 正常終了の送信の指示があれば、 [CODE[[[shutdown]]]] [CODE[[[SHUT_WR]]]] を実行します。

[141] 中断の指示があれば、 [CODE[[[shutdown]]]] [CODE[[[SHUT_RDWR]]]] を実行します。

[142] [CODE[[[recv]]]] によりバイト列を受信したら、
各バイトを順に、バイトの受信を通知します。

[143] [CODE[[[recv]]]] で何も受信しなくなれば、
[VAR[送信閉じ済みフラグ]]を設定し、正常終了の受信を通知します。

[144] [CODE[[[send]]]] や [CODE[[[recv]]]] でエラーが発生したら、
[VAR[送信閉じ済みフラグ]]と[VAR[受信閉じ済みフラグ]]を設定し、
中断を通知します。