[1] [[Web API]] ([[HTTP]] による [[API]]) の悪い設計例について。

* バージョニング (版付け)

[2] [[API]] にバージョンを設けるべきではありません。 [[API]] の拡張は、常に後方互換性を保った形で行うべきです。

[3] 従って [[URL]] や [[HTTPヘッダー]]などにバージョン番号を指定させるべきではありません。

[7] やむを得ず非互換変更せざるを得なくなった時は、非互換な機能のみ、
新しい[[エンドポイント]]を設けるべきです。はじめから非互換変更するつもりで準備しておくのは無駄ですし、
非互換変更するための言い訳を用意するようなもので、危険です。

[38] バージョンが複数あるということは、同じものを複数メンテナンスし続けなければならないということです。バグやセキュリティーホールのリスクも増えます。場合によっては、混用された時におかしなことにならないかも注意しなければなりません。

[39] 実際それはつらいので、いつか古いバージョンへの対応をやめようとします。しかし、古いバージョンで問題なく使えていたクライアントは、無駄な変更コストが発生しますし、それによって新たにバグが生じることもあります。面倒に思ったり、コスト上の理由などで、それを機に対応を取りやめるクライアントもあるかもしれません。旧バージョンのアクセスが減ったと思って廃止したら、アクセス頻度が低いクライアントが利用できなくなって困る、というのもありそうです。 [[API]] 提供者にとっても、クライアント開発者にとっても、クライアント利用者にとっても、嬉しいことは何一つありません。

;; [40] シェアを背景に [[API]] の非互換変更を頻繁に行う [[Facebook]] や [[Twitter]] は、雇用創出のための公共事業で仕様変更をやってるのではないかと揶揄されていますよ。

* 意味のない互換性

[41] 競合他サービスの [[API]] に似せた [[API]] を提供しようとして、失敗している例をたまに見かけます。

[42] 完全互換ならクライアント開発者のメリットも多いでしょうが、実際には細かな差異がたくさんあったり、他サービスの仕様変更に追随できなかったりして、似て非なるものになっているのが普通です。すると他サービス用のコードを思ったほど流用できなかったり、境界ケースで正しく扱えず不具合が生じたりしがちです。

[43] クライアント開発者の視点からすると、 (対象となるサービス自体のデータモデルが似ていることが前提で) 同じ操作が似たような手順で実行さえできればよく、そのエンドポイント名や引数名、応答のデータ構造などは (完全に一致しないなら) 合わせなくても良いように思えます。

[44] 業界標準仕様を確立できそうな場合は別です。

* 特殊な要求メソッド

[4] 実用上、 [CODE(HTTP)@en[[[GET]]]] と [CODE(HTTP)@en[[[POST]]]]
(と [CODE(HTTP)@en[[[OPTIONS]]]] と [CODE(HTTP)@en[[[HEAD]]]])
以外の[[要求メソッド]]を使うべきではありません。

[6] 意味的にもすべての操作をこの2つで十分明確に表現できます。

[79] [CODE(HTTP)@en[[[PUT]]]] や [CODE(HTTP)@en[[[DELETE]]]] を使うべきだというのは宗教的な主張なので、
普通は [CODE(HTTP)@en[[[POST]]]] で問題ありません。
最近は [CODE(HTTP)@en[[[PATCH]]]] 教も人気ですが、
流行に乗ればいいというものでもないでしょう。

[5] 特殊な[[要求メソッド]]に対応していない[[クライアント]]のための代替手段として
[CODE(HTTP)@en[[[X-HTTP-Method-Override:]]]] [[ヘッダー]]に[[要求メソッド]]を指定できるようにすることがありますが、
本末転倒です。正しい[[要求メソッド]]を使うべきです。

[32] [[安全]]で[[冪等]]な操作にしか [CODE(HTTP)@en[[[GET]]]] を使う(使える)べきではありません。
かつては [[JSONP]] のためやむを得ず [CODE(HTTP)@en[[[GET]]]] を使うことがありましたが、
今やただの[[セキュリティーホール]]です。

* 特殊な認証方式

[8] [[認証]]には [[HTTP]] [[基本認証]]か [[OAuth 2.0]] [CODE(HTTP)@en[[[Bearer]]]]
を使うべきです。いわゆる[[APIキー]]認証は [CODE(HTTP)@en[[[Bearer]]]]
で表現できます。 ([[OAuth 2.0]] の[[認可フロー]]を実装しなくても、
[CODE(HTTP)@en[[[Bearer]]]] だけ使えます。)

[31] [[キャッシュ]] ([[サーバー]]アプリケーションを構成する[[プロキシ]]、
または[[クライアント]]が使っている[[プロキシ]]のもの。) による問題を防ぐためには、
[[HTTP認証]]の仕組みに乗るべきです。その意味で [[query]] や独自
[[HTTPヘッダー]]に[[APIキー]]を指定する方法は、安全ではありません。

[80] 独自の[[署名]]を求める方式も、避けるべきです。歴史的には意味があったかもしれませんが、
今や [[HTTPS]] が基本ですから、本当に[[署名]]が必要な状況は稀です。
[[署名]]はデバッグが難しく、開発者を悩ませてきました。

* パスの濫用

[21] [[URL]] の [[path]] の濫用は慎むべきです。

[22] 例えば検索キーワードなどは [[URL query]] で指定するべきです。

[23] [[path]] に任意の文字列が指定可能な場合、 [[クライアント]]側の[[パーセント符号化]]漏れ、
[[Web API]] サーバー側の[[逆プロキシ]]や [[WAF]] の設定ミスによる[[パーセント符号化]]まわりの不具合などが起こりがちです。

[35] [[path]] に任意の [[URL]] を埋め込めるのは、特に避けるべきです。

* 動詞のパス

[34] よく [[path]] は[[名詞]]がよく、[[動詞]]は好ましくないと言われます。

[48] ただし整理上の都合で[[動詞]]を使った方が綺麗になるなら、無理に避けるものでもありません。
たとえば [CODE[https://host/document/124345]] の編集に関する操作は
[CODE[https://host/document/124345/edit]] への [CODE(HTTP)@en[[[POST]]]] に、
削除に関する操作は
[CODE[https://host/document/124345/delete]] への [CODE(HTTP)@en[[[POST]]]]
に実装しても何ら問題ないでしょう。

;; [CODE[https://host/document/124345/edit]] の [CODE(HTTP)@en[[[GET]]]] が編集ページ、
[CODE[https://host/document/124345/delete]] の [CODE(HTTP)@en[[[GET]]]]
が削除確認ページになっていると、ちょうど良い。

[65] [[動詞]]を避けることで直感的でなくなったり、複雑になったりするのでは本末転倒です。

[73] >>72 も参照。

* 何でもパスに入れたがる

[66] オプションを[[引数]] ([[URL query]] や[[要求本体]]の 
[CODE(MIME)@en[application/x-www-form-urlencoded]])
ではなく[[パス]]の一部に入れたがる人もいるようです。

[67] あまりどちらを使うべきか一概に言えるものでもないのですが、
次のような判断基準はたてられそうです。
[FIG(list)[
- [68] 省略可能なオプションなら、[[引数]]で指定させた方が良い。
- [69] 値が長くなりそうなオプションなら、 [[引数]]で指定させた方が良い。
- [70] 操作対象を指定する性質が強そうなオプションなら、[[パス]]に入れて良い。
- [71] いくつかのオプションがあって自明な順序がない 
(包含関係やユーザー○○の投稿××のような親子関係がない) なら、
[[引数]]で指定させた方が良い。
- [72] 動作の指示は[[引数]]で指定させた方が良い。
- [74] 記号を値に含むなら (特に、普段は含まないがたまに含む場合)、
[[引数]]で指定させた方が[[パーセント符号化]]を忘れるミスは防ぎやすい。
]FIG]

* 用語の一貫性

[81] [[API]] に登場する語 ([[path]] の一部分、[[引数]]の名前、
[[列挙型]]の[[引数]]の値、 [[JSON]] の[[オブジェクト]]に含まれる名前など)
は、一貫した命名規則に従うべきです。

[EG[
[82] 例えば、[[利用者]]のことを表すのに、 [CODE[user]]、[CODE[usr]]、[CODE[u]]、
[CODE[account]] のような似て非なる語・綴りを混在させるべきではありません。
]EG]

[83] 省略形よりも完全形の方がわかりやすくて良いとする人もいます。
しかしやたらと長い方が却ってわかりにくくなったり、面倒くさかったりもします。
省略するべきかどうかは適宜判断すればよく、語の長さよりも一貫性の方が重要でしょう。

* 状態符号

[11] [[状態符号]]は適切に選択するべきです。エラーなら [CODE(HTTP)[[[4xx]]]]
とするべきです。

;; 決め方に迷ったら [CODE(HTTP)[[[4xx]]]] 参照。

[47] エラーだろうがなんだろうが構わず [CODE(HTTP)[[[200]]]] を返すものは最悪です。
本文 [[JSON]] データでエラーを表している場合でも、適切な[[状態符号]]を使うべきです。

* 出力データ形式

** データ形式

[9] 出力データ形式は [[JSON]] を基本とするべきです。
ほとんどの[[プログラミング言語]]や[[フレームワーク]]で、
[[JSON]] は標準で実装されています。

[33] [[XML]] は追加ライブラリーが必要で面倒なクライアント環境やデータの扱いが面倒なライブラリー
[[API]] が多いので、極力避けるべきです。

[50] [[CBOR]] や [[MessagePack]] のような[[バイナリー]]ベースの形式を好む人もいます。
確かにサイズは抑えられ、 (実装次第ですが) [[JSON]] より高速に処理できるかもしれませんが、
ほとんどの場合は微々たる差で、より広く普及していてデバッグも容易な [[JSON]]
の方が適切です。少なくても不特定多数の開発者に公開された [[API]]
では、 [[JSON]] を基本とするべきです。

[12] [[JSONP]] は使うべきではありません。ただの[[セキュリティーホール]]です。
異なる[[起源]]の [[JavaScript]] からのアクセスが必要なら、 [[CORS]]
を使うべきです。

** データ形式の指定と内容折衝

[10] データ形式を選択制にするときは、[[URL query]] または[[拡張子]]で指定できるようにするべきです。
[CODE(HTTP)@en[[[Accept:]]]] による選択は使うべきではありません。
杜撰な[[キャッシュ]]の実装は [CODE(HTTP)@en[[[Accept:]]]] を正しく扱えません。
[[URL]] で指定できる方が[[デバッグ]]が容易です。
[[サーバー]]の[[アクセスログ]]に普通 [CODE(HTTP)@en[[[Accept:]]]]
は記録されないので、[[URL]] に含めた方が便利です。

[EG[
[49] [[Webブラウザー]]向けと [[Web API]] で同じ [[URL]]
を使い [CODE(HTTP)@en[[[Accept:]]]] によって[[内容折衝]]するような実装方法もありますが、
混乱を招くだけで誰も得しないので、避けるべきです。
]EG]

** エラー応答の形式

[36] クライアントが機械的に処理することを想定したエラー応答は、
[[JSON]] など (成功時と同じ) 機械可読な形式で提供するべきです。例えば投稿エンドポイントは、
投稿エラーなら、投稿エラーを説明した [[JSON]] 応答を返すべきです。

[37] しかしだからといって、無理にどんなエラーでも [[JSON]]
で返すようがんばる必要はないでしょう。例えばアプリケーションサーバーが過負荷で応答できないときの[[リバースプロキシ]]のエラーまで敢えて
[[JSON]] にしなくても構いません (しても構いませんが)。どうせクライアントは[[状態符号]]以上の有益な情報をその応答から得られません。
クライアントはどのみち [[JSON]] でない時のエラー処理を実装しておく必要がありますから、
実装の手間も変わりません。

* JSON データ構造

[45] [[JSON]] の場合、最上位は ([[配列]]や[[プリミティブ値]]ではなく)
[[オブジェクト]]とした方が無難です。何かのリストを返したい時も、
後から他の付加データを増やしたいときに[[配列]]だとどうしようもないので、
[[オブジェクト]]でくるんでおくと良いでしょう。

[46] [[識別子]]などで桁数の多い[[数字]]列を扱う時は、 [[JSON]]
の[[数値]]ではなく[[文字列]]で表すように注意するべきです。

;; [[JavaScript]] では構文解析時に32ビット整数に丸められてしまいます。

[51] [[HAL]] のような [[JSON]] ベースの言語を採用したり、
[[JSON Schema]] のような[[スキーマ]]に従って定義したりすることを好む人もいます。
そうしたものが有用な場面もあれば、あまり意味のない場面もありますから、
個別の用途に合わせて何を採用するか決めるべきです。「すべて○○を使うべき」
といった主張は眉唾物です。

* タイムスタンプ

[13] [[日時形式]]は、[[Unix time]] を基本とするべきです。
[[ISO 8601の日時形式]]や[[HTTPの日時形式]]、その他独自の形式は、
構文解析や生成処理や[[時間帯]]処理が面倒でミスを誘発しがちなので、避けるべきです。

* HTTP ヘッダーの濫用

[24] [[HTTPヘッダー]]の濫用は避けるべきです。

[25] [[クライアント]]による[[ページング]]の指定は、 [[URL query]] で行うのが伝統的な方法です。
それで何も問題ありません。

[26] [[サーバー]]による前後のページのリンクなどは、本文 [[JSON]] データに含めるべきです。
[CODE(HTTP)@en[[[Link:]]]] [[ヘッダー]]による指定は構文解析や生成処理が面倒でミスを誘発しがちなので、避けるべきです。
本文に含められない時は、 [[URL]] だけを値とする独自の [[HTTPヘッダー]]を使うのが次善策です。

* MIME 型引数

[78] [[MIME型]]の[[引数]] ([CODE[application/example; foo=bar]] の [CODE[foo=bar]]
のような部分) を使いたがる人がいるようです。一見便利に使えそうな場所ですし、
実際意味的に適切な場合もあるのですが、 [[MIME型]]の[[引数]]の取扱いは[[相互運用性]]に欠けるので、
あまりおすすめできません。

;; 実装によって、[[引数]]の存在に対応していない、大文字と小文字の扱いが不適切、
複数の[[引数]]の指定順序の違いが不適切、
同名の[[引数]]が複数あるときの扱いがわからない、
値の特殊文字や[[非ASCII文字]]の符号化の方法が混乱している、
といった色々な問題があります。

* ページング

[76] 「投稿一覧」や「コメント一覧」のような追加や削除が起こり得る対象の一覧を時刻順で取得する
[[API]] では、[[ページング]]にページ番号や先頭からの位置を取得するべきではありません。
最初のページと次のページの取得時点で位置が変化している可能性があるので、
項目の重複や欠落が発生する可能性があるからです。

[77] 「時刻 [VAR[t]] より前、後」のような指定形式が良さそうですが、
同時刻に複数の項目が存在するかもしれないケースでは、
取り扱いが難しくなるかもしれません。
[[マイクロ秒]]や[[ナノ秒]]の精度の時刻を使えば、そのようなケースはほとんど排除できそうです。
[[秒]]の精度では、重複はかなりの頻度で発生します。

* 人間向けサーバーと API サーバー

[57] 人間向けサーバーと [[Web API]] のサーバーをどのように共存させるかは、
[[アプリケーション]]の実装手法や[[サービス]]の規模と[[負荷分散]]の戦略によって、
いろいろな手法が考えられます。実際、いろいろな方法が用いられています。

[58] 例えば:
[FIG(list)[
- [59] [CODE[https://service/page]] ([[HTML]]) と [CODE[https://service/page.json]] (API)
のように[[拡張子]]で区別する
- [60] [CODE[https://service/api/page]] のように [[API]] を特定の[[ディレクトリー]]に収容する
- [61] [CODE[https://www.serivce.example/page]] と [CODE[https://api.service.example/page]]
のように[[ホスト]]で区別する
]FIG]

[62] 最初は小規模のサービスが大きくなった場合でも、 [[URL]] で区別できるなら、
[[リバースプロキシ]]で接続先[[アプリケーションサーバー]]を切り替えられますから、
[[負荷分散]]戦略によって [[URL]] の設計を過剰に制約する必要はありません。

* HTTPS

[29] 常に [[HTTPS]] を使うべきです。平文の [[HTTP]] が好ましい理由は何もありません。
歴史的な理由で未だに [[HTTP]] で [[Web API]] を提供するサービスも少なくありませんが、
それに倣うべきではありません。

;; [30] 両方を提供する理由もありません。ただの[[セキュリティーホール]]です。

* ドキュメント

[14] [[人間]]による明確なドキュメントを提供するべきです。

[15] 機械的に生成されただけのものは、ドキュメントとは言えません。
むしろドキュメントを整備した気になるだけなので有害です。

[EG[
[27] 例えば [[JSON Schema]] から機械的に生成した [[HTML]]
ファイル群は、ただの [[JSON Schema]] の[[書き下し文]]であって、
[[ドキュメント]]ではありません。
もしや有用な情報が含まれているのでは、と読者の期待を煽ってしまうだけなので、
むしろ有害です。
]EG]

[16] 入出力や処理内容など必要な情報を過不足なく記述するべきです。
エンドポイントごとに一言コメントを並べたようなものは、メモ書きであり、
ドキュメントではありません。

[17] また例示は例示であり、ドキュメントの本編ではありません。
例示をいくつ並べても、エンドポイントの説明とはいえません。

[EG[
[52] 有名な [[Webサービス]]の [[Web API]] であっても、
[[応答]]の [[JSON]] の実例を示しただけでまともな説明を加えていない「ドキュメント」
しか無いことがあります。
]EG]

[28] [[API]] によってアクセスされる対象であるオブジェクトの説明をがんばっているのに、
肝心の [[Web API]] の部分、つまり [[HTTP]] でどのような[[要求]]が必要で、
どのような[[応答]]が送られるのかの説明が雑なことがよくあります。
サービスのオブジェクトモデルの説明は、もちろん重要な情報ですが、
それだけでは [[Web API]] のドキュメントになりません。

[63] 一読して理解できないレイアウトは避けるべきです。 API ドキュメントは、
デザイナーやエンジニアの自己表現の場ではありません。

** 値域

[84] 可能な値の範囲は、できるだけ明確に文書化するべきです。その際は、
将来の拡張も視野に入れ、限定しすぎず、かといって一般化もしすぎず、
適当な粒度とするべきです。

[EG[
[85] 例えば、あるサービスの[[利用者]]の[[識別子]]を [[API]] でやり取りする場合、
おそらく[[クライアント]]もその識別子を何らかの形で保存しなければなりませんから、
[[ストレージ]]上の[[データ型]]を決めなければなりません。
識別子が[[数値]]なのか[[文字列]]なのか、含まれる文字の種類は何なのか、
最大の長さはどれだけなのか、といった情報が[[クライアント]]側開発者には有用です。

[86] ここで、[[サーバー]]側で識別子を32ビット整数型で表現しているとしても、
これをそのまま文書化することが望ましいとは限りません。将来の拡張の余地を残すため、
64ビットで表現可能な非負整数、と説明した方が良いかもしれません。

[87] 加えて、[[利用者]]の識別子は[[利用者]]によって互いに異なること、
決して他の[[利用者]]に再割当てされることがないこと、
といった性質も、説明しておくのが良さそうです。
一方で、識別子は小さい順に連番で割り当てられる、という情報は書かないべきでしょう
([[クライアント]]側で有用な情報ではなさそうですし、将来サーバー側で割当方法を変更したくなるかもしれません)。
]EG]

* 開発環境

[18] 提供されるサービスの性質次第ではありますが、[[クライアント]]の開発者が利用できる開発環境が提供されていると大変有用です。

[20] [[課金]]など重大な処理が伴うものや、通常のサービス利用では前提条件を構築するのが難しい処理などは、適当な開発環境が用意されているべきです。

[19] [[API]] の[[ホスト]]を書き換える程度の手間で本番環境と切り替えられるのが理想的です。

[53] 有料サービスや審査制のものなどでは、開発者が容易にアクセスできる開発を提供することはとても重要です。
本格的な開発 (や契約その他) の前の評価段階の予備的開発のため、
特別な審査や費用などがなくても利用できるようにするべきです。

* API の設計ガイドライン

[54] [[プログラミング言語]]や[[ライブラリー]]と同様に、 [[Web API]]
にもこう設計するのが良い、悪いというような[[指針]]や[[コーディング規約]]のようなものが色々とあります。

[55] そうした指針類は、設計に迷った時のヒントとして有用かもしれませんが、
あまり意識しすぎても、無駄な制約でかえって開発しづらくなったり、
設計を歪めたりする危険性があります。

[56] 宗教性の高い指針には、特に自分の信仰と親和性が高そうに思った場合を除き、
従わない方が無難です。

[FIG(list)[
- [64] [[パス]]などで[[単数形]]にするか、[[複数形]]にするか: 
どうでも良い。好きにすれば良い。その場その場で不自然でないようにすれば十分。
- [75] 「[[ベストプラクティス]]」などと称する指針は、
その[[著者]]の思想が色濃くにじみ出た「ベスト」であると思って注意して読むべき。
いつでもどこでも誰でも「ベスト」な方針が存在するのなら、既にみんなそれに従っているはずで、
そうでないからこそ「ベスト」とわざわざ主張しているのである。
]FIG]
