[1] [[Web API]] ([[HTTP]] による [[API]]) の悪い設計例について。

* バージョニング (版付け)

[2] [[API]] にバージョンを設けるべきではありません。 [[API]] の拡張は、常に後方互換性を保った形で行うべきです。

[3] 従って [[URL]] や [[HTTPヘッダー]]などにバージョン番号を指定させるべきではありません。

[7] やむを得ず非互換変更せざるを得なくなった時は、非互換な機能のみ、
新しい[[エンドポイント]]を設けるべきです。はじめから非互換変更するつもりで準備しておくのは無駄ですし、
非互換変更するための言い訳を用意するようなもので、危険です。

[38] バージョンが複数あるということは、同じものを複数メンテナンスし続けなければならないということです。バグやセキュリティーホールのリスクも増えます。場合によっては、混用された時におかしなことにならないかも注意しなければなりません。

[39] 実際それはつらいので、いつか古いバージョンへの対応をやめようとします。しかし、古いバージョンで問題なく使えていたクライアントは、無駄な変更コストが発生しますし、それによって新たにバグが生じることもあります。面倒に思ったり、コスト上の理由などで、それを機に対応を取りやめるクライアントもあるかもしれません。旧バージョンのアクセスが減ったと思って廃止したら、アクセス頻度が低いクライアントが利用できなくなって困る、というのもありそうです。 [[API]] 提供者にとっても、クライアント開発者にとっても、クライアント利用者にとっても、嬉しいことは何一つありません。

;; [40] シェアを背景に [[API]] の非互換変更を頻繁に行う [[Facebook]] や [[Twitter]] は、雇用創出のための公共事業で仕様変更をやってるのではないかと揶揄されていますよ。

* 特殊な要求メソッド

[4] 実用上、 [CODE(HTTP)@en[[[GET]]]] と [CODE(HTTP)@en[[[POST]]]]
(と [CODE(HTTP)@en[[[OPTIONS]]]] と [CODE(HTTP)@en[[[HEAD]]]])
以外の[[要求メソッド]]を使うべきではありません。

[6] 意味的にもすべての操作をこの2つで十分明確に表現できます。
[CODE(HTTP)@en[[[PUT]]]] や [CODE(HTTP)@en[[[DELETE]]]] を使うべきだというのは宗教的な主張なので、
普通は [CODE(HTTP)@en[[[POST]]]] で問題ありません。
最近は [CODE(HTTP)@en[[[PATCH]]]] 教も人気ですが、
流行に乗ればいいというものでもないでしょう。

[5] 特殊な[[要求メソッド]]に対応していない[[クライアント]]のための代替手段として
[CODE(HTTP)@en[[[X-HTTP-Method-Override:]]]] [[ヘッダー]]に[[要求メソッド]]を指定できるようにすることがありますが、
本末転倒です。正しい[[要求メソッド]]を使うべきです。

[32] [[安全]]で[[冪等]]な操作にしか [CODE(HTTP)@en[[[GET]]]] を使う(使える)べきではありません。
かつては [[JSONP]] のためやむを得ず [CODE(HTTP)@en[[[GET]]]] を使うことがありましたが、
今やただの[[セキュリティーホール]]です。

* 特殊な認証方式

[8] [[認証]]には [[HTTP]] [[基本認証]]か [[OAuth 2.0]] [CODE(HTTP)@en[[[Bearer]]]]
を使うべきです。いわゆる[[APIキー]]認証は [CODE(HTTP)@en[[[Bearer]]]]
で表現できます。 ([[OAuth 2.0]] の[[認可フロー]]を実装しなくても、
[CODE(HTTP)@en[[[Bearer]]]] だけ使えます。)

[31] [[キャッシュ]] ([[サーバー]]アプリケーションを構成する[[プロキシ]]、
または[[クライアント]]が使っている[[プロキシ]]のもの。) による問題を防ぐためには、
[[HTTP認証]]の仕組みに乗るべきです。その意味で [[query]] や独自
[[HTTPヘッダー]]に[[APIキー]]を指定する方法は、安全ではありません。

* パスの濫用

[21] [[URL]] の [[path]] の濫用は慎むべきです。

[22] 例えば検索キーワードなどは [[URL query]] で指定するべきです。

[23] [[path]] に任意の文字列が指定可能な場合、 [[クライアント]]側の[[パーセント符号化]]漏れ、
[[Web API]] サーバー側の[[逆プロキシ]]や [[WAF]] の設定ミスによる[[パーセント符号化]]まわりの不具合などが起こりがちです。

[35] [[path]] に任意の [[URL]] を埋め込めるのは、特に避けるべきです。

* 動詞のパス

[34] よく [[path]] は[[名詞]]がよく、[[動詞]]は好ましくないと言われます。
しかし整理上の都合で[[動詞]]を使った方が綺麗になるなら、無理に避けるものでもありません。
たとえば [CODE[https://host/document/124345]] の編集に関する操作は
[CODE[https://host/document/124345/edit]] への [CODE(HTTP)@en[[[POST]]]] に、
削除に関する操作は
[CODE[https://host/document/124345/delete]] への [CODE(HTTP)@en[[[POST]]]]
に実装しても何ら問題ないでしょう。

;; [CODE[https://host/document/124345/edit]] の [CODE(HTTP)@en[[[GET]]]] が編集ページ、
[CODE[https://host/document/124345/delete]] の [CODE(HTTP)@en[[[GET]]]]
が削除確認ページになっていると、ちょうど良い。

* 状態符号

[11] [[状態符号]]は適切に選択するべきです。エラーなら [CODE(HTTP)[[[4xx]]]]
とするべきです。

* 出力データ形式

[9] 出力データ形式は [[JSON]] を基本とするべきです。

[33] [[XML]] は追加ライブラリーが必要で面倒なクライアント環境やデータの扱いが面倒なライブラリー
[[API]] が多いので、極力避けるべきです。

[10] データ形式を選択制にするときは、[[URL query]] または[[拡張子]]で指定できるようにするべきです。
[CODE(HTTP)@en[[[Accept:]]]] による選択は使うべきではありません。
杜撰な[[キャッシュ]]の実装は [CODE(HTTP)@en[[[Accept:]]]] を正しく扱えません。
[[URL]] で指定できる方が[[デバッグ]]が容易です。
[[サーバー]]の[[アクセスログ]]に普通 [CODE(HTTP)@en[[[Accept:]]]]
は記録されないので、[[URL]] に含めた方が便利です。

[12] [[JSONP]] は使うべきではありません。ただの[[セキュリティーホール]]です。
異なる[[起源]]の [[JavaScript]] からのアクセスが必要なら、 [[CORS]]
を使うべきです。

[36] クライアントが機械的に処理することを想定したエラー応答は、
[[JSON]] など (成功時と同じ) 機械可読な形式で提供するべきです。例えば投稿エンドポイントは、
投稿エラーなら、投稿エラーを説明した [[JSON]] 応答を返すべきです。

[37] しかしだからといって、無理にどんなエラーでも [[JSON]]
で返すようがんばる必要はないでしょう。例えばアプリケーションサーバーが過負荷で応答できないときの[[リバースプロキシ]]のエラーまで敢えて
[[JSON]] にしなくても構いません (しても構いませんが)。どうせクライアントは[[状態符号]]以上の有益な情報をその応答から得られません。
クライアントはどのみち [[JSON]] でない時のエラー処理を実装しておく必要がありますから、
実装の手間も変わりません。

* タイムスタンプ

[13] [[日時形式]]は、[[Unix time]] を基本とするべきです。
[[ISO 8601の日時形式]]や[[HTTPの日時形式]]、その他独自の形式は、
構文解析や生成処理が面倒でミスを誘発しがちなので、避けるべきです。

* HTTP ヘッダーの濫用

[24] [[HTTPヘッダー]]の濫用は避けるべきです。

[25] [[クライアント]]による[[ページング]]の指定は、 [[URL query]] で行うのが伝統的な方法です。
それで何も問題ありません。

[26] [[サーバー]]による前後のページのリンクなどは、本文 [[JSON]] データに含めるべきです。
[CODE(HTTP)@en[[[Link:]]]] [[ヘッダー]]による指定は構文解析や生成処理が面倒でミスを誘発しがちなので、避けるべきです。
本文に含められない時は、 [[URL]] だけを値とする独自の [[HTTPヘッダー]]を使うのが次善策です。

* HTTPS

[29] 常に [[HTTPS]] を使うべきです。平文の [[HTTP]] が好ましい理由は何もありません。
歴史的な理由で未だに [[HTTP]] で [[Web API]] を提供するサービスも少なくありませんが、
それに倣うべきではありません。

;; [30] 両方を提供する理由もありません。ただの[[セキュリティーホール]]です。

* ドキュメント

[14] [[人間]]による明確なドキュメントを提供するべきです。

[15] 機械的に生成されただけのものは、ドキュメントとは言えません。
むしろドキュメントを整備した気になるだけなので有害です。

[EG[
[27] 例えば [[JSON Schema]] から機械的に生成した [[HTML]]
ファイル群は、 [[JSON Schema]] の[[書き下し文]]であって、
[[ドキュメント]]ではありません。
]EG]

[16] 入出力や処理内容など必要な情報を過不足なく記述するべきです。
エンドポイントごとに一言コメントを並べたようなものは、メモ書きであり、
ドキュメントではありません。

[17] また例示は例示であり、ドキュメントの本編ではありません。
例示をいくつ並べても、エンドポイントの説明とはいえません。

[28] [[API]] によってアクセスされる対象であるオブジェクトの説明をがんばっているのに、
肝心の [[Web API]] の部分、つまり [[HTTP]] でどのような[[要求]]が必要で、
どのような[[応答]]が送られるのかの説明が雑なことがよくあります。
サービスのオブジェクトモデルの説明は、もちろん重要な情報ですが、
それだけでは [[Web API]] のドキュメントになりません。

* 開発環境

[18] 提供されるサービスの性質次第ではありますが、[[クライアント]]の開発者が利用できる開発環境が提供されていると大変有用です。

[20] [[課金]]など重大な処理が伴うものや、通常のサービス利用では前提条件を構築するのが難しい処理などは、適当な開発環境が用意されているべきです。

[19] [[API]] の[[ホスト]]を書き換える程度の手間で本番環境と切り替えられるのが理想的です。