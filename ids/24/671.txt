[1] [[Web API]] ([[HTTP]] による [[API]]) の悪い設計例について。

* バージョニング (版付け)

[2] [[API]] にバージョンを設けるべきではありません。 [[API]] の拡張は、常に後方互換性を保った形で行うべきです。

[3] 従って [[URL]] や [[HTTPヘッダー]]などにバージョン番号を指定させるべきではありません。

[7] やむを得ず非互換変更せざるを得なくなった時は、非互換な機能のみ、
新しい[[エンドポイント]]を設けるべきです。はじめから非互換変更するつもりで準備しておくのは無駄ですし、
非互換変更するための言い訳を用意するようなもので、危険です。

[38] バージョンが複数あるということは、同じものを複数メンテナンスし続けなければならないということです。バグやセキュリティーホールのリスクも増えます。場合によっては、混用された時におかしなことにならないかも注意しなければなりません。

[39] 実際それはつらいので、いつか古いバージョンへの対応をやめようとします。しかし、古いバージョンで問題なく使えていたクライアントは、無駄な変更コストが発生しますし、それによって新たにバグが生じることもあります。面倒に思ったり、コスト上の理由などで、それを機に対応を取りやめるクライアントもあるかもしれません。旧バージョンのアクセスが減ったと思って廃止したら、アクセス頻度が低いクライアントが利用できなくなって困る、というのもありそうです。 [[API]] 提供者にとっても、クライアント開発者にとっても、クライアント利用者にとっても、嬉しいことは何一つありません。

;; [40] シェアを背景に [[API]] の非互換変更を頻繁に行う [[Facebook]] や [[Twitter]] は、雇用創出のための公共事業で仕様変更をやってるのではないかと揶揄されていますよ。

* 意味のない互換性

[41] 競合他サービスの [[API]] に似せた [[API]] を提供しようとして、失敗している例をたまに見かけます。

[42] 完全互換ならクライアント開発者のメリットも多いでしょうが、実際には細かな差異がたくさんあったり、他サービスの仕様変更に追随できなかったりして、似て非なるものになっているのが普通です。すると他サービス用のコードを思ったほど流用できなかったり、境界ケースで正しく扱えず不具合が生じたりしがちです。

[43] クライアント開発者の視点からすると、 (対象となるサービス自体のデータモデルが似ていることが前提で) 同じ操作が似たような手順で実行さえできればよく、そのエンドポイント名や引数名、応答のデータ構造などは (完全に一致しないなら) 合わせなくても良いように思えます。

[44] 業界標準仕様を確立できそうな場合は別です。

* 特殊な要求メソッド

[4] 実用上、 [CODE(HTTP)@en[[[GET]]]] と [CODE(HTTP)@en[[[POST]]]]
(と [CODE(HTTP)@en[[[OPTIONS]]]] と [CODE(HTTP)@en[[[HEAD]]]])
以外の[[要求メソッド]]を使うべきではありません。

[6] 意味的にもすべての操作をこの2つで十分明確に表現できます。
[CODE(HTTP)@en[[[PUT]]]] や [CODE(HTTP)@en[[[DELETE]]]] を使うべきだというのは宗教的な主張なので、
普通は [CODE(HTTP)@en[[[POST]]]] で問題ありません。
最近は [CODE(HTTP)@en[[[PATCH]]]] 教も人気ですが、
流行に乗ればいいというものでもないでしょう。

[5] 特殊な[[要求メソッド]]に対応していない[[クライアント]]のための代替手段として
[CODE(HTTP)@en[[[X-HTTP-Method-Override:]]]] [[ヘッダー]]に[[要求メソッド]]を指定できるようにすることがありますが、
本末転倒です。正しい[[要求メソッド]]を使うべきです。

[32] [[安全]]で[[冪等]]な操作にしか [CODE(HTTP)@en[[[GET]]]] を使う(使える)べきではありません。
かつては [[JSONP]] のためやむを得ず [CODE(HTTP)@en[[[GET]]]] を使うことがありましたが、
今やただの[[セキュリティーホール]]です。

* 特殊な認証方式

[8] [[認証]]には [[HTTP]] [[基本認証]]か [[OAuth 2.0]] [CODE(HTTP)@en[[[Bearer]]]]
を使うべきです。いわゆる[[APIキー]]認証は [CODE(HTTP)@en[[[Bearer]]]]
で表現できます。 ([[OAuth 2.0]] の[[認可フロー]]を実装しなくても、
[CODE(HTTP)@en[[[Bearer]]]] だけ使えます。)

[31] [[キャッシュ]] ([[サーバー]]アプリケーションを構成する[[プロキシ]]、
または[[クライアント]]が使っている[[プロキシ]]のもの。) による問題を防ぐためには、
[[HTTP認証]]の仕組みに乗るべきです。その意味で [[query]] や独自
[[HTTPヘッダー]]に[[APIキー]]を指定する方法は、安全ではありません。

* パスの濫用

[21] [[URL]] の [[path]] の濫用は慎むべきです。

[22] 例えば検索キーワードなどは [[URL query]] で指定するべきです。

[23] [[path]] に任意の文字列が指定可能な場合、 [[クライアント]]側の[[パーセント符号化]]漏れ、
[[Web API]] サーバー側の[[逆プロキシ]]や [[WAF]] の設定ミスによる[[パーセント符号化]]まわりの不具合などが起こりがちです。

[35] [[path]] に任意の [[URL]] を埋め込めるのは、特に避けるべきです。

* 動詞のパス

[34] よく [[path]] は[[名詞]]がよく、[[動詞]]は好ましくないと言われます。

[48] ただし整理上の都合で[[動詞]]を使った方が綺麗になるなら、無理に避けるものでもありません。
たとえば [CODE[https://host/document/124345]] の編集に関する操作は
[CODE[https://host/document/124345/edit]] への [CODE(HTTP)@en[[[POST]]]] に、
削除に関する操作は
[CODE[https://host/document/124345/delete]] への [CODE(HTTP)@en[[[POST]]]]
に実装しても何ら問題ないでしょう。

;; [CODE[https://host/document/124345/edit]] の [CODE(HTTP)@en[[[GET]]]] が編集ページ、
[CODE[https://host/document/124345/delete]] の [CODE(HTTP)@en[[[GET]]]]
が削除確認ページになっていると、ちょうど良い。

* 状態符号

[11] [[状態符号]]は適切に選択するべきです。エラーなら [CODE(HTTP)[[[4xx]]]]
とするべきです。

;; 決め方に迷ったら [CODE(HTTP)[[[4xx]]]] 参照。

[47] エラーだろうがなんだろうが構わず [CODE(HTTP)[[[200]]]] を返すものは最悪です。
本文 [[JSON]] データでエラーを表している場合でも、適切な[[状態符号]]を使うべきです。

* 出力データ形式

** データ形式

[9] 出力データ形式は [[JSON]] を基本とするべきです。
ほとんどの[[プログラミング言語]]や[[フレームワーク]]で、
[[JSON]] は標準で実装されています。

[33] [[XML]] は追加ライブラリーが必要で面倒なクライアント環境やデータの扱いが面倒なライブラリー
[[API]] が多いので、極力避けるべきです。

[50] [[CBOR]] や [[MessagePack]] のような[[バイナリー]]ベースの形式を好む人もいます。
確かにサイズは抑えられ、 (実装次第ですが) [[JSON]] より高速に処理できるかもしれませんが、
ほとんどの場合は微々たる差で、より広く普及していてデバッグも容易な [[JSON]]
の方が適切です。少なくても不特定多数の開発者に公開された [[API]]
では、 [[JSON]] を基本とするべきです。

[12] [[JSONP]] は使うべきではありません。ただの[[セキュリティーホール]]です。
異なる[[起源]]の [[JavaScript]] からのアクセスが必要なら、 [[CORS]]
を使うべきです。

** データ形式の指定と内容折衝

[10] データ形式を選択制にするときは、[[URL query]] または[[拡張子]]で指定できるようにするべきです。
[CODE(HTTP)@en[[[Accept:]]]] による選択は使うべきではありません。
杜撰な[[キャッシュ]]の実装は [CODE(HTTP)@en[[[Accept:]]]] を正しく扱えません。
[[URL]] で指定できる方が[[デバッグ]]が容易です。
[[サーバー]]の[[アクセスログ]]に普通 [CODE(HTTP)@en[[[Accept:]]]]
は記録されないので、[[URL]] に含めた方が便利です。

[EG[
[49] [[Webブラウザー]]向けと [[Web API]] で同じ [[URL]]
を使い [CODE(HTTP)@en[[[Accept:]]]] によって[[内容折衝]]するような実装方法もありますが、
混乱を招くだけで誰も得しないので、避けるべきです。
]EG]

** エラー応答の形式

[36] クライアントが機械的に処理することを想定したエラー応答は、
[[JSON]] など (成功時と同じ) 機械可読な形式で提供するべきです。例えば投稿エンドポイントは、
投稿エラーなら、投稿エラーを説明した [[JSON]] 応答を返すべきです。

[37] しかしだからといって、無理にどんなエラーでも [[JSON]]
で返すようがんばる必要はないでしょう。例えばアプリケーションサーバーが過負荷で応答できないときの[[リバースプロキシ]]のエラーまで敢えて
[[JSON]] にしなくても構いません (しても構いませんが)。どうせクライアントは[[状態符号]]以上の有益な情報をその応答から得られません。
クライアントはどのみち [[JSON]] でない時のエラー処理を実装しておく必要がありますから、
実装の手間も変わりません。

* JSON データ構造

[45] [[JSON]] の場合、最上位は ([[配列]]や[[プリミティブ値]]ではなく)
[[オブジェクト]]とした方が無難です。何かのリストを返したい時も、
後から他の付加データを増やしたいときに[[配列]]だとどうしようもないので、
[[オブジェクト]]でくるんでおくと良いでしょう。

[46] [[識別子]]などで桁数の多い[[数字]]列を扱う時は、 [[JSON]]
の[[数値]]ではなく[[文字列]]で表すように注意するべきです。

;; [[JavaScript]] では構文解析時に32ビット整数に丸められてしまいます。

[51] [[HAL]] のような [[JSON]] ベースの言語を採用したり、
[[JSON Schema]] のような[[スキーマ]]に従って定義したりすることを好む人もいます。
そうしたものが有用な場面もあれば、あまり意味のない場面もありますから、
個別の用途に合わせて何を採用するか決めるべきです。「すべて○○を使うべき」
といった主張は眉唾物です。

* タイムスタンプ

[13] [[日時形式]]は、[[Unix time]] を基本とするべきです。
[[ISO 8601の日時形式]]や[[HTTPの日時形式]]、その他独自の形式は、
構文解析や生成処理や[[時間帯]]処理が面倒でミスを誘発しがちなので、避けるべきです。

* HTTP ヘッダーの濫用

[24] [[HTTPヘッダー]]の濫用は避けるべきです。

[25] [[クライアント]]による[[ページング]]の指定は、 [[URL query]] で行うのが伝統的な方法です。
それで何も問題ありません。

[26] [[サーバー]]による前後のページのリンクなどは、本文 [[JSON]] データに含めるべきです。
[CODE(HTTP)@en[[[Link:]]]] [[ヘッダー]]による指定は構文解析や生成処理が面倒でミスを誘発しがちなので、避けるべきです。
本文に含められない時は、 [[URL]] だけを値とする独自の [[HTTPヘッダー]]を使うのが次善策です。

* HTTPS

[29] 常に [[HTTPS]] を使うべきです。平文の [[HTTP]] が好ましい理由は何もありません。
歴史的な理由で未だに [[HTTP]] で [[Web API]] を提供するサービスも少なくありませんが、
それに倣うべきではありません。

;; [30] 両方を提供する理由もありません。ただの[[セキュリティーホール]]です。

* ドキュメント

[14] [[人間]]による明確なドキュメントを提供するべきです。

[15] 機械的に生成されただけのものは、ドキュメントとは言えません。
むしろドキュメントを整備した気になるだけなので有害です。

[EG[
[27] 例えば [[JSON Schema]] から機械的に生成した [[HTML]]
ファイル群は、ただの [[JSON Schema]] の[[書き下し文]]であって、
[[ドキュメント]]ではありません。
もしや有用な情報が含まれているのでは、と読者の期待を煽ってしまうだけなので、
むしろ有害です。
]EG]

[16] 入出力や処理内容など必要な情報を過不足なく記述するべきです。
エンドポイントごとに一言コメントを並べたようなものは、メモ書きであり、
ドキュメントではありません。

[17] また例示は例示であり、ドキュメントの本編ではありません。
例示をいくつ並べても、エンドポイントの説明とはいえません。

[EG[
[52] 有名な [[Webサービス]]の [[Web API]] であっても、
[[応答]]の [[JSON]] の実例を示しただけでまともな説明を加えていない「ドキュメント」
しか無いことがあります。
]EG]

[28] [[API]] によってアクセスされる対象であるオブジェクトの説明をがんばっているのに、
肝心の [[Web API]] の部分、つまり [[HTTP]] でどのような[[要求]]が必要で、
どのような[[応答]]が送られるのかの説明が雑なことがよくあります。
サービスのオブジェクトモデルの説明は、もちろん重要な情報ですが、
それだけでは [[Web API]] のドキュメントになりません。

* 開発環境

[18] 提供されるサービスの性質次第ではありますが、[[クライアント]]の開発者が利用できる開発環境が提供されていると大変有用です。

[20] [[課金]]など重大な処理が伴うものや、通常のサービス利用では前提条件を構築するのが難しい処理などは、適当な開発環境が用意されているべきです。

[19] [[API]] の[[ホスト]]を書き換える程度の手間で本番環境と切り替えられるのが理想的です。

[53] 有料サービスや審査制のものなどでは、開発者が容易にアクセスできる開発を提供することはとても重要です。
本格的な開発 (や契約その他) の前の評価段階の予備的開発のため、
特別な審査や費用などがなくても利用できるようにするべきです。
