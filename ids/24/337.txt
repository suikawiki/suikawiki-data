* 仕様書

[REFS[
- [10] [CITE@en[RFC 6455 - The WebSocket Protocol]] ([TIME[2015-03-11 20:42:50 +09:00]] 版) <http://tools.ietf.org/html/rfc6455#section-5>
- [54] [CITE@en[RFC 6455 - The WebSocket Protocol]] ([TIME[2015-03-11 20:42:50 +09:00]] 版) <http://tools.ietf.org/html/rfc6455#section-6.2>
- [50] [CITE@en[RFC 6455 - The WebSocket Protocol]] ([TIME[2015-03-11 20:42:50 +09:00]] 版) <http://tools.ietf.org/html/rfc6455#section-10.4>
- [59] [CITE@en[RFC 6455 - The WebSocket Protocol]] ([TIME[2015-03-11 20:42:50 +09:00]] 版) <http://tools.ietf.org/html/rfc6455#section-10.7>
- [1] [CITE@en-GB-x-hixie[HTML Standard]] ([TIME[2015-05-06 10:42:35 +09:00]] 版) <https://html.spec.whatwg.org/#feedback-from-the-protocol>
]REFS]

* 処理

[6] [[WebSocket接続の確立]]により[[WebSocket接続]]の状態が [CODE[[[OPEN]]]]
になると、以後の受信データは次のように処理されることになります。

;; [5] [[WebSocket]] の規定に従わない[[クライアント]]は、 [[WebSocket handshake]]
における[[サーバー]]からの[[応答]]を待たずに[[フレーム]]
(や[[フレーム]]になっていないデータ) を送信するかもしれません。[[サーバー]]はそれに特別な対処を行う必要はありませんが、 >>60 を根拠に切断しても良いのかもしれません。

[53] 受信したデータは、次のように処理しなければ[['''なりません''']]。
[FIG(steps)[
= [9] [[WebSocketフレーム]]として構文解析します [SRC[>>54]]。
= [60] 不正なデータなら、[[TCP接続]]を切断して構いません。
次のようにする[['''べきです''']]。 [SRC[>>59]]
== [7] [[[CODE[Close]]フレーム]]を送信します。
== [8] [[WebSocket接続を閉じる]]処理を実行します。
== [15] 停止します。
= [14] 次の場合は、[[WebSocket接続失敗]]を実行し、停止します。 [SRC[>>10]]。
[FIG(list)[
- [16] [CODE[[[RSV1]]]] が非 [CODE[[[0]]]] 値であり、[[拡張]]のいずれの規定にも拠っていない場合
- [17] [CODE[[[RSV2]]]] が非 [CODE[[[0]]]] 値であり、[[拡張]]のいずれの規定にも拠っていない場合
- [11] [CODE[[[RSV3]]]] が非 [CODE[[[0]]]] 値であり、[[拡張]]のいずれの規定にも拠っていない場合
- [12] 未知の [CODE[[[opcode]]]] の場合
]FIG]
= [13] 自身が[[サーバー]]であり、[[フレーム]]が[[マスク]]されていないか、
自身が[[クライアント]]であり、[[フレーム]]が[[マスク]]されているなら、
== [19] [[[CODE[Close]]フレーム]]を[[状態符号]] [CODE(HTTP)[[[1002]]]] で送信して構いません
[SRC[>>10]]。
== [18] [[接続]]を閉じます [SRC[>>10]]。 ([[WebSocket接続を閉じる]]べきと思われます。)
= [58] 自身が[[サーバー]]なら、[[マスク]]を除去します [SRC[>>54]]。
= [55] [[制御フレーム]]なら、その規定により処理します [SRC[>>54]]。
= [56] [[データフレーム]]なら、
その [CODE[[[opcode]]]] を種別、[[応用データ]]をデータとする
[DFN[[RUBYB[WebSocketメッセージを受信]@en[A WebSocket Message Has Been Received]]]]したといいます。
ただし[[断片化]]されている場合には、以後の断片の[[応用データ]]もデータに連結してゆき、
最後の[[フレーム]]分まで連結した時をいいます。
[[拡張]]により別途規定がある場合は、それに拠ります。 [SRC[>>54]]
]FIG]

[52] 扱える[[フレーム]]のサイズや[[断片化]]を結合した[[メッセージ]]のサイズに上限がある実装は、
それを超えないよう自身を保護しなければ[['''なりません''']] [SRC[>>50]]。

[2] [[利用者エージェント]]は、[[WebSocketメッセージを受信]]したら、
次の[[タスク]]を[[タスクキュー]]に追加しなければ[['''なりません''']] [SRC[>>1]]。
[FIG(list members)[
[FIGCAPTION[
[[タスク]]
]FIGCAPTION]
:[[タスク源]]:[[WebSocketタスク源]]
:処理:
[FIG(steps)[
= [CODE(DOMa)@en[[[readyState]]]] が [CODE(DOM)[[[OPEN]]]] ([CODE[[[1]]]])
でなければ、停止します。
= [[イベント]]を作成します。
[FIG(list members short)[
[FIGCAPTION[
[[イベント]]
]FIGCAPTION]
:[[インターフェイス]]:[CODE(DOMi)@en[[[MessageEvent]]]]
:[[イベント型]]:[CODE(DOMe)@en[[[message]]]]
:[[trusted]]:[[真]]
:[[bubbles]]:[[偽]]
:[[取り消し可能]]:[[偽]]
:[[既定動作]]:なし
:[CODE(DOMa)@en[[[origin]]]]:[COCDE(DOMi)@en[[[WebSocket]]]] の [CODE(DOMa)@en[[[url]]]]
の[[URLの起源]]の[[Unicode直列化]]
]FIG]
= 受信したデータが[[テキスト]]なら、[[イベント]]の [CODE(DOMa)@en[[[data]]]] を、
受信したデータに設定します。
= 受信したデータが[[バイナリー]]なら、
== [CODE(DOMa)@en[[[binaryType]]]] が [CODE[[[blob]]]] なら、
[[イベント]]の [CODE(DOMa)@en[[[data]]]] を、生データが受信したデータである新しい
[CODE(DOMi)@en[[[Blob]]]] に設定します。
== [CODE(DOMa)@en[[[binaryType]]]] が [CODE[[[arraybuffer]]]] なら、
[[イベント]]の [CODE(DOMa)@en[[[data]]]] を、生データが受信したデータを内容として持つ新しい
[CODE(DOMi)@en[[[Blob]]]] に設定します。
= [[イベント]]を [CODE(DOMi)@en[[[WebSocket]]]] [[オブジェクト]]において[[dispatch]]します。
]FIG]
]FIG]

[3] [[利用者エージェント]]は、本[[タスク]]の実行の時に効率的に実行する条件が満たされていなければ、実行を遅延させて他の[[タスクキュー]]の[[タスク]]を実行することが[RUBYB[推奨]@en[encouraged]]されています。 [SRC[>>1]]

[EG[
[4] 例えば、受信したデータが[[ディスク]]にあり、[[タスク]]実行時点で
[CODE(DOMa)@en[[[binaryType]]]] が [CODE[[[arraybuffer]]]] になっていれば、
データを[[メモリー]]に読み込む処理を実行し、その完了まで他の[[タスク]]を実行していることができます。 [SRC[>>1]]
]EG]