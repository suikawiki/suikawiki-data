[12] [[OAuth 1.0]] で[[署名]]を計算する方式を[DFN[[RUBYB[署名方式]@en[signature method]]]]といいます。
[[クライアント]]は選択した[[署名方式]]を [DFN[[CODE(URI)@en[[[oauth_signature_method]]]]]]
[[引数]]に、計算した[[署名]]を [DFN[[CODE(URI)@en[[[oauth_signature]]]]]]
[[引数]]に指定することになっています。[[鯖]]は[[署名]]を確認し、
正当な[[クライアント]]からの[[認証された要求]]であるかを調べることになっています。

* 仕様書

[REFS[
- [1] [CITE@en[RFC 5849 - The OAuth 1.0 Protocol]] ([TIME[2014-12-28 14:19:21 +09:00]] 版) <http://tools.ietf.org/html/rfc5849#section-3.1>
- [5] [CITE@en[RFC 5849 - The OAuth 1.0 Protocol]] ([TIME[2014-12-28 14:19:21 +09:00]] 版) <http://tools.ietf.org/html/rfc5849#section-3.2>
- [7] '''[CITE@en[RFC 5849 - The OAuth 1.0 Protocol]] ([TIME[2014-12-28 14:19:21 +09:00]] 版) <http://tools.ietf.org/html/rfc5849#section-3.4>'''
]REFS]

* 署名

[8] [[認証された要求]]には2組の[[credentials]]が含まれますが、
[[鯖]]が[[認証]]を[[検証]]して[[認可]]されていないアクセスを防ぐために、
[[クライアント]]は自身が [[credentials]] の正当な所有者であることを示す必要があります。
このために [[credentials]] の[[共有秘密]]または [[RSA鍵]]を使って[[署名]]します。 [SRC[>>7]]

* 署名方式

[9] [RUBYB[署名方式]@en[signature method]]には次のものがあります。
[FIG(short list)[
- [CODE(HTTP)@en[[[HMAC-SHA1]]]]
- [CODE(HTTP)@en[[[RSA-SHA1]]]]
- [CODE(HTTP)@en[[[PLAINTEXT]]]]
]FIG]

[10] [[OAuth]] 仕様としてはどの[[署名方式]]も必須とはなっていません [SRC[>>7]]。

;; [13] [CODE(HTTP)@en[[[HMAC-SHA1]]]] を使うことが多く、それ以外を使うことはあまりないようです。

[11] [[鯖]]は独自の[[署名方式]]を使うことができます [SRC[>>7]]。

* [CODE(URI)@en[oauth_signature]] 引数

[3] [[認証された要求]]の [DFN[[CODE(URI)@en[[[oauth_signature]]]]]]
[[引数]]は、[[署名]]の計算結果の値を表します。

* [CODE(URI)@en[oauth_signature_method]] 引数

[2] [[認証された要求]]の [DFN[[CODE(URI)@en[[[oauth_signature_method]]]]]] [[引数]]は、
[[クライアント]]が使用する[[署名方法]]を表します。

[4] この値が [CODE(HTTP)@en[[[PLAINTEXT]]]] であるか否かにより、
[CODE(HTTP)@en[[[oauth_timestamp]]]], [CODE(HTTP)@en[[[oauth_nonce]]]]
が必要か否かが変わります。

* 処理

[6] [[認証された要求]]も参照。

* メモ

[14] [[署名]]は [[OAuth 1.0]] の中で最も複雑で実装しづらく、嫌われていました。
[[OAuth 2.0]] では [[TLS]] を必須とすることで[[署名]]を除去しています。

[15] [[署名]]は技術的にはそれほど難解ではなく、特に[[署名アルゴリズム]]の実装を既存のライブラリーに委ねている場合には、
[[クライアント]]や[[鯖]]が自前で行わなければならない処理はほとんどありません。
それでも実装しづらいのは、何重にも[[符号化]]を重ねていること、
その[[パーセント符号化]]にバリエーションが多く誤った選択をしても気づきにくいこと、
[[署名]]対象となる [[HTTP要求]]の各構成部分 ([[URL]] の各部や[[引数]])
の扱いが既存のライブラリーや [[WAF]] 等で様々で、それぞれが独自の[[符号化]]や変換、
独自データ構造での保持などを行っていて実際に送信される値を取得するのが難しかったり、
不可能だったりすることなど、様々な罠があります。

;; [16] 例えば[[鯖]]は [[WAF]] によって[[復号]]された[[対象URL]]ではなく、
[[要求対象]]として指定された[[パーセント符号化]]を保持した[[URL]]が必要です。

;; [18] 例えば[[逆串]]の裏側で動作する[[鯖]]は、[[クライアント]]が指定した元の
[CODE(HTTP)@en[[[Host:]]]] [[ヘッダー]]の値にアクセスできる必要があります。

;; [17] 例えば[[クライアント]]は入力として与えられた[[対象URL]]
に [[query]] が含まれていれば、正しく[[復号]]して再度[[符号化]]して[[署名]]対象としなければなりません。

[19] [[署名]]は[[要求引数]]を必要としており、[[要求URL]] の一部である [[URL query]] や
[CODE(MIME)@en[[[application/x-www-form-urlencoded]]]] [[payload body]]
の生成とも関係しています。そのため、狭義の [[HTTP要求]]の生成処理と [[OAuth 1.0]]
の処理を完全に分離することが難しく、 [[HTTP]] 処理ライブラリーのモジュール化設計に悪い影響を与えています。
これも [[OAuth 1.0]]、とりわけその[[署名]]が嫌われる一因となります。
