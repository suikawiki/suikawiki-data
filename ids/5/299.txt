
[1] [DFN[[[RFC 2234]]]] の [DFN[[[ABNF]]]] (増補 BNF)
は、非常によく用いられていた [[RFC 822]]
の ABNF を整理・拡張して独立な仕様としたものです。
RFC 2234 は [[IETF]] の[[提案標準]]となっており、
新しい IETF の規格を中心によく利用されています。

[2] 仕様書:
- [[RFC 2234]]
<urn:ietf:rfc:2234>

[12]
改訂版の [[RFC 4234]] が発行されました。
([[名無しさん]] [WEAK[2005-10-16 05:55:41 +00:00]])


[18]
[[RFC 4234]] は更に改訂され、 [[RFC 5234]] ([[インターネット標準]] [[STD 68]])
となりました。(差異については [[RFC 5234]] の項を参照。)
([[名無しさん]])


[[#comment]]


* 変種

[5] RFC 2234 では[[二重引用符]]で括った[[引用文字列]]は大文字・
小文字を区別しないと定義していますが、その解釈を変えて、
大文字・小文字は区別するとしている仕様書もあります。

- [[RFC 3862]] ([[CPIM]])
- [[RFC 5147]] ([[[CODE(MIME)@en[text/plain]]の素片識別子]])

[6] [[P3P]] で使われている ABNF は RFC 2234 の ABNF の変種です。
詳しくは [[P3PのABNF]] の項を参照してください。

[10] [[RFC 3080]] [SRC[>>17]] と [[RFC 3391]] では [SAMP(ABNF)[0..2147483647]]
のように、整数の範囲指定が使われています。

[16] ちなみに、 RFC 3391 は [[MIME]] 式の ABNF も使っています。

[9]
[[RFC 3981]] など [[IRIS]] RFC では
[PRE(ABNF example)[
unreserved         = // as specified by RFC2396
]PRE]
... のように他の規格で定義されていることを表す表現が
[WEAK[(undocumented で)]] 使われています。

[21] [[RFC 3080]] では
[PRE(ABNF example)[
   mapping    = ;; each transport mapping may define additional frames
]PRE]
... のような表記も使われています [SRC[>>17]]。

;; [14] 変種については [[ABNF]] の項も参照してください。

[REFS[
- [17] [CITE@en[RFC 3080 - The Blocks Extensible Exchange Protocol Core]] ([TIME[2014-08-17 14:28:11 +09:00]] 版) <http://tools.ietf.org/html/rfc3080#section-2.2.1>
]REFS]

[25] [[媒体素片]]の仕様書 [SRC[>>24]] は [[ABNF]] のような方法で構文を記述していますが、
それが何であるのかは明記していません。ただ [[RFC 3986]] を参照しており、
[[IETF]] の [[ABNF]] との類似性を感じさせます。

>
[PRE(ABNF code)[
name = fragment - "&" - "="
]PRE]

... のような構文により使用できない[[文字]]を記述しているようです (が説明がありません)。
[CODE[-]] の左辺は[[文字列]]で、右辺が[[文字]]であることにも注意が必要です。
(右辺の[[文字列]]が認められないのではなく、右辺の[[文字]]を含む文字列が認められないと解釈するのが自然でしょう。)

[REFS[
- [24] [CITE@en-us[Media Fragments URI 1.0 (basic)]] ([TIME[2012-09-27 23:08:40 +09:00]] 版) <http://www.w3.org/TR/media-frags/#general-structure>
]REFS]

* 意味的な変種

[3] RFC 2234 では ABNF によって定義されるものが
([CODE(charset)[[[US-ASCII]]]] を用いた) 
[[オクテット列]]または[[ビット列]]としています。
しかし、[[符号化文字集合]]とは独立に[[文字列]]だけを定義したい場合や、
符号化文字集合が [[ASCII]] 以外である場合にも ABNF
を使いたいという要求があります。そのため、 RFC 2234
を参照しながらもこの辺の解釈を変えている仕様書も少なからずあります。

[4] [[RFC 3986]] ([[URI]] 4[SUP[th]]) は、
[[URI]] は符号化からは独立した文字列として定義されるとしています。
RFC 3986 における ABNF は、それによって定義されるオクテット列 
[WEAK[(の集合)]] に ASCII で対応する文字列 [WEAK[(の集合)]]
であるとしています。

[8] 同様に [[RFC 3987]] ([[IRI]]) は ABNF
の終端を [[UCS]] としています。

[6] [[RFC 3676]] ([CODE(MIME)[[[text/plain]]; [[format]]=[[flowed]]]])
は [CODE(MIME)[[[charset]]]] 引数によって実際の[[オクテット列]]は変わってくることを指摘しています
[WEAK[(が不完全です)]]。

[20] [[HTML5]] は「[[文字集合]]は [[Unicode]]」としつつ [[ABNF]] を利用しています。

;; [CITE@en-US-x-hixie[HTML 5]] ([TIME[2009-08-01 09:07:43 +09:00]] 版) <http://www.whatwg.org/specs/web-apps/current-work/#inline-documentation-for-external-scripts>

[7] この他、元の仕様が厳密に意味的に RFC 2234 に従って
US-ASCII のオクテット列として定義していても、
それを引用している仕様がそうでなかったりすることもあります。
例えば [[RFC 3066]] の[[言語札]]の構文は RFC 2234 の ABNF
で記述されていますが、言語札を採用している仕様がすべて
US-ASCII のオクテット列による表現を使っているわけではありません。
ほとんどの場合、そのような違いは読めばわかるからか明確に規定されていることはありません。

[15]
[[RFC 4646]] ([[言語札]]) は [[RFC 4234]] を参照していますが、
終端は[[オクテット]]ではなく、[[文字]]だとしています。

[22] 古くからの慣習で、[[空白]] ([[LWSP]] や [[FWS]] など)
の挿入を省略しているものもあります。そのような仕様の中には、
どこに[[空白]]が挿入されるのかを明記していないものも少なくありません。

;; [23] 例えば [[RFC 6690]] は[[空白]]を構文に明記していません。

* メモ

[11] RFC 2234 ABNF を使う場合で、終端として文字列表記
(引用文字列) を使う時は、大文字・小文字の区別の有無を
[WEAK[(区別ありであれ、なしであれ)]] 明記しておいた方が安全です。

[13]
[[RFC 3986]] では[[空文字列]]たることを明示するために
[CODE(ABNF example)@en[0<pchar>]] のような表現を使っています。

* 詐称

[19] [[W3C]] の仕様書の中には [[RFC 2234のABNF]] であるとしながらも実際には [[XMLのEBNF]]
を採用していることがあります。 [[XMLのEBNF]] や [[LEIRIのABNF]] の項をご覧ください。