* 仕様書

[REFS[
- [5] '''[CITE@en[RFC 1951 - DEFLATE Compressed Data Format Specification version 1.3]] ([TIME[2016-01-10 18:30:17 +09:00]] 版) <https://tools.ietf.org/html/rfc1951>'''
-- [7] [CITE@en[RFC 1951 - DEFLATE Compressed Data Format Specification version 1.3]] ([TIME[2016-01-10 18:30:17 +09:00]] 版) <https://tools.ietf.org/html/rfc1951#section-1>
-- [25] [CITE@en[RFC 1951 - DEFLATE Compressed Data Format Specification version 1.3]] ([TIME[2016-07-03 09:57:20 +09:00]]) <https://tools.ietf.org/html/rfc1951#section-2>
-- [26] [CITE@en[RFC 1951 - DEFLATE Compressed Data Format Specification version 1.3]] ([TIME[2016-07-03 09:57:20 +09:00]]) <https://tools.ietf.org/html/rfc1951#section-3>
]REFS]

* アルゴリズム

[12] [RUBYB[入力データ]@en[input data]]は、[RUBYB[ブロック]@en[block]]の連なりとします。 
[[ブロック]]の大きさは任意に決められますが、 
[N[65535]] [[バイト]][[以下]]でなければなりません。[SRC[>>25]]

[14] [RUBYB[圧縮データ集合]@en[compressed data set]]は、
[RUBYB[ブロック]@en[block]]の[[系列]]です。この[[ブロック]]は、
入力データの各[[ブロック]]に対応します。 [SRC[>>25]]

[15] 各[[ブロック]]は、 [[LZ77]] [[アルゴリズム]]と[[ハフマン符号化]]の組み合わせにより、
[[圧縮]]します。 [SRC[>>25]]

[18] [[ブロック]]は、[[圧縮]]されたデータ部分の表現を説明する[[ハフマン符号木]]と、
[RUBYB[圧縮されたデータ部分]@en[compressed data part]]との2つの部分の組です。 [SRC[>>25]]

[20] 圧縮されたデータ部分は、要素の系列です。各要素は、
[RUBYB[リテラルバイト群]@en[literal bytes]]か、
[RUBYB[重複列への指示子]@en[pointer to duplicated strings]]かのいずれかです。 [SRC[>>25]]

[21] 指示子は、[RUBYB[長さ]@en[length]]と、[RUBYB[前方向の距離]@en[backward distance]]との組で表されます。 [SRC[>>25]]

[17] 距離は、 32KB [[以下]]です。すなわち、指示子は、入力データの 32KB 前までの[[ブロック]]の[RUBYB[列]@en[string]]を参照できます。 [SRC[>>25]]

[22] 長さは、 258 バイト[[以下]]です。 [SRC[>>25]]

[23] リテラルと長さは、[[ハフマン符号木]]を使って[[ハフマン符号]]で表します。 [SRC[>>25]]

[24] 距離は、別の[[ハフマン符号木]]を使って[[ハフマン符号]]で表します。 [SRC[>>25]]

[19] [[ハフマン木]]自体も、[[ハフマン符号化]]により圧縮します。 [SRC[>>25]]

[16] 各[[ブロック]]の[[ハフマン木]]は、互いに独立です。 [SRC[>>25]]

** ビット列の表現

[27] [[DEFLATE]] の出力は[[バイト列]]です。
[[バイト]]内の[[ビット順]]は規定されておらず [SRC[>>26]]、
[[プラットフォーム]]や[[プロトコル]]に依存します。

[29] [[多バイト]]の値は、重みの小さな[[バイト]]から順に並べた[[バイト列]]とします
[SRC[>>26]]。つまり[[小エンディアン]]で表現します。

[28] [RUBYB[データ要素]@en[data element]]を[[バイト列]]にする際には、
[[バイト]]の重みの小さな[[ビット]] ([[LSB]]) から順に詰めていきます。 [SRC[>>26]]

[30] [[ハフマン符号]]''以外''のデータ要素は、
当該データ要素の LSB から順に詰めていきます。 [SRC[>>26]]

[31] [[ハフマン符号]]は、重みの大きな[[ビット]] ([[MSB]])
から順に詰めていきます。 [SRC[>>26]]

** ハフマン符号化

[32] [RUBYB[接頭辞符号化]@en[prefix coding]]は、
事前に与えられた[RUBYB[字母]@en[alphabet]]の[RUBYB[記号]@en[symbol]]を、
ビット列 (符号) として表現するものです。ここで、ビット列は記号ごとに長さが異なりますが、
構文解析器が常に曖昧無く記号を認識できるようにします。 [SRC[>>26]]

[33] 接頭辞符号は、[[二分木]]を使って定義します。
[[枝]]が [N[0]] または [N[1]] のいずれかを表すこととします。
[[枝]]がいずれかの[[記号]]を表すこととします。
[[根]]から[[葉]]までの[[枝]]の値を順番に並べたものが、[[符号]]を表します。 [SRC[>>26]]

[35] 構文解析器は、[[二分木]]の[[根]]から順に入力の[[ビット]]に従い進むことで、
記号を得ることができます。 [SRC[>>26]]

[EG[
[34] 次の[[木]]は、次の表のような[[符号]]を表しています。 [SRC[>>26]]
[PRE[
                          /\         
                         0  1        
                        /    \       
                       /\     B      
                      0  1           
                     /    \          
                    A     /\
                         0  1
                        /    \
                       D      C
]PRE]

,* 記号  ,* 符号
, A      , [CODE[00]]
, B      , [CODE[1]]
, C      , [CODE[011]]
, D      , [CODE[010]]
]EG]

[36] [[ハフマン算法]]により、[[字母]]とその[[頻度]]から最適な接頭辞符号を得られます。
頻度が高いほど身近な[[符号]]となります。これを[[ハフマン符号]]といいます。 [SRC[>>26]]

;; [37] ただし [[DEFLATE]] では[[符号]]長の上限があるので、少し複雑になります。 [SRC[>>26]]


* 文脈

[1] [[DEFLATE]] は次の場面で用いられています。
[FIG(short list)[
- [[zlib]]
- [[gzip]]
- [[ZIP]]
- [[LHA]]
]FIG]

* 適合性

[8] [[圧縮器]]は、[[仕様]]にすべて従うデータ集合を生成しなければなりません [SRC[>>7]]。

[6] [RUBYB[[[展開器]]]@en[decompressor]]は、
特に定める場合を除き、
[[仕様]]に[[適合]]する任意のデータ集合を[[受理]]し[RUBYB[[[展開]]]@en[decompress]]できなければなりません。 [SRC[>>7]]

* 関連

[3] [[HTTP]] の[[内容符号化]] [CODE(HTTP)@en[[[deflate]]]]
については、 [[zlib]] を参照。

* 歴史

[9] [[DEFLATE]] は [DFN[[[RFC 1591]]]] によって定義されています。

[10] [[RFC 1591]] は第1.3版となっていますが、第1.1版から技術的内容は変わっていません [SRC[>>7]]。

;; [11] 第1.0版には言及がなく、存在したのか不明です。

[2] [CITE@en[RFC 6713 - The 'application/zlib' and 'application/gzip' Media Types]]
([TIME[2015-09-27 13:20:11 +09:00]] 版)
<https://tools.ietf.org/html/rfc6713>

[FIG(quote)[
[FIGCAPTION[
[4] [CITE[zlib 入門]]
([TIME[2007-02-14 08:49:05 +09:00]] 版)
<https://oku.edu.mie-u.ac.jp/~okumura/compression/zlib.html>
]FIGCAPTION]

> zlib の圧縮アルゴリズムは PKZIP 2.x の deflate アルゴリズムで, もともとは私と吉崎栄泰さんが LHA のために開発したものをハッシュで高速化したものです(zlib のソースコード中に,ほんのちょっとですが私の名前が入っています)。 その後,LHA もハッシュを使うようになりましたので,LHA と gzip/zlib/Zip の実質的な相違はなくなりました。

]FIG]

[13] [CITE@en-US[Efficient XML Interchange (EXI) Format 1.0]]
( ([TIME[2011-03-10 23:00:15 +09:00]] 版))
<http://www.w3.org/TR/2011/REC-exi-20110310/#CompressedStreams>