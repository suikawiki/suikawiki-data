* 仕様書

[REFS[
- [6] [CITE@en[RFC 8188 - Encrypted Content-Encoding for HTTP]], [TIME[2020-03-09 11:21:54 +09:00]] <https://tools.ietf.org/html/rfc8188>
- [7] [CITE[RFC Errata Report » RFC Editor]], [TIME[2020-03-12 17:34:59 +09:00]] <https://www.rfc-editor.org/errata_search.php?rfc=8188>
]REFS]

* 意味

[9] 
[[HTTPメッセージ]] ([[HTTP要求]]、
[[HTTP応答]])
の内容を暗号化し、適切な鍵を持つ者のみが閲覧可能とし、
[[サーバー]]すらその内容を閲覧できなくしたいことがあります。
[SRC[>>6 1.]]

;; [10] [[HTTP]] の[[暗号化]]といえば [[TLS]]
があります。 [[TLS]] は[[サーバー]]と[[クライアント]]の間の[[通信路]]を[[暗号化]]するもので、
性質が異なります。
本手法では、[[サーバー]]すらデータを読むことができないべきかもしれませんし、
読めないデータを他の[[サーバー]]に複製して配置したりすることもあって、
1対の [[HTTPサーバー]]と [[HTTPクライアント]]の間の通信で完結しないかもしれません。
[SRC[>>6 1.]]

* プロトコル


** 内容符号化 [CODE[aes128gcm]]

[12] 
[[内容符号化]] [DFN[[CODE[aes128gcm]]]]
が定義されています。
[SRC[>>6 2.]]

[13] 
[CODE[aes128gcm]]
は、
[[payload]]
が
[[RFC 5116]] 5.1 節
[CODE[AEAD_AES_128_GCM]]
([[AES]] [[GCM]]、128ビット内容暗号化キー利用)
で[[暗号化]]されているものです。
[SRC[>>6 2.]]

;; [15] 
[[暗号化]]の [[primitive]] はこの通り固定化されています。
他の手法への対応 ([[cipher agility]])
は、別の[[内容符号化]]を定義することによって実現し、
[[折衝]]は [CODE[Accept-Encoding]] を使うことになっています。
[SRC[>>6 2.]]

;; [16] 
こういうとき、これまでの [[IETF]] 
の[[プロトコル]]だともう1段階抽象化と折衝の仕組みを導入していたところでしょうが、
既存の[[内容符号化]]の[[折衝]]を流用して統合することで、
仕組みが簡単になって、既存の [[HTTP]] の実装と統合しやすくなっているのは優れた設計です。


[14] 
[[鍵]]が必要となりますが、その取得方法は定義されていません。
[SRC[>>6 2.]]
[[応用]]依存の別の方法で事前に当事者間で共有しておく必要があります。




= [20] [VAR[rs]], [VAR[データ]]
= [19] [[Assert]]: [VAR[データ]]は [VAR[rs]] - 17 [[バイト]][[以下]]
= [21] [VAR[[DFN[[RUBYB[詰め区切子オクテット][padding delimiter octet]]]]]]を、
[VAR[最終レコード]]なら 
[N[0x02]]、
それ以外なら
[N[0x01]]
に設定します。
= [22] [VAR[平文]]を、
[VAR[データ]]の後に[VAR[詰め区切子オクテット]]を連結したものに設定します。
= [23] [VAR[詰め区切子オクテット]]が
[N[0x01]] 
の場合、
== [24] [VAR[平文]]の末尾に、
[N[0x00]]
を 
[VAR[rs]] - 16 - [VAR[平文]]の[[長さ][byte length]]
個追加します。
= [25] それ以外の場合、
== [26] [VAR[平文]]の末尾に、
[N[0x00]]
を 
[VAR[rs]] - 16 - [VAR[平文]]の[[長さ][byte length]]
個追加して構いません。
= [43] 
@@
[VAR[nonce]]
= [27] 
[VAR[[RUBYB[暗号文][ciphertext]]]]を、
[CODE[AEAD_AES_128_GCM]]
を実行した結果に設定します。
[FIG(list members)[
: [VAR[鍵]] :
: [VAR[nonce]] : [VAR[nonce]]
: [VAR[平文]] : [VAR[平文]]
: [VAR[関連付けされたデータ]] : [[空バイト列]]
([[RFC 8188]] では「additional data」)
]FIG]
= [29] [[Assert]]:
[VAR[暗号文]]の[[長さ][byte length]] = [VAR[平文]]の[[長さ][byte length]] + [N[16]]
= [28] [[Assert]]:
[VAR[詰め区切子オクテット]]が
[N[0x01]] 
の場合、
[VAR[暗号文]]の[[長さ][byte length]]は [VAR[rs]]。
それ以外の場合、
[VAR[暗号文]]の[[長さ][byte length]]は [VAR[rs]] [[以下]]。
= [30] [VAR[レコード]]を、[VAR[暗号文]]に設定します。
= [31] [[Assert]]: [VAR[レコード]]の[[長さ]]は [N[17]] [[以上]]

= [32] [VAR[レコード]]の末尾から、
[N[0x00]]
[[バイト]]をすべて削除します。
= [33] [VAR[レコード]]が[[空バイト列]]の場合、
== [34] [RUBYB[[[失敗]]][fail]]を返し、ここで停止します。
= [35] [VAR[詰め区切子オクテット]]を、
[VAR[レコード]]の最後の[[バイト]]に設定し、
これを[VAR[レコード]]から削除します。
= [36] [VAR[詰め区切子オクテット]]が [N[0x02]] の場合、
== [37] [VAR[最終レコード]]を、[[偽]]に設定します。
= [38] [VAR[詰め区切子オクテット]]が [N[0x01]] の場合、
== [39] [VAR[最終レコード]]を、[[真]]に設定します。
= [40] それ以外の場合、
== [41] [[失敗]]を返し、ここで停止します。

= [18] [[Assert]]:
[VAR[暗号文]]の[[長さ][byte length]] = [VAR[平文]]の[[長さ][byte length]] + [N[16]]

= [42] [VAR[最終レコード]]が[[真]]で最後でない場合、
[VAR[最終レコード]]が[[偽]]で最後の場合、
[[失敗]]を返し、ここで停止します。


[17] 
[RUBYB[レコードサイズ][record size]]は固定であり、
最終的な符号化結果は、
ヘッダーと、
零個以上の固定サイズの暗号化された記録によって構成されます。
最後のレコードは、レコードサイズより小さくなることがあります。
レコードサイズは、
暗号化される[RUBYB[[[平文]]][plaintext]]の各部分の長さを決定します。
[[内容符号化]]ヘッダーの [CODE[rs]]
に指定します。
[SRC[>>6 2.]]

[11] 
本手法は、
[[OpenPGP]],
[[CMS]],
[[JWE]],
[[XML暗号化]]といった既存の[[メッセージ]]ベースの[[暗号化]]形式を採用せず、
[[RFC 5116]] のより低レベルな構造に依っています。
既存の形式では[[ストリーミング処理]]に適しません。
[SRC[>>6 1.]]
本手法は[[レコード]]構造により、
[[範囲要求]]や[[ランダムアクセス]]が、
[[レコードサイズ]]粒度で可能となります。
[SRC[>>6 2.]]

[44] 
適切な[[レコードサイズ]]は、状況により異なります。
小さくすると解読済み[[バイト]]を早めに解放できるので、
[[応答性]]が重要な[[応用]]に適しています。
小さいほど[[ランダムアクセス]]時に解読が必要な余分なデータが少なくて済みます。
逆に大きいほど処理やデータの[[オーバーヘッド]]は小さくなるので、
[[ストリーミング処理]]や[[ランダムアクセス]]や任意の[[詰め]]が不要な[[応用]]は、
[[レコードサイズ]]を大きくできます。
極端な場合は全体を1レコードにできます。
[SRC[>>6 2.]]

[63] 
[F[[CODE[rs]]]]
[[引数]]は32ビット[[符号無し整数]]なので、
[CODE[AEAD_AES_128_GCM]] の[VAR[平文]]の上限 2[SUP[36]] - 31 は超え得ません。
[SRC[>>6 2.1.]]
さらに、
[[IND-CPA]] の 2[SUP[-40]] の確率を防ぐため、
同じ [[input-keying material]] と [F[[CODE[salt]]]]
で暗号化される[VAR[平文]]の総量は
16バイトの
2[SUP[44.5]]
[[ブロック]][[未満]]でなければ[MUST[なりません]]。
[[レコードサイズ]]が
16バイトの[[倍数]]のとき、
これはすなわち[[詰め]]とオーバーヘッドを含めて
398テラバイトまで安全に暗号化できることを表します。
16バイトの倍数でないときは更に少なくなり、
最悪ケースは[[高々]]74テラバイトになります。
[SRC[>>6 4.4.]]



[45] 
[[メッセージ]]本体の[[レコード]]列の前に、
[DFN[[RUBYB[ヘッダーブロック][header block]]]]
([DFN[[RUBYB[内容符号化ヘッダー][content-coding header]]]])
を配置します。
[[ヘッダーブロック]]は、次の4つの[RUBYB[[[引数]]][parameter]]を順に並べたものです。
[SRC[>>6 2.1.]]

[FIG(list members)[

: [DFN[[F[[CODE[salt]]]]]] :
16バイト。
同じ [[input-keying material]] を使う別の [[payload]] 本体では、
同じ [CODE[salt]] を使っては[MUST[なりません]]。
[SRC[>>6 2.1., 4.3.]]
実装はメッセージごとに毎回 [CODE[salt]]
を生成する[SHOULD[べきです]]。
[SRC[>>6 4.3.]]
: [DFN[[F[[CODE[rs]]]]]] :
[[レコードサイズ]]を[[バイト]]単位で表し、
[[32ビット符号無し整数]]を[[ネットワークバイト順]]にしたもの。
: [DFN[[F[[CODE[idlen]]]]]] :
[F[[CODE[keyid]]]]
[[引数]]の長さを[[8ビット符号無し整数]]で表したもの。
: [DFN[[F[[CODE[keyid]]]]]] :
使用する [[keying material]] を識別するために使えます。
[F[[CODE[idlen]]]]
[[引数]]で指定された長さ。
受信者は、[[鍵]]を取得する方法を知っていることが期待され、
そのために [F[[CODE[keyid]]]]
[[引数]]を使うことができます。
[F[[CODE[keyid]]]] [[引数]]は、 特にその識別子を[[テキスト]]として[[レンダリング]]する必要がある場合にあっては、
[[RFC 3629]] [[UTF-8]] 符号化する[SHOULD[べきです]]。


]FIG]

[HISTORY[
[64] 
古い [[I-D]] では、この情報は [CODE[Encryption:]]
[[HTTPヘッダー]]に入れることになっていました。
[[HTTPヘッダー]]ではなく[[本体]]の先頭に入れることに変更したせいで、
[[ランダムアクセス]]できるという特徴が半分嘘になってしまっています。
]HISTORY]


[46] 
[DFN[[RUBYB[内容暗号化キー][content-encryption key]]]] ([DFN[[[CEK]]]])
は、
[[keying material]]
を複数の
[[HTTPメッセージ]]で再利用できるように、
[[salt]] を使って[[HTTPメッセージ]]ごとに求めます。
その方法として、
[[RFC 5869]] [[HKDF]]
で
[[SHA-256]] 
を使ったものを用います。
[SRC[>>6 2.2.]]

[FIG(steps)[
= [48] [VAR[salt]] を、
[VAR[ヘッダーブロック]]の
[F[[CODE[salt]]]]
に設定します。
= [47] [VAR[IKM]] を、
[VAR[ヘッダーブロック]]の [F[[CODE[keyid]]]]
から[[応用]]依存の方法で取得した
[[input-keying material]]
に設定します。
= [49] 
[VAR[PRK]] ([[疑似乱数]]キー) を、
[CODE[HMAC-SHA-256]] ([VAR[salt]], [VAR[IKM]])
の結果に設定します。
= [50] 
[VAR[cek_info]]
を、
[CODE[Content-Encoding: aes128gcm]]
の末尾に
[N[0x00]]
を連結した[[バイト列]]に設定します。
= [51] 
[VAR[CEK]]
を、
[CODE[HMAC-SHA-256]] ([VAR[PRK]], [VAR[cek_info]] の末尾に [N[0x01]] を連結した[[バイト列]])
の結果に設定します。
[NOTE[
[53] [VAR[L]] = [N[16]]
なので、このように簡略化できます。
]NOTE]
= [52] 
[VAR[PRK]]
と
[VAR[CEK]]
を返します。
]FIG]

[54] 
[[nonce]]
は、
[VAR[PRK]]、
[VAR[SEQ]]
から次のように決定します。
[SRC[>>6 2.3.]]

[FIG(steps)[
= [55] [VAR[nonce_info]] を、
[CODE[Content-Encoding: nonce]]
の末尾に
[N[0x00]]
を連結した[[バイト列]]に設定します。
= [56] [VAR[NONCE]]
を、
[CODE[HMAC-SHA-256]]
([VAR[PRK]], [VAR[nonce_info]] の末尾に [N[0x01]] を連結した[[バイト列]])
の結果と
[VAR[SEQ]]
を
[[XOR]]
した結果に設定します。
= [58] 
[[Assert]]:
[VAR[NONCE]]
は96ビットです。
= [57] [VAR[NONCE]] を返します。
]FIG]

[59] 
[VAR[[DFN[SEQ]]]]
は[DFN[[RUBYB[レコードシーケンス番号][record sequence number]]]]で、
[N[0]]
から始まる、
96ビット[[符号無し整数]]を[[ネットワークバイト順]]で表したものです。
[SRC[>>6 2.3.]]

[60] 
[[nonce]]
は、
[[レコード]]の削除や順序入れ替えを防ぐものです。
[SRC[>>6 2.3.]]


-*-*-

[61] 
本手法を使って内容の起源を認証する[[受信者]]は、
[CODE[aes128gcm]]
[[内容符号化]]を含まない[[HTTPメッセージ]]を拒絶しなければ[MUST[なりません]]。
[[内容符号化]]が自動的に除去されて、最終的な受信者がそれに気づかないおそれがあります。
[SRC[>>6 4.1.]]

[62] 
途中で途切れたメッセージでも本手法は処理できますが、
完全なメッセージであるものとして処理しては[MUST[なりません]]。
途中までのメッセージでも処理する受信者は、
攻撃者によりメッセージが途中で切られた可能性も考慮する必要があります。
[SRC[>>6 4.2.]]


* 歴史

[1] [CITE@en[Encrypted Content-Encoding for HTTP]]
([TIME[2016-04-06 02:26:28 +09:00]] 版)
<http://httpwg.org/http-extensions/draft-ietf-httpbis-encryption-encoding.html>

[2] [CITE@en[draft-ietf-webpush-encryption-08 - Message Encryption for Web Push]]
([TIME[2017-04-16 18:28:05 +09:00]])
<https://tools.ietf.org/html/draft-ietf-webpush-encryption-08>

[3] [[IANA登録簿]]に [CODE[aes128gcm]] が登録されました。 [TIME[2017-04-21T03:50:50.600Z]]

[4] [CITE@en[Add PushManager.supportedContentEncodings (#252)]]
([[beverloo]]著, [TIME[2017-04-26 01:13:27 +09:00]])
<https://github.com/w3c/push-api/commit/813f9af75d59e3fa1522db9aeeaa2bd158ff10bf>

[5] [CITE@en[encrypted-content-encoding/ece.js at master · web-push-libs/encrypted-content-encoding]]
([TIME[2019-01-04 13:12:20 +09:00]])
<https://github.com/web-push-libs/encrypted-content-encoding/blob/master/nodejs/ece.js>


[8] 
[TIME[平成29(2017)年6月][2017-06]]、
[DFN[RFC 8188]]
として出版されました
[SRC[>>6]]。
