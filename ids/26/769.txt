* Data model

[9] An [DFN[object]] has 
[DFN[[F[name]]]],
[DFN[[F[description]]]],
[DFN[[F[keywords]]]],
[DFN[[F[page URL]]]],
[DFN[[F[timestamp]]]],
[DFN[[F[modified]]]],
[DFN[[F[author]]]],
[DFN[[F[license]]]],
[DFN[[F[minimum latitude]]]],
[DFN[[F[minimum longitude]]]],
[DFN[[F[maximum latitude]]]], and
[DFN[[F[maximum longitude]]]],
which are initially [[null]].

[23] A [DFN[data set]] is an [[object]].

[24] A [[data set]] has
[DFN[[F[generator]]]],
which is initially [[null]].

[19] A [DFN[data set]] has
[DFN[[F[waypoints]]]],
[DFN[[F[routes]]]], and
[DFN[[F[tracks]]]], which are initially empty lists.

[25] A [DFN[point]] is an [[object]].

[26] A [[point]] has
[DFN[[F[latitude]]]],
[DFN[[F[longitude]]]],
[DFN[[F[elevation]]]],
[DFN[[F[geoid height]]]],
[DFN[[F[magnetic variation]]]],
[DFN[[F[comment]]]],
[DFN[[F[source]]]],
[DFN[[F[symbol name]]]],
[DFN[[F[type]]]], and
[DFN[[F[fix]]]],
which are initially [[null]].

[43] A [DFN[person]] has
[DFN[[F[name]]]],
[DFN[[F[email]]]], and
[DFN[[F[page URL]]]],
which are initially [[null]].

[51] A [DFN[license]] has
[DFN[[F[holder]]]],
[DFN[[F[year]]]], and
[DFN[[F[page URL]]]],
which are initially null.

* Parsing

[1] To [DFN[parse a GPX document]] [VAR[doc]], run these steps:
[FIG(steps)[
= [2] Let [VAR[element]] be [VAR[doc]]'s [F[document element]].
= [4] If [VAR[element]] is an [[element]] whose [F[local name]] is [CODE[gpx]]:
== [8] Let [VAR[object]] be a [[data set]].
== [6] [[Parse a [CODE[gpx]] element][parse a [CODE[gpx]] element]] [VAR[element]]
into [VAR[object]].
== [7] Return [VAR[object]].
= [11] Otherwise:
== [12] Return [[null]].
]FIG]

[28] To [DFN[process property elements]] of [[element]] [VAR[element]]
with [VAR[object]], run these steps:
[FIG(steps)[
= [29] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order:
== [30] Switch by [VAR[child]]'s [F[local name]]:
[FIG(switch)[
: [CODE[name][name (GPX)]] :
[FIG(steps)[
= [35] If [VAR[object]]'s [F[name]] is [[null]]:
== [31] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [32] If [VAR[text]] is not the [[empty string]]:
=== [33] Set [VAR[object]]'s [F[name]] to [VAR[text]].
]FIG]
: [CODE[desc][desc (GPX)]] :
[FIG(steps)[
= [36] If [VAR[object]]'s [F[description]] is [[null]]:
== [37] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [38] If [VAR[text]] is not the [[empty string]]:
=== [39] Set [VAR[object]]'s [F[description]] to [VAR[text]].
]FIG]
: [CODE[keywords][keywords (GPX)]] :
[FIG(steps)[
= [93] If [VAR[object]]'s [F[keywords]] is [[null]]:
== [94] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [95] If [VAR[text]] is not the [[empty string]]:
=== [96] Set [VAR[object]]'s [F[keywords]] to [VAR[text]].
]FIG]
: [CODE[author][author (GPX)]] :
[FIG(steps)[
= [40] If [VAR[object]]'s [F[author]] is [[null]]:
== [42] Let [VAR[person]] be a [[person]].
== [68] For each [[element]] [VAR[gc]] in [VAR[child]]'s [F[children]], in order:
=== [69] Switch by [VAR[gc]]'s [F[local name]]:
[FIG(switch)[
: [CODE[name][name (GPX)]] :
[FIG(steps)[
= [41] If [VAR[person]]'s [F[name]] is [[null]]:
== [70] Let [VAR[text]] be [VAR[gc]]'s [F[child text content]].
== [71] If [VAR[text]] is not the [[empty string]]:
=== [72] Set [VAR[person]]'s [F[name]] to [VAR[text]].
]FIG]
: [CODE[email][email (GPX)]] :
[FIG(steps)[
= [45] If [VAR[person]]'s [F[email]] is [[null]]:
== [46] Let [VAR[left]] be [VAR[gc]]'s [CODE[id][email (GPX)]] attribute value.
== [47] Let [VAR[right]] be [VAR[gc]]'s [CODE[domain][email (GPX)]] attribute value.
== [48] If [VAR[left]] and [VAR[right]] are not [[null]]:
=== [50] Let [VAR[email]] be [VAR[left]] followed by [CODE[@]] followed by [VAR[right]].
=== [49] Set [VAR[person]]'s [F[email]] to [VAR[email]].
]FIG]
: [CODE[link][link (GPX)]] :
[FIG(steps)[
= [82] If [VAR[person]]'s [F[page URL]] is [[null]]:
== [79] Let [VAR[href]] be [VAR[child]]'s [CODE(XMLa)@en[href]] attribute value.
== [80] If [VAR[href]] is not [[null]],
[[parse][parse a URL]] [VAR[href]] relative to [VAR[child]]'s [F[node document]].
== [65] If parsed and not failed:
=== [81] Set [VAR[person]]'s [F[page URL]] to the [[resulting URL string]].
]FIG]
]FIG]
== [44] Set [VAR[object]]'s [F[author]] to [VAR[person]].
]FIG]
: [CODE[copyright][copyright (GPX)]] :
[FIG(steps)[
= [52] If [VAR[object]]'s [F[license]] is [[null]]:
== [55] Let [VAR[license]] be a [[license]].
== [54] Set [VAR[license]]'s [F[holder]] to
[VAR[child]]'s [CODE[author][copyright (GPX)]] attribute value.
== [53] For each [[element]] [VAR[gc]] in [VAR[child]]'s [F[children]], in order:
=== [56] Switch by [VAR[gc]]'s [F[local name]]:
[FIG(switch)[
: [CODE[year]] :
[FIG(steps)[
= [57] If [VAR[license]]'s [F[year]] is [[null]]:
== [59] Let [VAR[text]] be [VAR[gc]]'s [F[child text content]].
== [60] If [VAR[text]] is four or more [[ASCII digits]]:
=== [61] Let [VAR[year]] be the result of applying the [[rules for parsing non-negative integers]] to [VAR[text]].
=== [3] If [VAR[year]] is a positive integer:
==== [58] Set [VAR[license]]'s [F[year]] to [VAR[year]].
]FIG]
: [CODE[license][license (GPX)]] :
[FIG(steps)[
= [62] If [VAR[license]]'s [F[page URL]] is [[null]]:
== [63] Let [VAR[text]] be [VAR[gc]]'s [F[child text content]].
== [64] If [VAR[text]] is not the [[empty string]],
[[parse][parse a URL]] [VAR[text]] relative to [VAR[gc]]'s [F[node document]].
== [66] If parsed and not failed:
=== [67] Set [VAR[license]]'s [F[page URL]] to the [[resulting URL string]].
]FIG]
]FIG]
]FIG]
: [CODE[link][link (GPX)]] :
[FIG(steps)[
= [73] If [VAR[object]]'s [F[page URL]] is [[null]]:
== [74] Let [VAR[href]] be [VAR[child]]'s [CODE(XMLa)@en[href]] attribute value.
== [75] If [VAR[href]] is not [[null]],
[[parse][parse a URL]] [VAR[href]] relative to [VAR[child]]'s [F[node document]].
== [76] If parsed and not failed:
=== [77] Set [VAR[object]]'s [F[page URL]] to the [[resulting URL string]].
]FIG]
: [CODE[time][time (GPX)]] :
[FIG(steps)[
= [83] If [VAR[child]]'s [F[namespace]] is [CODE[http://www.topografix.com/GPX/gpx_modified/0/1]]:
== [88] If [VAR[object]]'s [F[modified]] is [[null]]:
=== [85] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
=== [86] [[Parse a global date and time string][parse a global date and time string]]
[VAR[text]].
=== [87] If a time is returned,
set [VAR[object]]'s [F[modified]] to the time.
= [84] Otherwise:
== [89] If [VAR[object]]'s [F[timestamp]] is [[null]]:
=== [90] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
=== [91] [[Parse a global date and time string][parse a global date and time string]]
[VAR[text]].
=== [92] If a time is returned,
set [VAR[object]]'s [F[timestamp]] to the time.
]FIG]
: [CODE[bounds]] :
[FIG(steps)[
= [97] If [VAR[object]]'s [F[minimum latitude]] is [[null]]:
== [98] Set [VAR[object]]'s [F[minimum latitude]] be the result of applying the
[[rules for parsing a latitude value]] to [VAR[child]]'s [CODE[minlat]] attribute value.
= [99] If [VAR[object]]'s [F[minimum longitude]] is [[null]]:
== [100] Set [VAR[object]]'s [F[minimum longitude]] be the result of applying the
[[rules for parsing a longitude value]] to [VAR[child]]'s [CODE[minlon]] attribute value.
= [101] If [VAR[object]]'s [F[maximum latitude]] is [[null]]:
== [102] Set [VAR[object]]'s [F[maximum latitude]] be the result of applying the
[[rules for parsing a latitude value]] to [VAR[child]]'s [CODE[maxlat]] attribute value.
= [103] If [VAR[object]]'s [F[maximum longitude]] is [[null]]:
== [104] Set [VAR[object]]'s [F[maximum longitude]] be the result of applying the
[[rules for parsing a longitude value]] to [VAR[child]]'s [CODE[maxlon]] attribute value.
]FIG]

]FIG]
]FIG]

;; [78] These steps ignore any duplicate [CODE(XMLe)@en[link][link (GPX)]]
element.  They also ignore any [CODE(XMLe)@en[link][link (GPX)]] content.

[105] The [DFN[rules for parsing a latitude value]] [VAR[text]] are as given in the following algorithm:
[FIG(steps)[
= [106] Let [VAR[number]] be the result of applying the
[[rules for parsing floating-point number values]] to [VAR[text]].
= [107] If [VAR[number]] is not a number, return [[null]] and abort these steps.
= [108] If [VAR[number]] is greater than [N[90]], or less than [N[0]],
return [[null]] and abort these steps.
= [109] Return [VAR[number]].
]FIG]

[110] The [DFN[rules for parsing a longitude value]] [VAR[text]] are as given in the following algorithm:
[FIG(steps)[
= [111] Let [VAR[number]] be the result of applying the
[[rules for parsing floating-point number values]] to [VAR[text]].
= [112] If [VAR[number]] is not a number, return [[null]] and abort these steps.
= [113] If [VAR[number]] is greater than [N[180]], or less than [N[-180]],
return [[null]] and abort these steps.
= [114] Return [VAR[number]].
]FIG]

[10] To [DFN[parse a [CODE[gpx]] element]] [VAR[element]]
into [VAR[object]], run these steps:
[FIG(steps)[
= [14] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order:
== [17] If [VAR[object]]'s [F[generator]] is [[null]]:
=== [115] Set [VAR[object]]'s [F[generator]] to 
[VAR[child]]'s [CODE(XMLa)@en[creator]] attribute value.
== [15] Switch by [VAR[child]]'s [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[metadata][metadata (GPX)]] or [CODE(XMLe)@en[extensions][extensions (GPX)]] :
[[Process property elements][process property elements]] of [VAR[child]] into [VAR[object]].
: [CODE(XMLe)@en[wpt]] :
[FIG(steps)[
= [20] Let [VAR[point]] be a [[point]].
= [21] [[Parse a point element][parse a point element]] [VAR[child]] into [VAR[point]].
= [22] Append [VAR[point]] to [VAR[object]]'s [F[waypoints]].
]FIG]
: [CODE(XMLe)@en[rte]] :
@@
: [CODE(XMLe)@en[trk]] :
@@
]FIG]
]FIG]

[27] To [DFN[parse a point element]] [VAR[element]] into [VAR[object]],
run these steps:
[FIG(steps)[
= [18] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order:
== [117] If [VAR[object]]'s [F[latitude]] is [[null]]:
=== [116] Set [VAR[object]]'s [F[latitude]] to the result of applying the
[[rules for parsing a latitude value]] to [VAR[child]]'s [CODE[lat]] attribute value.
== [16] If [VAR[object]]'s [F[longitude]] is [[null]]:
=== [118] Set [VAR[object]]'s [F[longitude]] to the result of applying the
[[rules for parsing a latitude value]] to [VAR[child]]'s [CODE[lon]] attribute value.
== [15] Switch by [VAR[child]]'s [F[local name]]:
[FIG(switch)[
: [CODE[ele]] :
[FIG(steps)[
= [119] If [VAR[object]]'s [F[elevation]] is [[null]]:
== [120] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [121] Let [VAR[number]] be the result of applying the
[[rules for parsing floating-point number values]] to [VAR[text]].
== [122] If [VAR[number]] is not an error,
set [VAR[object]]'s [F[elevation]] to [VAR[number]].
]FIG]
: [CODE[geoidheight]] :
[FIG(steps)[
= [128] If [VAR[object]]'s [F[geoid height]] is [[null]]:
== [129] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [130] Let [VAR[number]] be the result of applying the
[[rules for parsing floating-point number values]] to [VAR[text]].
== [131] If [VAR[number]] is not an error,
set [VAR[object]]'s [F[geoid height]] to [VAR[number]].
]FIG]
: [CODE[magvar]] :
[FIG(steps)[
= [124] If [VAR[object]]'s [F[magnetic variation]] is [[null]]:
== [125] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [126] Let [VAR[number]] be the result of applying the
[[rules for parsing floating-point number values]] to [VAR[text]].
== [127] If [VAR[number]] is a number in the range [ [N[0]], [N[360]] ],
set [VAR[object]]'s [F[magnetic variation]] to [VAR[number]].
]FIG]
: [CODE[cmt]] :
[FIG(steps)[
= [132] If [VAR[object]]'s [F[comment]] is [[null]]:
== [133] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [134] If [VAR[text]] is not the [[empty string]]:
=== [135] Set [VAR[object]]'s [F[comment]] to [VAR[text]].
]FIG]
: [CODE[src][src (GPX)]] :
[FIG(steps)[
= [136] If [VAR[object]]'s [F[source]] is [[null]]:
== [137] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [138] If [VAR[text]] is not the [[empty string]]:
=== [139] Set [VAR[object]]'s [F[source]] to [VAR[text]].
]FIG]
: [CODE[sym]] :
[FIG(steps)[
= [140] If [VAR[object]]'s [F[symbol name]] is [[null]]:
== [141] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [142] If [VAR[text]] is not the [[empty string]]:
=== [143] Set [VAR[object]]'s [F[symbol name]] to [VAR[text]].
]FIG]
: [CODE[type][type (GPX)]] :
[FIG(steps)[
= [144] If [VAR[object]]'s [F[type]] is [[null]]:
== [145] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [146] If [VAR[text]] is not the [[empty string]]:
=== [147] Set [VAR[object]]'s [F[type]] to [VAR[text]].
]FIG]
: [CODE[fix][fix (GPX)]] :
[FIG(steps)[
= [148] If [VAR[object]]'s [F[fix]] is [[null]]:
== [149] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [150] If [VAR[text]] is not the [[empty string]]:
=== [151] Set [VAR[object]]'s [F[fix]] to [VAR[text]].
]FIG]

]FIG]
= [123] [[Process property elements][process property elements]] of [VAR[child]] into [VAR[object]].
]FIG]

;; [13] These steps intentionally ignore [[namespaces][namespace]].

* References

[5] The terms [DFN[[[element]]]], [DFN[[[attribute]]]],
[DFN[[F[document element]]]],
[DFN[[F[node document]]]],
[DFN[[F[children]]]], [DFN[[F[local name]]]],
and [DFN[[F[namespace]]]] are defined by the [[DOM Standard]].

[34] The terms [DFN[[[ASCII digits]]]], 
[DFN[[[rules for parsing non-negative integers]]]],
[DFN[[[rules for parsing floating-point number values]]]],
[DFN[[[parse a global date and time string]]]],
[DFN[[F[child text content]]]],
[DFN[parse a URL]], and
[DFN[resulting URL string]]
are defined by the [[HTML Standard]].