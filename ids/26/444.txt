
[15] A [DFN[feed]] has
[DFN[[F[entries]]][feed's entries]], which is a list of [[entries][entry]], and
[DFN[[F[authors]]][feed's authors]], which is a list of [[persons][person]].
They are initially empty.

[39] A [[feed]] has 
[DFN[[F[page URL]]][feed's page URL]],
[DFN[[F[feed URL]]][feed's feed URL]],
[DFN[[F[previous feed URL]]][feed's previous feed URL]],
[DFN[[F[next feed URL]]][feed's next feed URL]],
[DFN[[F[icon URL]]][feed's icon URL]],
[DFN[[F[logo URL]]][feed's logo URL]], and
[DFN[[F[updated]]][feed's updated]].
They are initially [[null]].

[226] A [[feed]] has
[DFN[[F[title]]][feed's title]],
[DFN[[F[subtitle]]][feed's subtitle]], and
[DFN[[F[description]]][feed's description]].
They are initially [[null]].  They can be [[null]], a [[string]], or a [CODE(DOMi)@en[Node]].

[28] An [DFN[entry]] has
[DFN[[F[authors]]][entry's authors]], which is a list of [[persons][person]],
[DFN[[F[categories]]][feed's categories]], which is a list of [[categories][category]], and
[DFN[[F[enclosures]]][feed's enclosures]], which is a list of [[enclosures][enclosure]].
They are initially empty.

[88] An [[entry]] has
[DFN[[F[feed]]][entry's feed]],
[DFN[[F[page URL]]][entry's page URL]],
[DFN[[F[comment page URL]]][entry's comment page URL]],
[DFN[[F[thumbnail URL]]][entry's thumbnail URL]],
[DFN[[F[published]]][entry's published]], and
[DFN[[F[updated]]][entry's updated]].
They are initially [[null]].

[227] An [[entry]] has
[DFN[[F[title]]][entry's title]] and
[DFN[[F[summary]]][entry's summary]].
They are initially [[null]].  They can be [[null]], a [[string]], or a [CODE(DOMi)@en[Node]].

[228] An [[entry]] has [DFN[[F[content]]][entry's content]].
It is initially [[null]].  It can be [[null]], a [[string]], a [[URL record]],
a [[data pair]], or a [CODE(DOMi)@en[Node]].

[229] A [DFN[data pair]] is either
([[null]], [[null]]),
([[MIME type]], [[string]]), or
([[MIME type]], [[byte sequence]]).

[188] An [DFN[enclosure]] has
[DFN[[F[URL]]][enclosure's URL]],
[DFN[[F[MIME type]]][enclosure's MIME type]], and
[DFN[[F[length]]][enclosure's length]].
They are initially [[null]].

;; [190] Note that a [[MIME type]] might or might not be a [[parsible MIME type]].

[81] To get the [DFN[[F[computed authors]]]] of an [[entry]] [VAR[entry]], run these steps:
[FIG(steps)[
= [82] If [VAR[entry]]'s [F[authors][entry's authors]] is not empty,
return [VAR[entry]]'s [F[authors][entry's authors]].
= [83] Otherwise, if [VAR[entry]]'s [F[feed][entry's feed]] is not null,
return [VAR[entry]]'s [F[feed][entry's feed]]'s [F[authors][feed's author]].
= [84] Otherwise, return an empty list.
]FIG]

[93] To get the [DFN[[F[computed updated]]]] of an [[entry]] [VAR[entry]], run these steps:
[FIG(steps)[
= [94] If [VAR[entry]]'s [F[updated][entry's updated]] is not [[null]],
return [VAR[entry]]'s [F[updated][entry's updated]].
= [97] Otherwise, if [VAR[entry]]'s [F[published][entry's published]] is not [[null]],
return [VAR[entry]]'s [F[published][entry's published]].
= [95] Otherwise, if [VAR[entry]]'s [F[feed][feed's entry]] is not null,
return [VAR[entry]]'s [F[feed][entry's feed]]'s [F[updated][feed's updated]].
= [96] Otherwise, return
@@ the current timestamp.
]FIG]

[29] A [DFN[person]] is a tuple of 
[DFN[[F[name]]][person's name]],
[DFN[[F[email]]][person's email]], and
[DFN[[F[page URL]]][person's page URL]].
They are initially [[null]].

[30] A [DFN[category]] is a pair of
[DFN[[F[term]]][category's term]] and
[DFN[[F[label]]][category's label]].

[130] The [DFN[[F[link relation]]]] of a [CODE(XMLe)@en[link][atom:link]] element 
in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]
[VAR[element]] is the value returned by the following steps:
[FIG(steps)[
= [131] If [VAR[element]] does not have a [CODE(XMLa)@en[rel]] attribute:
== [132] Return [CODE[http://www.iana.org/assignments/relation/alternate]].
= [134] Otherwise:
== [135] Let [VAR[rel]] be [VAR[element]]'s [CODE(XMLa)@en[rel]] attribute value.
== [136] If [VAR[rel]] contains a [CODE[:]] character:
=== [137] Return [VAR[rel]].
== [138] Otherwise:
=== [133] Return [CODE[http://www.iana.org/assignments/relation/]]
followed by [VAR[rel]].
]FIG]

[140] The [DFN[[F[href URL]]]] of a [CODE(XMLe)@en[link][atom:link]] element
in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]
[VAR[element]] is the value returned by the following steps:
[FIG(steps)[
= [141] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[href]] attribute value,
if any, or the empty string.
= [142] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
= [143] If failed, return [[null]].
= [144] Otherwise, return the [[resulting URL record]].
]FIG]

[1] To [DFN[process a feed response]] [VAR[res]], run these steps:
[FIG(steps)[
= [9] If [VAR[res]] is a [[network error]] or
[VAR[res]]'s [F[status][status code]] is not [CODE(HTTP)[200]],
return [[null]] and abort these steps.
= [2] Let [VAR[type]] be [VAR[res]]'s [F[computed MIME type]].
= [3] If [VAR[type]] is an [[XML MIME type]]:
== [7] Let [VAR[doc]] be a [CODE(DOMi)@en[Document]].
== [6] Let [VAR[parser]] be an [[XML parser]] associated with [VAR[doc]].
The [[XML parser]] [MUST[MUST]] implement [[XML5]].
It [MUST[MUST NOT]] [[fetch]] and process [[external entities][external entity]].
== [8] Run [VAR[parser]], using [VAR[res]]'s [F[body]] as its [F[input byte stream]].
The [CODE(MIME)@en[charset]] parameter value in the 
[CODE(HTTP)@en[Content-Type]] [[header value]] of [VAR[res]], if any, is used as
the [[encoding label]] provided by the underlying transport.
== [11] Set [VAR[doc]]'s [F[address][document's address]] to
[VAR[res]]'s [F[url][response's URL]].
== [27] Set [VAR[doc]]'s [F[character encoding][document's character encoding]]
to the [[character encoding]] used by [VAR[parser]].
== [5] Return the result of [[processing a feed document][process a feed document]] [VAR[doc]].
= [4] Otherwise, return [[null]].
]FIG]

[10] To [DFN[process a feed document]] [VAR[doc]], run these steps:
[FIG(steps)[
= [12] Let [VAR[root]] be [VAR[doc]]'s [F[root element]].
= [17] Switch by [VAR[root]]:
[FIG(switch)[
: [16] If it is a [CODE(XMLe)@en[feed]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
Return the result of [[processing an Atom feed element][process an Atom feed element]] [VAR[root]].
: [19] If it is an [CODE(XMLe)@en[rss]] element in the [[null namespace]] :
Return the result of [[processing an rss element][process an rss element]] [VAR[root]].
: [18] If it is an [CODE(XMLe)@en[RDF]] element in the [[RDF namespace]] :
Return the result of [[processing an RDF element][process an RDF element]] [VAR[root]].
: [13] Otherwise : Return [[null]].
]FIG]
]FIG]

[20] To [DFN[process an Atom feed element]] [VAR[element]], run these steps:
[FIG(steps)[
= [14] Let [VAR[feed]] be a [[feed]].
= [21] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [22] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[icon]] element in the [[Atom namespace]] :
[FIG(steps)[
= [37] If [VAR[feed]]'s [F[icon URL][feed's icon URL]] is [[null]]:
== [35] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [36] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [38] If not failed, set [VAR[feed]]'s [F[icon URL][feed's icon URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[logo]] element in the [[Atom namespace]] :
[FIG(steps)[
= [40] If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]]:
== [41] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [42] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [43] If not failed, set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[Atom namespace]] :
[FIG(steps)[
= [44] If [VAR[feed]]'s [F[title][feed's title]] is [[null]]:
== [45] Set [VAR[feed]]'s [F[title][feed's title]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [156] If [VAR[feed]]'s [F[title][feed's title]] is [[null]]:
== [157] Set [VAR[feed]]'s [F[title][feed's title]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[subtitle]] element in the [[Atom namespace]] :
[FIG(steps)[
= [46] If [VAR[feed]]'s [F[subtitle][feed's subtitle]] is [[null]]:
== [47] Set [VAR[feed]]'s [F[subtitle][feed's subtitle]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[tagline]] element in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [158] If [VAR[feed]]'s [F[subtitle][feed's subtitle]] is [[null]]:
== [159] Set [VAR[feed]]'s [F[subtitle][feed's subtitle]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[updated]] element in the [[Atom namespace]] :
[FIG(steps)[
= [48] If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]]:
== [49] Set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[modified]] element in the [[Atom 0.3 namespace]] or in the [[Atom namespace]] :
[FIG(steps)[
= [160] If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]]:
== [161] Set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[feed]], with [VAR[type]] [CODE[feed]].
: [CODE(XMLe)@en[author]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
Append the result of [[processing an Atom person][process an Atom person]] [VAR[child]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[entry]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [86] Let [VAR[entry]] be the result of [[processing an Atom entry][process an Atom entry]]
[VAR[child]].
= [85] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [87] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
]FIG]
= [25] Return [VAR[feed]].
]FIG]

[301] To [DFN[process an rss element]] [VAR[element]], run these steps:
[FIG(steps)[
= [239] Let [VAR[feed]] be a [[feed]].
= [240] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [302] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[channel]] element in the [[null namespace]] :
[[Process an RSS 2.0 channel][process an RSS 2.0 channel]] [VAR[element]] with [VAR[feed]].
: [CODE(XMLe)@en[item]] element in the [[null namespace]] :
[FIG(steps)[
= [242] Let [VAR[entry]] be the result of [[processing an RSS 2.0 item][process an RSS 2.0 item]]
[VAR[child]].
= [243] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [244] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
]FIG]
= [245] Return [VAR[feed]].
]FIG]

[207] To [DFN[process an RDF element]] [VAR[element]], run these steps:
[FIG(steps)[
= [238] Let [VAR[feed]] be a [[feed]].
= [210] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [236] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[channel]] element in the [[RSS 1.0 namespace]] :
[[Process an RSS 1.0 channel][process an RSS 1.0 channel]] [VAR[element]] with [VAR[feed]].
: [CODE(XMLe)@en[item]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [237] Let [VAR[entry]] be the result of [[processing an RSS 1.0 item][process an RSS 1.0 item]]
[VAR[child]].
= [241] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [303] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
: [CODE(XMLe)@en[image]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [305] If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]]:
== [306] Let [VAR[element]] be [VAR[child]]'s first [CODE(XMLe)@en[url]] child element
in the [[RSS 1.0 namespace]].
== [307] If [VAR[element]] is not [[null]]:
=== [308] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
=== [309] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
=== [310] If not failed, set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the [[resulting URL string]].
]FIG]
]FIG]
= [304] Return [VAR[feed]].
]FIG]

[206] To [DFN[process an RSS 2.0 channel]] [VAR[element]] with [[feed]] [VAR[feed]], 
run these steps:
[FIG(steps)[
= [208] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [209] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[description]] element in the [[null namespace]] :
If [VAR[feed]]'s [F[description][feed's description]] is [[null]],
set [VAR[feed]]'s [F[description][feed's description]] to
[VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[image]] element in the [[null namespace]] :
[FIG(steps)[
= [211] If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]]:
== [213] Let [VAR[element]] be [VAR[child]]'s first [CODE(XMLe)@en[url]] child element
in the [[null namespace]].
== [214] If [VAR[element]] is not [[null]]:
=== [212] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
=== [215] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
=== [216] If not failed, set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[managingEditor]] element in the [[null namespace]] :
Append the result of [[processing an RSS 2.0 person][process an RSS 2.0 person]] [VAR[child]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[pubDate]] or [CODE(XMLe)@en[lastBuildDate]] element in the [[null namespace]]:
[FIG(steps)[
= [217] If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]]:
== [218] Set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing an RSS 2.0 date][process an RSS 2.0 date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[null namespace]] :
[FIG(steps)[
= [223] If [VAR[feed]]'s [F[title][feed's title]] is [[null]]:
== [224] Set [VAR[feed]]'s [F[title][feed's title]] to 
[VAR[child]]'s [F[child text content]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[null namespace]] :
[FIG(steps)[
= [230] If [VAR[feed]]'s [F[page URL][feed's page URL]] is [[null]]:
== [231] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [232] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [233] If not failed, set [VAR[feed]]'s [F[page URL][feed's page URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[feed]], with [VAR[type]] [CODE[feed]].
: [CODE(XMLe)@en[item]] element in the [[null namespace]] :
[FIG(steps)[
= [147] Let [VAR[entry]] be the result of [[processing an RSS 2.0 item][process an RSS 2.0 item]]
[VAR[child]].
= [148] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [149] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
]FIG]
]FIG]

[311] To [DFN[process an RSS 1.0 channel]] [VAR[element]] with [[feed]] [VAR[feed]], 
run these steps:
[FIG(steps)[
= [312] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [313] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[description]] element in the [[RSS 1.0 namespace]] :
If [VAR[feed]]'s [F[description][feed's description]] is [[null]],
set [VAR[feed]]'s [F[description][feed's description]] to
[VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[date]] element in the [[Dublin Core namespace]]:
[FIG(steps)[
= [314] If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]]:
== [315] Set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [316] If [VAR[feed]]'s [F[title][feed's title]] is [[null]]:
== [317] Set [VAR[feed]]'s [F[title][feed's title]] to 
[VAR[child]]'s [F[child text content]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [318] If [VAR[feed]]'s [F[page URL][feed's page URL]] is [[null]]:
== [319] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [320] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [321] If not failed, set [VAR[feed]]'s [F[page URL][feed's page URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[feed]], with [VAR[type]] [CODE[feed]].
]FIG]
]FIG]

[52] To [DFN[process an Atom entry]] [VAR[element]], run these steps:
[FIG(steps)[
= [78] Let [VAR[entry]] be an [[entry]].
= [79] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [80] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[author]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
Append the result of [[processing an Atom person][process an Atom person]] [VAR[child]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[category]] element in the [[Atom namespace]] :
[FIG(steps)[
= [89] Let [VAR[category]] a [[category]].
= [90] Set [VAR[category]]'s [F[term][category's term]] to the
[CODE(XMLa)@en[term]] attribute value of [VAR[child]], if any, or the empty string.
= [91] Set [VAR[category]]'s [F[label][category's label]] to the
[CODE(XMLa)@en[label]] attribute value of [VAR[child]], if any, or [VAR[category]]'s 
[F[term][category's term]].
= [92] Append [VAR[category]] to [VAR[entry]]'s [F[categories][entry's categories]].
]FIG]
: [CODE(XMLe)@en[subject]] element in the [[Dublin Core namespace]] :
[FIG(steps)[
= [344] Let [VAR[category]] a [[category]].
= [345] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
= [346] Set [VAR[category]]'s [F[term][category's term]] to [VAR[text]].
= [347] Set [VAR[category]]'s [F[label][category's label]] to [VAR[text]].
= [348] Append [VAR[category]] to [VAR[entry]]'s [F[categories][entry's categories]].
]FIG]
: [CODE(XMLe)@en[published]] element in the [[Atom namespace]] :
[FIG(steps)[
= [33] If [VAR[entry]]'s [F[published][entry's published]] is [[null]]:
== [34] Set [VAR[entry]]'s [F[published][entry's published]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[created]] element in the [[Atom 0.3 namespace]] or in the [[Atom namespace]] :
[FIG(steps)[
= [193] If [VAR[entry]]'s [F[published][entry's published]] is [[null]]:
== [194] Set [VAR[entry]]'s [F[published][entry's published]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[updated]] element in the [[Atom namespace]] :
[FIG(steps)[
= [31] If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]]:
== [32] Set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[modified]] element in the [[Atom 0.3 namespace]] or in the [[Atom namespace]] :
[FIG(steps)[
= [23] If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]]:
== [26] Set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[Atom namespace]] :
[FIG(steps)[
= [98] If [VAR[entry]]'s [F[title][entry's title]] is [[null]]:
== [99] Set [VAR[entry]]'s [F[title][entry's title]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [197] If [VAR[entry]]'s [F[title][entry's title]] is [[null]]:
== [198] Set [VAR[entry]]'s [F[title][entry's title]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[summary]] element in the [[Atom namespace]] :
[FIG(steps)[
= [100] If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]]:
== [101] Set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[summary]] element in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [195] If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]]:
== [196] Set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[content]] element in the [[Atom namespace]] :
[FIG(steps)[
= [128] If [VAR[entry]]'s [F[content][entry's content]] is [[null]]:
== [129] Set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[processing an Atom content][process an Atom content]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[content]] element in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [191] If [VAR[entry]]'s [F[content][entry's content]] is [[null]]:
== [192] Set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[entry]], with [VAR[type]] [CODE[entry]].
: [CODE(XMLe)@en[thumbnail]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [360] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [361] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[url]] attribute value.
== [362] If [VAR[text]] is not [[null]]:
=== [363] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
=== [364] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
]FIG]
= [246] Return [VAR[entry]].
]FIG]

[249] To [DFN[process an RSS 2.0 item]] [VAR[element]], run these steps:
[FIG(steps)[
= [248] Let [VAR[entry]] be an [[entry]].
= [250] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [251] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[category]] element in the [[null namespace]] :
[FIG(steps)[
= [258] Let [VAR[category]] a [[category]].
= [262] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
= [259] Set [VAR[category]]'s [F[term][category's term]] to [VAR[text]].
= [260] Set [VAR[category]]'s [F[label][category's label]] to [VAR[text]].
= [261] Append [VAR[category]] to [VAR[entry]]'s [F[categories][entry's categories]].
]FIG]
: [CODE(XMLe)@en[link]] element in the [[null namespace]] :
[FIG(steps)[
= [291] If [VAR[entry]]'s [F[page URL][entry's page URL]] is [[null]]:
== [292] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [293] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
== [294] If not failed, set [VAR[entry]]'s [F[page URL][entry's page URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[comments]] element in the [[null namespace]] :
[FIG(steps)[
= [263] If [VAR[entry]]'s [F[comment page URL][entry's comment page URL]] is [[null]]:
== [264] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [265] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
== [266] If not failed, set [VAR[entry]]'s [F[comment page URL][entry's comment page URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[thumbnail]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [355] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [356] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[url]] attribute value.
== [357] If [VAR[text]] is not [[null]]:
=== [358] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
=== [359] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[author]] element in the [[null namespace]] :
Append the result of [[processing an RSS 2.0 person][process an RSS 2.0 person]] [VAR[child]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[pubDate]] element in the [[null namespace]]:
[FIG(steps)[
= [295] If [VAR[entry]]'s [F[published][entry's published]] is [[null]]:
== [296] Set [VAR[entry]]'s [F[published][entry's published]] to the result of
[[processing an RSS 2.0 date][process an RSS 2.0 date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[updated]] element in the [[Atom namespace]]:
[FIG(steps)[
= [353] If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]]:
== [354] Set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[null namespace]] :
[FIG(steps)[
= [297] If [VAR[entry]]'s [F[title][entry's title]] is [[null]]:
== [298] Set [VAR[entry]]'s [F[title][entry's title]] to 
[VAR[element]]'s [F[child text content]].
]FIG]
: [CODE(XMLe)@en[description]] element in the [[null namespace]] :
[FIG(steps)[
= [187] If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]]:
== [189] Set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
]FIG]
: [CODE(XMLe)@en[encoded]] element in the [[RSS content namespace]] :
[FIG(steps)[
= [299] If [VAR[entry]]'s [F[content][entry's content]] is [[null]]:
== [300] Set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
]FIG]
: [CODE(XMLe)@en[enclosure]] element in the [[null namespace]] :
[FIG(steps)[
= [279] Let [VAR[enclosure]] be an [[enclosure]].
= [280] Let [VAR[text]] be [VAR[child]]'s [CODE(XMLa)@en[url]] attribute value.
= [281] If [VAR[text]] is not [[null]]:
== [282] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [283] If not failed, set [VAR[enclosure]]'s [F[URL][enclosure's URL]] to the [[resulting URL string]].
= [284] Set [VAR[enclosure]]'s [F[type][enclosure's type]] to [VAR[child]]'s
[CODE(XMLa)@en[type]] attribute value.
= [285] Let [VAR[length]] be [VAR[child]]'s [CODE(XMLa)@en[length]] attribute value.
= [286] If [VAR[length]] is not null:
== [287] Let [VAR[n]] be the result of applying the
[[rules for parsing non-negative integers]] to [VAR[length]].
== [288] If [VAR[n]] is not an error:
=== [289] Set [VAR[enclosure]]'s [F[length][enclosure's length]] to [VAR[n]].
= [290] Append [VAR[enclosure]] to [VAR[object]]'s [F[enclosures][entry's enclosures]].
]FIG]
]FIG]
= [252] Return [VAR[entry]].
]FIG]

[322] To [DFN[process an RSS 1.0 item]] [VAR[element]], run these steps:
[FIG(steps)[
= [323] Let [VAR[entry]] be an [[entry]].
= [324] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [325] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[link]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [331] If [VAR[entry]]'s [F[page URL][entry's page URL]] is [[null]]:
== [332] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [333] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
== [334] If not failed, set [VAR[entry]]'s [F[page URL][entry's page URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[imageurl]] element in the [[Hatena namespace]] :
[FIG(steps)[
= [349] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [350] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [351] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
== [352] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[date]] element in the [[Dublin Core namespace]]:
[FIG(steps)[
= [335] If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]]:
== [336] Set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
]FIG]
: [CODE(XMLe)@en[subject]] element in the [[Dublin Core namespace]] :
[FIG(steps)[
= [326] Let [VAR[category]] a [[category]].
= [327] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
= [328] Set [VAR[category]]'s [F[term][category's term]] to [VAR[text]].
= [329] Set [VAR[category]]'s [F[label][category's label]] to [VAR[text]].
= [330] Append [VAR[category]] to [VAR[entry]]'s [F[categories][entry's categories]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [337] If [VAR[entry]]'s [F[title][entry's title]] is [[null]]:
== [338] Set [VAR[entry]]'s [F[title][entry's title]] to 
[VAR[element]]'s [F[child text content]].
]FIG]
: [CODE(XMLe)@en[description]] element in the [[RSS 1.0 namespace]] :
[FIG(steps)[
= [339] If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]]:
== [340] Set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
]FIG]
: [CODE(XMLe)@en[encoded]] element in the [[RSS content namespace]] :
[FIG(steps)[
= [341] If [VAR[entry]]'s [F[content][entry's content]] is [[null]]:
== [342] Set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
]FIG]
]FIG]
= [343] Return [VAR[entry]].
]FIG]

[24] To [DFN[process an Atom person]] [VAR[element]], run these steps:
[FIG(steps)[
= [54] Let [VAR[person]] be a [[person]].
= [55] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [56] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[name]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]:
If [VAR[person]]'s [F[name][person's name]] is [[null]],
set [VAR[person]]'s [F[name][person's name]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[email]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]:
If [VAR[person]]'s [F[email][person's email]] is [[null]],
set [VAR[person]]'s [F[email][person's email]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[uri]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [57] If [VAR[person]]'s [F[page URL][person's page URL]] is [[null]]:
== [58] Let [VAR[text]] be [VAR[child]]'s [F[child text content]].
== [59] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [60] If not failed, set [VAR[person]]'s [F[page URL][person's page URL]] to the [[resulting URL string]].
]FIG]
]FIG]
= [53] Return [VAR[person]].
]FIG]

[247] To [DFN[process an RSS 2.0 person]] [VAR[element]], run these steps:
[FIG(steps)[
= [254] Let [VAR[person]] be a [[person]].
= [253] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [255] Set [VAR[person]]'s [F[name][person's name]] to [VAR[text]].
= [256] Return [VAR[person]].
]FIG]

@@ [257] email address should be extracted from [VAR[text]]?

[50] To [DFN[process an Atom text]] [VAR[element]], run these steps:
[FIG(steps)[
= [61] Let [VAR[type]] be the [CODE(XMLa)@en[type]] attribute value
of [VAR[element]], if any, or [[null]].
= [62] If [VAR[type]] is [CODE[html]]:
== [267] Return the result of [[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
= [63] Otherwise, if [VAR[type]] is [CODE[xhtml]] and
[VAR[element]]'s [F[children]] contains a [CODE(HTMLe)@en[div]] element:
== [66] Let [VAR[div]] be a [[clone]] of [VAR[element]]'s
first [CODE(HTMLe)@en[div]] element child, with [VAR[clone children flag]] set.
== [67] Let [VAR[fragment]] be a [CODE(DOMi)@en[DocumentFragment]]
whose [F[node document]] is [VAR[element]]'s [F[node document]].
== [68] For each child [VAR[node]] in [VAR[div]]'s [F[children]], in order,
[[insert]] [VAR[node]] into [VAR[fragment]].
== [69] Return [VAR[fragment]].
= [64] Otherwise:
== [65] Return [VAR[element]]'s [F[child text content]].
]FIG]

[102] To [DFN[process an Atom content]] [VAR[element]], run these steps:
[FIG(steps)[
= [103] Let [VAR[type]] be the [CODE(XMLa)@en[type]] attribute value
of [VAR[element]], if any, or [[null]].
= [104] If [VAR[type]] is either [[null]], [CODE[text]], [CODE[html]], or [CODE[xhtml]]:
== [105] Return the result of [[processing an Atom text][process an Atom text]]
[VAR[element]] and abort these steps.
= [106] If [VAR[element]] has a [CODE(XMLa)@en[src]] attribute:
== [108] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[src]] attribute value.
== [109] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
== [111] If failed, return ([[null]], [[null]]) and abort these steps.
== [112] Return the [[resulting URL record]] and abort these steps.
= [110] Let [VAR[mime]] be the result of [[parsing][parse a MIME type]] [VAR[text]] as a [[MIME type]].
= [113] If [VAR[mime]] is an [[XML MIME type]]:
== [125] Let [VAR[fragment]] be a [CODE(DOMi)@en[DocumentFragment]]
whose [F[node document]] is [VAR[element]]'s [F[node document]].
== [126] For each child [VAR[node]] in [VAR[element]]'s [F[children]], in order,
[[insert]] [VAR[node]] into [VAR[fragment]].
== [127] Return [VAR[fragment]].
= [114] Otherwise:
== [117] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [123] If [VAR[mime]]'s [F[type]] is [CODE(MIME)@en[text][text/[VAR[*]]]]
([[ASCII case-insensitive]]):
=== [124] Return ([VAR[type]], [VAR[text]]).
== [115] Otherwise:
=== [118] Let [VAR[binary]] be the result of [[decoding base64][decode base64]] [VAR[text]].
=== [119] If [VAR[binary]] is [[null]]:
==== [120] Return ([[null]], [[null]]).
=== [121] Otherwise:
==== [122] Return ([VAR[type]], [VAR[binary]]).
]FIG]

;; [107] These steps return either 
a [[string]], a [[URL record]], a [[data pair]], or a [CODE(DOMi)@en[Node]].

[153] To [DFN[process an Atom 0.3 content]] [VAR[element]], run these steps:
[FIG(steps)[
= [155] Let [VAR[mode]] be [VAR[element]]'s [CODE(XMLa)@en[mode]] attribute value,
if any, or [CODE(MIME)@en[xml]].
= [154] Let [VAR[type]] be [VAR[element]]'s [CODE(XMLa)@en[type]] attribute value,
if any, or [CODE(MIME)@en[text/plain]].
= [175] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [162] If [VAR[mode]] is [CODE[escaped]]:
== [177] If [VAR[type]] is equal to [CODE(MIME)@en[text/plain]] ([[ASCII case-insensitive]]):
=== [179] Return [VAR[text]].
== [180] Otherwise, if [VAR[type]] is equal to [CODE(MIME)@en[text/html]] ([[ASCII case-insensitive]]):
=== [268] Return the result of [[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
== [185] Otherwise:
=== [186] Return ([VAR[type]], [VAR[text]]).
= [163] Otherwise, if [VAR[mode]] is [CODE[base64]]:
== [176] Let [VAR[binary]] be the result of [[decoding base64][decode base64]] [VAR[text]].
== [181] If [VAR[binary]] is [[null]]:
=== [182] Return ([[null]], [[null]]).
== [183] Otherwise:
=== [184] Return ([VAR[type]], [VAR[binary]]).
= [164] Otherwise:
== [165] If [VAR[type]] is equal to [CODE(MIME)@en[text/plain]] ([[ASCII case-insensitive]]):
=== [170] Return [VAR[text]].
== [171] Otherwise:
=== [172] Let [VAR[fragment]] be a [CODE(DOMi)@en[DocumentFragment]]
whose [F[node document]] is [VAR[element]]'s [F[node document]].
=== [173] For each child [VAR[node]] in [VAR[element]]'s [F[children]], in order,
[[insert]] [VAR[node]] into [VAR[fragment]].
=== [174] Return [VAR[fragment]].
]FIG]

;; [225] These steps return either a [[string]], a [[data pair]], or a [CODE(DOMi)@en[Node]].

@@ [116] Need to define [[decode base64]] [VAR[text]].
It returns [[null]] if failed.

[178] To [DFN[parse escaped HTML content]] of element [VAR[element]], run these steps:
[FIG(steps)[
= [73] Let [VAR[div]] be a [CODE(HTMLe)@en[div]] element
whose [F[node document]] is [VAR[element]]'s [F[node document]].
= [74] Let [VAR[fragment]] be a [CODE(DOMi)@en[DocumentFragment]]
whose [F[node document]] is [VAR[element]]'s [F[node document]].
= [70] Let [VAR[nodes]] be the result of running the [[HTML fragment parsing algorithm]]
with [VAR[context]] element [VAR[div]] and
[VAR[input]] [VAR[element]]'s [F[child text content]].
= [71] For each item [VAR[node]] in [VAR[nodes]], in order,
[[insert]] [VAR[node]] into [VAR[fragment]].
= [72] Return [VAR[fragment]].
]FIG]

[234] To [DFN[process an Atom link]] [VAR[element]] for [VAR[object]]
with [VAR[type]], run these steps:

[FIG(steps)[
= [139] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/alternate]]:
== [145] If [VAR[object]]'s [F[page URL]] is [[null]]:
=== [146] Set [VAR[object]]'s [F[page URL]] to
[VAR[child]]'s [F[href URL]].
= [235] If [VAR[mode]] is [CODE[feed]]:
== [150] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/self]]:
=== [151] If [VAR[object]]'s [F[feed URL][feed's feed URL]] is [[null]]:
==== [152] Set [VAR[object]]'s [F[feed URL][feed's feed URL]] to
[VAR[child]]'s [F[href URL]].
== [199] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/prev]] or
[CODE[http://www.iana.org/assignments/relation/previous]]:
=== [201] If [VAR[object]]'s [F[previous feed URL][feed's previous feed URL]] is [[null]]:
==== [202] Set [VAR[object]]'s [F[previous feed URL][feed's previous feed URL]] to
[VAR[child]]'s [F[href URL]].
== [203] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/next]]:
=== [204] If [VAR[object]]'s [F[next feed URL][feed's next feed URL]] is [[null]]:
==== [205] Set [VAR[object]]'s [F[next feed URL][feed's next feed URL]] to
[VAR[child]]'s [F[href URL]].
= [269] If [VAR[mode]] is [CODE[entry]]:
== [270] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/enclosure]]:
=== [271] Let [VAR[enclosure]] be an [[enclosure]],
whose [F[URL][enclosure's URL]] is [VAR[child]]'s [F[href URL]].
=== [273] Set [VAR[enclosure]]'s [F[type][enclosure's type]] to [VAR[child]]'s
[CODE(XMLa)@en[type]] attribute value.
=== [275] Let [VAR[length]] be [VAR[child]]'s [CODE(XMLa)@en[length]] attribute value.
=== [276] If [VAR[length]] is not null:
==== [277] Let [VAR[n]] be the result of applying the
[[rules for parsing non-negative integers]] to [VAR[length]].
==== [278] If [VAR[n]] is not an error:
===== [274] Set [VAR[enclosure]]'s [F[length][enclosure's length]] to [VAR[n]].
=== [272] Append [VAR[enclosure]] to [VAR[object]]'s [F[enclosures][entry's enclosures]].
]FIG]

[51] To [DFN[process an Atom date]] [VAR[element]], run these steps:
[FIG(steps)[
= [75] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [76] Return the result of [[parsing an RFC 3339 [CODE[xs:dateTime]] string][parse an RFC 3339 [CODE[xs:dateTime]] string]] [VAR[text]].
]FIG]

@@ [77] Need to define [DFN[parse an RFC 3339 [CODE[xs:dateTime]] string]].
It returns a number (JS timestamp) or [[null]].

[166] To [DFN[process a W3C-DTF date]] [VAR[element]], run these steps:
[FIG(steps)[
= [167] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [168] Return the result of [[parsing a W3C-DTF string][parse a W3C-DTF string]] [VAR[text]].
]FIG]

@@ [169] Need to define [DFN[parse a W3C-DTF string]].
It returns a number (JS timestamp) or [[null]].

[219] To [DFN[process an RSS 2.0 date]] [VAR[element]], run these steps:
[FIG(steps)[
= [220] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [221] Return the result of [[parsing an RFC 822 date-time string][parse an RFC 822 date-time string]] [VAR[text]].
]FIG]

@@ [222] Need to define [DFN[parse an RFC 822 date-time string]].
It returns a number (JS timestamp) or [[null]].