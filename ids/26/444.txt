* Data model

[15] A [DFN[feed]] has
[DFN[[F[entries]]][feed's entries]], which is a list of [[entries][entry]], and
[DFN[[F[authors]]][feed's authors]], which is a list of [[persons][person]].
They are initially empty.

[39] A [[feed]] has 
[DFN[[F[page URL]]][feed's page URL]],
[DFN[[F[feed URL]]][feed's feed URL]],
[DFN[[F[previous feed URL]]][feed's previous feed URL]],
[DFN[[F[next feed URL]]][feed's next feed URL]],
[DFN[[F[icon URL]]][feed's icon URL]],
[DFN[[F[logo URL]]][feed's logo URL]], and
[DFN[[F[updated]]][feed's updated]].
They are initially [[null]].

[226] A [[feed]] has
[DFN[[F[title]]][feed's title]],
[DFN[[F[subtitle]]][feed's subtitle]], and
[DFN[[F[description]]][feed's description]].
They are initially [[null]].  They can be [[null]], a [[string]], or a [CODE(DOMi)@en[Node]].

[28] An [DFN[entry]] has
[DFN[[F[authors]]][entry's authors]], which is a list of [[persons][person]],
[DFN[[F[categories]]][feed's categories]], which is a list of [[categories][category]], and
[DFN[[F[enclosures]]][feed's enclosures]], which is a list of [[enclosures][enclosure]].
They are initially empty.

[88] An [[entry]] has
[DFN[[F[feed]]][entry's feed]],
[DFN[[F[page URL]]][entry's page URL]],
[DFN[[F[comment page URL]]][entry's comment page URL]],
[DFN[[F[thumbnail URL]]][entry's thumbnail URL]],
[DFN[[F[duration][entry's duration]]]],
[DFN[[F[published]]][entry's published]], and
[DFN[[F[updated]]][entry's updated]].
They are initially [[null]].

[227] An [[entry]] has
[DFN[[F[title]]][entry's title]],
[DFN[[F[summary]]][entry's summary]], and
[DFN[[F[content]]][entry's content]].
They are initially [[null]].  They can be [[null]], a [[string]], or a [CODE(DOMi)@en[Node]].

[188] An [DFN[enclosure]] has
[DFN[[F[URL]]][enclosure's URL]],
[DFN[[F[MIME type]]][enclosure's MIME type]], and
[DFN[[F[length]]][enclosure's length]].
They are initially [[null]].

;; [190] Note that a [[MIME type]] might or might not be a [[parsible MIME type]].

[81] To get the [DFN[[F[computed authors]]]] of an [[entry]] [VAR[entry]], run these steps:
[FIG(steps)[
= [82] If [VAR[entry]]'s [F[authors][entry's authors]] is not empty,
return [VAR[entry]]'s [F[authors][entry's authors]].
= [83] Otherwise, if [VAR[entry]]'s [F[feed][entry's feed]] is not null,
return [VAR[entry]]'s [F[feed][entry's feed]]'s [F[authors][feed's author]].
= [84] Otherwise, return an empty list.
]FIG]

[93] To get the [DFN[[F[computed updated]]]] of an [[entry]] [VAR[entry]], run these steps:
[FIG(steps)[
= [94] If [VAR[entry]]'s [F[updated][entry's updated]] is not [[null]],
return [VAR[entry]]'s [F[updated][entry's updated]].
= [97] Otherwise, if [VAR[entry]]'s [F[published][entry's published]] is not [[null]],
return [VAR[entry]]'s [F[published][entry's published]].
= [95] Otherwise, if [VAR[entry]]'s [F[feed][feed's entry]] is not null,
return [VAR[entry]]'s [F[feed][entry's feed]]'s [F[updated][feed's updated]].
= [96] Otherwise, return
@@ the current timestamp.
]FIG]

[29] A [DFN[person]] is a tuple of 
[DFN[[F[name]]][person's name]],
[DFN[[F[email]]][person's email]],
[DFN[[F[page URL]]][person's page URL]], and
[DFN[[F[icon URL]]][person's icon URL]].
They are initially [[null]].

[30] A [DFN[category]] is a pair of
[DFN[[F[term]]][category's term]] and
[DFN[[F[label]]][category's label]].

[44] A [[category]] with string [VAR[name]] is a [[category]]
whose [F[term]] is [VAR[name]] and [F[label]] is [VAR[name]].

[295] A [[category]] is [DFN[equal][equal category]] to another [[category]]
if their [F[term][category's term]] and [F[label][category's label]]
are respectively equal.

* Parsing

** Namespaces

[365] The following namespaces are used in this section:
[FIG(table)[
:name: Name
:url: [[Namespace URL][namespace URL]]

:name: The [DFN@en[null namespace]]
:url: [[null]]

:name: The [DFN@en[Atom namespace]]
:url: [CODE(URI)@en[http://www.w3.org/2005/Atom]]

:name: The [DFN@en[Atom 0.3 namespace]]
:url: [CODE(URI)@en[http://purl.org/atom/ns#]]

:name: The [DFN@en[Dublin Core namespace]]
:url: [CODE(URI)@en[http://purl.org/dc/elements/1.1/]]

:name: The [DFN@en[GData namespace]]
:url: [CODE(URI)@en[http://schemas.google.com/g/2005]]

:name: The [DFN@en[Hatena namespace]]
:url: [CODE(URI)@en[http://www.hatena.ne.jp/info/xmlns#]]

:name: The [DFN@en[iTunes namespace]]
:url: [CODE(URI)@en[http://www.itunes.com/dtds/podcast-1.0.dtd]]

:name: The [DFN@en[Media RSS namespace]]
:url: [CODE(URI)@en[http://search.yahoo.com/mrss/]]

:name: The [DFN@en[RDF namespace]]
:url: [CODE(URI)@en[http://www.w3.org/1999/02/22-rdf-syntax-ns#]]

:name: The [DFN@en[RSS namespace]]
:url: [CODE(URI)@en[http://purl.org/rss/1.0/]]

:name: The [DFN@en[RSS content namespace]]
:url: [CODE(URI)@en[http://purl.org/rss/1.0/modules/content/]]

]FIG]

** Timestamps

[51] To [DFN[process an Atom date]] [VAR[element]], run these steps:
[FIG(steps)[
= [75] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [76] Return the result of [[parsing an RFC 3339 [CODE[xs:dateTime]] string][parse an RFC 3339 [CODE[xs:dateTime]] string]] [VAR[text]].
]FIG]

@@ [77] Need to define [DFN[parse an RFC 3339 [CODE[xs:dateTime]] string]].
It returns a number (JS timestamp) or [[null]].

[166] To [DFN[process a W3C-DTF date]] [VAR[element]], run these steps:
[FIG(steps)[
= [167] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [168] Return the result of [[parsing a W3C-DTF string][parse a W3C-DTF string]] [VAR[text]].
]FIG]

@@ [169] Need to define [DFN[parse a W3C-DTF string]].
It returns a number (JS timestamp) or [[null]].

[219] To [DFN[process an RSS 2.0 date]] [VAR[element]], run these steps:
[FIG(steps)[
= [220] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [221] Return the result of [[parsing an RFC 822 date-time string][parse an RFC 822 date-time string]] [VAR[text]].
]FIG]

@@ [222] Need to define [DFN[parse an RFC 822 date-time string]].
It returns a number (JS timestamp) or [[null]].

** Links

[372] To [DFN[process a URL element]] [VAR[element]], run these steps:
[FIG(steps)[
= [35] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [196] If [VAR[text]] is the [[empty string]], return [[null]] and abort these steps.
= [36] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
= [38] If not failed, return the [[resulting URL string]].
= [373] Otherwise, return [[null]].
]FIG]

[130] The [DFN[[F[link relation]]]] of a [CODE(XMLe)@en[link][atom:link]] element 
in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]
[VAR[element]] is the value returned by the following steps:
[FIG(steps)[
= [131] If [VAR[element]] does not have a [CODE(XMLa)@en[rel]] attribute:
== [132] Return [CODE[http://www.iana.org/assignments/relation/alternate]].
= [134] Otherwise:
== [135] Let [VAR[rel]] be [VAR[element]]'s [CODE(XMLa)@en[rel]] attribute value.
== [136] If [VAR[rel]] contains a [CODE[:]] character:
=== [137] Return [VAR[rel]].
== [138] Otherwise:
=== [133] Return [CODE[http://www.iana.org/assignments/relation/]]
followed by [VAR[rel]].
]FIG]

[140] The [DFN[[F[href URL]]]] of a [CODE(XMLe)@en[link][atom:link]] element
in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]
[VAR[element]] is the value returned by the following steps:
[FIG(steps)[
= [141] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[href]] attribute value,
if any, or the empty string.
= [142] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
= [143] If failed, return [[null]].
= [144] Otherwise, return the [[resulting URL record]].
]FIG]

[234] To [DFN[process an Atom link]] [VAR[element]] for [VAR[object]]
with [VAR[type]], run these steps:

[FIG(steps)[
= [139] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/alternate]]:
== [145] If [VAR[object]]'s [F[page URL]] is [[null]]:
=== [146] Set [VAR[object]]'s [F[page URL]] to
[VAR[child]]'s [F[href URL]].
= [235] If [VAR[mode]] is [CODE[feed]]:
== [150] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/self]]:
=== [151] If [VAR[object]]'s [F[feed URL][feed's feed URL]] is [[null]]:
==== [152] Set [VAR[object]]'s [F[feed URL][feed's feed URL]] to
[VAR[child]]'s [F[href URL]].
== [199] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/prev]] or
[CODE[http://www.iana.org/assignments/relation/previous]]:
=== [201] If [VAR[object]]'s [F[previous feed URL][feed's previous feed URL]] is [[null]]:
==== [202] Set [VAR[object]]'s [F[previous feed URL][feed's previous feed URL]] to
[VAR[child]]'s [F[href URL]].
== [203] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/next]]:
=== [204] If [VAR[object]]'s [F[next feed URL][feed's next feed URL]] is [[null]]:
==== [205] Set [VAR[object]]'s [F[next feed URL][feed's next feed URL]] to
[VAR[child]]'s [F[href URL]].
= [269] If [VAR[mode]] is [CODE[entry]]:
== [270] If [VAR[element]]'s [F[link relation]] is 
[CODE[http://www.iana.org/assignments/relation/enclosure]]:
=== [271] Let [VAR[enclosure]] be an [[enclosure]],
whose [F[URL][enclosure's URL]] is [VAR[child]]'s [F[href URL]].
=== [273] Set [VAR[enclosure]]'s [F[type][enclosure's type]] to [VAR[child]]'s
[CODE(XMLa)@en[type]] attribute value.
=== [275] Let [VAR[length]] be [VAR[child]]'s [CODE(XMLa)@en[length]] attribute value.
=== [276] If [VAR[length]] is not null:
==== [277] Let [VAR[n]] be the result of applying the
[[rules for parsing non-negative integers]] to [VAR[length]].
==== [278] If [VAR[n]] is not an error and [VAR[n]] is greater than zero:
===== [274] Set [VAR[enclosure]]'s [F[length][enclosure's length]] to [VAR[n]].
=== [272] Append [VAR[enclosure]] to [VAR[object]]'s [F[enclosures][entry's enclosures]].
]FIG]

** Persons

[24] To [DFN[process an Atom person]] [VAR[element]], run these steps:
[FIG(steps)[
= [54] Let [VAR[person]] be a [[person]].
= [55] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [56] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[name]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]:
If [VAR[person]]'s [F[name][person's name]] is [[null]],
set [VAR[person]]'s [F[name][person's name]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[email]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]]:
If [VAR[person]]'s [F[email][person's email]] is [[null]],
set [VAR[person]]'s [F[email][person's email]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[uri]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
If [VAR[person]]'s [F[page URL][person's page URL]] is [[null]],
set [VAR[person]]'s [F[page URL][person's page URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[image]] element in the [[GData namespace]] :
[FIG(steps)[
= [160] If [VAR[person]]'s [F[icon URL][person's icon URL]] is [[null]]:
== [161] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[src]] attribute value.
== [170] If [VAR[text]] is not [[null]] or the [[empty string]]:
=== [179] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
=== [187] If not failed, set [VAR[person]]'s [F[icon URL][person's icon URL]] to the [[resulting URL string]].
]FIG]
]FIG]
= [53] Return [VAR[person]].
]FIG]

[247] To [DFN[process an RSS 2.0 person]] [VAR[element]], run these steps:
[FIG(steps)[
= [254] Let [VAR[person]] be a [[person]].
= [253] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [157] If [VAR[text]] is
one or more [[Unicode code points][Unicode code point]] that are not [[space characters]],
followed by one or more [[space characters]],
followed by a [CODE[(]] character,
followed by one or more [[Unicode code points][Unicode code point]],
followed by a [CODE[)]] character:
== [158] Set [VAR[person]]'s [F[name][person's name]] to the substring
between [CODE[(]] and [CODE[)]] characters in [VAR[text]], not inclusive.
== [159] Set [VAR[person]]'s [F[email][person's email]] to the substring
before the first [[space character][space characters]] in [VAR[text]].
= Otherwise:
== [255] Set [VAR[person]]'s [F[name][person's name]] to [VAR[text]].
= [256] Return [VAR[person]].
]FIG]

** Texts

[50] To [DFN[process an Atom text]] [VAR[element]], run these steps:
[FIG(steps)[
= [61] Let [VAR[type]] be the [CODE(XMLa)@en[type]] attribute value
of [VAR[element]], if any, or [[null]].
= [62] If [VAR[type]] is [CODE[html]]:
== [267] Return the result of [[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
= [63] Otherwise, if [VAR[type]] is [CODE[xhtml]] and
[VAR[element]]'s [F[children]] contains a [CODE(HTMLe)@en[div]] element:
== [66] Let [VAR[div]] be a [[clone]] of [VAR[element]]'s
first [CODE(HTMLe)@en[div]] element child, with [VAR[clone children flag]] set.
== [67] Let [VAR[fragment]] be a [CODE(DOMi)@en[DocumentFragment]]
whose [F[node document]] is [VAR[element]]'s [F[node document]].
== [68] For each child [VAR[node]] in [VAR[div]]'s [F[children]], in order,
[[insert]] [VAR[node]] into [VAR[fragment]].
== [104] [[Sanitize][sanitize]] [VAR[fragment]].
== [105] If [VAR[fragment]] [[has significant content]]:
=== [69] Return [VAR[fragment]].
== [106] Otherwise:
=== [107] Return [[null]].
= [64] Otherwise:
== [65] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [45] If [VAR[text]] contains a [[Unicode code point]] that is not a [[space character]]:
=== [46] Return [VAR[text]].
== [47] Otherwise:
=== [48] Return [[null]].
]FIG]

;; [102] [[MIME type]] [CODE(XMLa)@en[type]] attribute values
and [CODE(XMLa)@en[src]] attribute of the [CODE(XMLe)@en[atom:content]]
element is not supported by these steps as they are not widely used.

[153] To [DFN[process an Atom 0.3 content]] [VAR[element]], run these steps:
[FIG(steps)[
= [155] Let [VAR[mode]] be [VAR[element]]'s [CODE(XMLa)@en[mode]] attribute value,
if any, or [CODE(MIME)@en[xml]].
= [154] Let [VAR[type]] be [VAR[element]]'s [CODE(XMLa)@en[type]] attribute value,
if any, or [CODE(MIME)@en[text/plain]].
= [175] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [162] If [VAR[mode]] is [CODE[escaped]]:
== [180] If [VAR[type]] is equal to [CODE(MIME)@en[text/html]] ([[ASCII case-insensitive]]):
=== [268] Return the result of [[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
== [177] Otherwise:
=== [60] If [VAR[text]] contains a [[Unicode code point]] that is not a [[space character]]:
==== [98] Return [VAR[text]].
=== [99] Otherwise:
==== [100] Return [[null]].
= [164] Otherwise:
== [49] If [VAR[text]] contains a [[Unicode code point]] that is not a [[space character]]:
=== [57] Return [VAR[text]].
== [58] Otherwise:
=== [59] Return [[null]].
]FIG]

;; [103] Combinations of [VAR[mode]] and [VAR[type]] not widely used 
are not supported by these steps.

[178] To [DFN[parse escaped HTML content]] of element [VAR[element]], run these steps:
[FIG(steps)[
= [101] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
= [73] Let [VAR[div]] be a [CODE(HTMLe)@en[div]] element
whose [F[node document]] is [VAR[element]]'s [F[node document]].
= [74] Let [VAR[fragment]] be a [CODE(DOMi)@en[DocumentFragment]]
whose [F[node document]] is [VAR[element]]'s [F[node document]].
= [70] Let [VAR[nodes]] be the result of running the [[HTML fragment parsing algorithm]]
with [VAR[context]] set to [VAR[div]] and [VAR[input]] set to [VAR[text]].
= [71] For each item [VAR[node]] in [VAR[nodes]], in order,
[[insert]] [VAR[node]] into [VAR[fragment]].
= [108] [[Sanitize][sanitize]] [VAR[fragment]].
= [109] If [VAR[fragment]] [[has significant content]]:
== [72] Return [VAR[fragment]].
= [110] Otherwise:
== [111] Return [[null]].
]FIG]

[112] To [DFN[sanitize]] [CODE(DOMi)@en[Node]] [VAR[node]], run these steps:
[FIG(steps)[
= [113] If there is
an [CODE(HTMLe)@en[img]] element whose
[CODE(HTMLa)@en[width]] attribute value is [CODE[1]] and
[CODE(HTMLa)@en[height]] attribute value is [CODE[1]],
[[remove]] it from its [F[parent]].
]FIG]

;; [115] These steps do not remove possibly dangerous content, such as 
[CODE(HTMLe)@en[script]] elements.  When [VAR[node]] is used
(e.g. inserted into a document), they have to be removed or
sandboxed (by, e.g., [CODE(HTMLa)@en[sandbox]] attribute and [[CSP]])
such that unreliable script will not run and
any fetch to a third party origin will be blocked.

[114] A [CODE(DOMi)@en[Node]] [VAR[node]] [DFN[has significant content]] if
there is an [[inclusive descendant]] of [VAR[node]],
which is a [[feed significant content]],
which does not have an [CODE(HTMLa)@en[hidden]] attribute, and
which is not an [[inclusive descendant]] of 
a [CODE(HTMLe)@en[script]] or [CODE(HTMLe)@en[style]] element
in [[HTML namespace]] or in [[SVG namespace]]
which is an [[inclusive descendant]] of [VAR[node]].

[129] A [CODE(DOMi)@en[Node]] is a [[feed significant content]] if
it is a [[palpable content]] and is an [[embedded content]].

;; [128] As the [CODE(DOMi)@en[Node]] objects returned by algorithms in this specification
share the same [F[node document]] as the input document, their [[base URL]]
is the [[URL]] of the input response.

** Entries

[52] To [DFN[process an Atom entry]] [VAR[element]], run these steps:
[FIG(steps)[
= [78] Let [VAR[entry]] be an [[entry]].
= [79] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [80] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[author]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
Append the result of [[processing an Atom person][process an Atom person]] [VAR[child]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[category]] element in the [[Atom namespace]] :
[FIG(steps)[
= [89] Let [VAR[category]] a [[category]].
= [90] Set [VAR[category]]'s [F[term][category's term]] to the
[CODE(XMLa)@en[term]] attribute value of [VAR[child]], if any, or the empty string.
= [91] Set [VAR[category]]'s [F[label][category's label]] to the
[CODE(XMLa)@en[label]] attribute value of [VAR[child]], if any, or [VAR[category]]'s 
[F[term][category's term]].
= [92] Append [VAR[category]] to [VAR[entry]]'s [F[categories][entry's categories]].
]FIG]
: [CODE(XMLe)@en[subject]] element in the [[Dublin Core namespace]] :
Append a [[category]] whose [VAR[name]] is
[VAR[child]]'s [F[child text content]]
to [VAR[entry]]'s [F[categories][entry's categories]].
: [CODE(XMLe)@en[published]] element in the [[Atom namespace]] :
If [VAR[entry]]'s [F[published][entry's published]] is [[null]],
set [VAR[entry]]'s [F[published][entry's published]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
: [CODE(XMLe)@en[created]] element in the [[Atom 0.3 namespace]] or in the [[Atom namespace]] :
If [VAR[entry]]'s [F[published][entry's published]] is [[null]],
set [VAR[entry]]'s [F[published][entry's published]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
: [CODE(XMLe)@en[updated]] element in the [[Atom namespace]] :
If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]],
set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
: [CODE(XMLe)@en[modified]] element in the [[Atom 0.3 namespace]] or in the [[Atom namespace]]:
If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]],
set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
: [CODE(XMLe)@en[title]] element in the [[Atom namespace]] :
If [VAR[entry]]'s [F[title][entry's title]] is [[null]],
set [VAR[entry]]'s [F[title][entry's title]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
: [CODE(XMLe)@en[title]] element in the [[Atom 0.3 namespace]] :
If [VAR[entry]]'s [F[title][entry's title]] is [[null]],
set [VAR[entry]]'s [F[title][entry's title]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
: [CODE(XMLe)@en[summary]] element in the [[Atom namespace]] :
If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]],
set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
: [CODE(XMLe)@en[summary]] element in the [[Atom 0.3 namespace]] :
If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]],
set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
: [CODE(XMLe)@en[content]] element in the [[Atom namespace]] :
If [VAR[entry]]'s [F[content][entry's content]] is [[null]],
set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
: [CODE(XMLe)@en[content]] element in the [[Atom 0.3 namespace]] :
If [VAR[entry]]'s [F[content][entry's content]] is [[null]],
set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[entry]], with [VAR[type]] [CODE[entry]].
: [CODE(XMLe)@en[thumbnail]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [360] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [361] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[url]] attribute value.
== [362] If [VAR[text]] is not [[null]] or the [[empty string]]:
=== [363] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
=== [364] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[group]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [116] For each [[element]] [VAR[gc]] in [VAR[child]]'s [F[children]], in order,
run these substeps:
== [117] Switch by [VAR[gc]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[title]] element in the [[Media RSS namespace]] :
If [VAR[entry]]'s [F[title][entry's title]] is [[null]],
set [VAR[entry]]'s [F[title][entry's title]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[gc]].
: [CODE(XMLe)@en[description]] element in the [[Media RSS namespace]] :
If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]],
set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[gc]].
: [CODE(XMLe)@en[thumbnail]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [118] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [119] Let [VAR[text]] be [VAR[gc]]'s [CODE(XMLa)@en[url]] attribute value.
== [120] If [VAR[text]] is not [[null]] or the [[empty string]]:
=== [121] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[gc]]'s [F[node document]].
=== [122] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[content]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [123] Let [VAR[enclosure]] be an [[enclosure]].
= [124] Let [VAR[text]] be [VAR[gc]]'s [CODE(XMLa)@en[url]] attribute value.
= [125] If [VAR[text]] is not [[null]] or the [[empty string]]:
== [126] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[gc]]'s [F[node document]].
== [127] If not failed:
=== [163] Set [VAR[enclosure]]'s [F[URL][enclosure's URL]] to the [[resulting URL string]].
=== [165] Set [VAR[enclosure]]'s [F[type][enclosure's type]] to [VAR[gc]]'s
[CODE(XMLa)@en[type]] attribute value.
=== [171] Append [VAR[enclosure]] to [VAR[object]]'s [F[enclosures][entry's enclosures]].
]FIG]
]FIG]
]FIG]
]FIG]
= [246] Return [VAR[entry]].
]FIG]

[249] To [DFN[process an RSS 2.0 item]] [VAR[element]], run these steps:
[FIG(steps)[
= [248] Let [VAR[entry]] be an [[entry]].
= [250] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [251] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[category]] element in the [[null namespace]] :
Append a [[category]] whose [VAR[name]] is
[VAR[child]]'s [F[child text content]]
to [VAR[entry]]'s [F[categories][entry's categories]].
: [CODE(XMLe)@en[author]] element in the [[null namespace]] :
Append the result of [[processing an RSS 2.0 person][process an RSS 2.0 person]] [VAR[child]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[author]] element in the [[iTunes namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[pubDate]] element in the [[null namespace]]:
If [VAR[entry]]'s [F[published][entry's published]] is [[null]],
set [VAR[entry]]'s [F[published][entry's published]] to the result of
[[processing an RSS 2.0 date][process an RSS 2.0 date]] [VAR[child]].
: [CODE(XMLe)@en[updated]] element in the [[Atom namespace]]:
If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]],
set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
: [CODE(XMLe)@en[link]] element in the [[null namespace]] :
If [VAR[entry]]'s [F[page URL][entry's page URL]] is [[null]],
set [VAR[entry]]'s [F[page URL][entry's page URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[comments]] element in the [[null namespace]] :
If [VAR[entry]]'s [F[comment page URL][entry's comment page URL]] is [[null]],
set [VAR[entry]]'s [F[comment page URL][entry's comment page URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[thumbnail]] element in the [[Media RSS namespace]] :
[FIG(steps)[
= [355] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [356] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[url]] attribute value.
== [357] If [VAR[text]] is not [[null]] or the [[empty string]]:
=== [358] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
=== [359] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[image]] element in the [[iTunes namespace]] :
[FIG(steps)[
= [189] If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]]:
== [191] Let [VAR[text]] be [VAR[element]]'s [CODE(XMLa)@en[href]] attribute value.
== [192] If [VAR[text]] is not [[null]] or the [[empty string]]:
=== [193] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[element]]'s [F[node document]].
=== [194] If not failed, set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[enclosure]] element in the [[null namespace]] :
[FIG(steps)[
= [279] Let [VAR[enclosure]] be an [[enclosure]].
= [280] Let [VAR[text]] be [VAR[child]]'s [CODE(XMLa)@en[url]] attribute value.
= [281] If [VAR[text]] is not [[null]] or the [[empty string]]:
== [282] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
== [283] If not failed:
=== [195] Set [VAR[enclosure]]'s [F[URL][enclosure's URL]] to the [[resulting URL string]].
=== [284] Set [VAR[enclosure]]'s [F[type][enclosure's type]] to [VAR[child]]'s
[CODE(XMLa)@en[type]] attribute value.
=== [285] Let [VAR[length]] be [VAR[child]]'s [CODE(XMLa)@en[length]] attribute value.
=== [286] If [VAR[length]] is not null:
==== [287] Let [VAR[n]] be the result of applying the
[[rules for parsing non-negative integers]] to [VAR[length]].
==== [288] If [VAR[n]] is not an error and [VAR[n]] is greater than zero:
===== [289] Set [VAR[enclosure]]'s [F[length][enclosure's length]] to [VAR[n]].
=== [290] Append [VAR[enclosure]] to [VAR[object]]'s [F[enclosures][entry's enclosures]].
]FIG]
: [CODE(XMLe)@en[title]] element in the [[null namespace]] :
If [VAR[entry]]'s [F[title][entry's title]] is [[null]],
set [VAR[entry]]'s [F[title][entry's title]] to [VAR[element]]'s [F[child text content]].
: [CODE(XMLe)@en[subtitle]] element in the [[iTunes namespace]] :
If [VAR[entry]]'s [F[subtitle][entry's subtitle]] is [[null]],
set [VAR[entry]]'s [F[subtitle][entry's subtitle]] to [VAR[element]]'s [F[child text content]].
: [CODE(XMLe)@en[description]] element in the [[null namespace]] :
If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]],
set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
: [CODE(XMLe)@en[summary]] element in the [[iTunes namespace]] :
If [VAR[entry]]'s [F[subtitle][entry's subtitle]] is [[null]],
set [VAR[entry]]'s [F[subtitle][entry's subtitle]] to [VAR[element]]'s [F[child text content]].
: [CODE(XMLe)@en[encoded]] element in the [[RSS content namespace]] :
If [VAR[entry]]'s [F[content][entry's content]] is [[null]],
set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
: [CODE(XMLe)@en[duration]] element in the [[iTunes namespace]] :
[FIG(steps)[
= [218] If [VAR[entry]]'s [F[duration][entry's duration]] is not [[null]]:
== [198] Let [VAR[text]] be [VAR[element]]'s [F[child text content]].
== [212] If [VAR[text]] is one or more [[ASCII digits]]:
=== [217] Set [VAR[entry]]'s [F[duration][entry's duration]] to
the [[ASCII digits]] in [VAR[text]], interpreted as a decimal number.
== [215] Otherwise, if [VAR[text]] is one or more [[ASCII digits]],
followed by a [CODE(char)[:]] character,
followed by one or more [[ASCII digits]]:
=== [223] Set [VAR[m]] to the first sequence of [[ASCII digits]] in [VAR[text]],
interpreted as a decimal number.
=== [224] Set [VAR[s]] to the second sequence of [[ASCII digits]] in [VAR[text]],
interpreted as a decimal number.
=== [230] Set [VAR[entry]]'s [F[duration][entry's duration]] to
[CODE(math)[[VAR[m]] × 60 + [VAR[s]]]].
== [216] Otherwise, if [VAR[text]] is one or more [[ASCII digits]],
followed by a [CODE(char)[:]] character,
followed by one or more [[ASCII digits]],
followed by a [CODE(char)[:]] character,
followed by one or more [[ASCII digits]]:
=== [231] Set [VAR[h]] to the first sequence of [[ASCII digits]] in [VAR[text]],
interpreted as a decimal number.
=== [232] Set [VAR[m]] to the second sequence of [[ASCII digits]] in [VAR[text]],
interpreted as a decimal number.
=== [233] Set [VAR[s]] to the third sequence of [[ASCII digits]] in [VAR[text]],
interpreted as a decimal number.
=== [257] Set [VAR[entry]]'s [F[duration][entry's duration]] to
[CODE(math)[[VAR[h]] × 3600 + [VAR[m]] × 60 + [VAR[s]]]].
]FIG]
]FIG]
= [252] Return [VAR[entry]].
]FIG]

[322] To [DFN[process an RSS 1.0 item]] [VAR[element]], run these steps:
[FIG(steps)[
= [323] Let [VAR[entry]] be an [[entry]].
= [324] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [325] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[link]] element in the [[RSS namespace]] :
If [VAR[entry]]'s [F[page URL][entry's page URL]] is [[null]],
set [VAR[entry]]'s [F[page URL][entry's page URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[imageurl]] element in the [[Hatena namespace]] :
If [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] is [[null]],
set [VAR[entry]]'s [F[thumbnail URL][entry's thumbnail URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[entry]]'s [F[authors][entry's author]].
: [CODE(XMLe)@en[date]] element in the [[Dublin Core namespace]]:
If [VAR[entry]]'s [F[updated][entry's updated]] is [[null]],
set [VAR[entry]]'s [F[updated][entry's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
: [CODE(XMLe)@en[subject]] element in the [[Dublin Core namespace]] :
Append a [[category]] whose [VAR[name]] is
[VAR[child]]'s [F[child text content]]
to [VAR[entry]]'s [F[categories][entry's categories]].
: [CODE(XMLe)@en[title]] element in the [[RSS namespace]] :
If [VAR[entry]]'s [F[title][entry's title]] is [[null]],
set [VAR[entry]]'s [F[title][entry's title]] to [VAR[element]]'s [F[child text content]].
: [CODE(XMLe)@en[description]] element in the [[RSS namespace]] :
If [VAR[entry]]'s [F[summary][entry's summary]] is [[null]],
set [VAR[entry]]'s [F[summary][entry's summary]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
: [CODE(XMLe)@en[encoded]] element in the [[RSS content namespace]] :
If [VAR[entry]]'s [F[content][entry's content]] is [[null]],
set [VAR[entry]]'s [F[content][entry's content]] to the result of
[[parsing escaped HTML content][parse escaped HTML content]] of [VAR[element]].
]FIG]
= [343] Return [VAR[entry]].
]FIG]

[262] To [DFN[cleanup entry]] [VAR[entry]], run these steps:
[FIG(steps)[
= [263] If [VAR[entry]]'s [F[page URL][entry's page URL]] is not [[null]] and
there is an [[enclosure]] whose [F[URL][enclosure's URL]] is equal to
[VAR[entry]]'s [F[page URL][entry's page URL]] in
[VAR[entry]]'s [F[enclosures][entry's enclosures]]:
== [264] Set [VAR[entry]]'s [F[page URL][entry's page URL]] to [[null]].
= [265] If [VAR[entry]]'s [F[subtitle][entry's subtitle]] is a [[string]] and is equal to
[VAR[entry]]'s [F[title][entry's title]]:
== [266] Set [VAR[entry]]'s [F[subtitle][entry's subtitle]] to [[null]].
= [291] If [VAR[entry]]'s [F[summary][entry's summary]] is a [[string]] and is equal to
[VAR[entry]]'s [F[title][entry's title]]:
== [292] Set [VAR[entry]]'s [F[summary][entry's summary]] to [[null]].
= [293] If [VAR[entry]]'s [F[categories][entry's categories]] contains 
a [[category]] whose [F[term]] is the [[empty string]],
remove the [[category]] from [VAR[entry]]'s [F[categories][entry's categories]].
= [294] If [VAR[entry]]'s [F[categories][entry's categories]] contains 
a [[category]] which is [[equal][equal category]] to another [[category]] in the same list,
remove the [[category]] from [VAR[entry]]'s [F[categories][entry's categories]].
]FIG]

** Feeds

[1] To [DFN[process a feed response]] [VAR[res]], run these steps:
[FIG(steps)[
= [9] If [VAR[res]] is a [[network error]] or
[VAR[res]]'s [F[status][status code]] is not [CODE(HTTP)[200]],
return [[null]] and abort these steps.
= [2] Let [VAR[type]] be [VAR[res]]'s [F[computed MIME type]].
= [3] If [VAR[type]] is an [[XML MIME type]]:
== [7] Let [VAR[doc]] be a [CODE(DOMi)@en[Document]].
== [6] Let [VAR[parser]] be an [[XML parser]] associated with [VAR[doc]].
The [[XML parser]] [MUST[MUST]] implement [[XML5]].
It [MUST[MUST NOT]] [[fetch]] and process [[external entities][external entity]].
== [8] Run [VAR[parser]], using [VAR[res]]'s [F[body]] as its [F[input byte stream]].
The [CODE(MIME)@en[charset]] parameter value in the 
[CODE(HTTP)@en[Content-Type]] [[header value]] of [VAR[res]], if any, is used as
the [[encoding label]] provided by the underlying transport.
== [11] Set [VAR[doc]]'s [F[address][document's address]] to
[VAR[res]]'s [F[url][response's URL]].
== [27] Set [VAR[doc]]'s [F[character encoding][document's character encoding]]
to the [[character encoding]] used by [VAR[parser]].
== [5] Return the result of [[processing a feed document][process a feed document]] [VAR[doc]].
= [4] Otherwise, return [[null]].
]FIG]

;; [33] Scripting is disabled as the document is not in any [[browsing context]].

[10] To [DFN[process a feed document]] [VAR[doc]], run these steps:
[FIG(steps)[
= [12] Let [VAR[root]] be [VAR[doc]]'s [F[root element]].
= [17] Switch by [VAR[root]]:
[FIG(switch)[
: [16] If it is a [CODE(XMLe)@en[feed]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
Return the result of [[processing an Atom feed element][process an Atom feed element]] [VAR[root]].
: [19] If it is an [CODE(XMLe)@en[rss]] element in the [[null namespace]] :
Return the result of [[processing an rss element][process an rss element]] [VAR[root]].
: [18] If it is an [CODE(XMLe)@en[RDF]] element in the [[RDF namespace]] :
Return the result of [[processing an RDF element][process an RDF element]] [VAR[root]].
: [13] Otherwise : Return [[null]].
]FIG]
]FIG]

[20] To [DFN[process an Atom feed element]] [VAR[element]], run these steps:
[FIG(steps)[
= [14] Let [VAR[feed]] be a [[feed]].
= [21] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [22] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[title]] element in the [[Atom namespace]] :
If [VAR[feed]]'s [F[title][feed's title]] is [[null]],
set [VAR[feed]]'s [F[title][feed's title]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
: [CODE(XMLe)@en[title]] element in the [[Atom 0.3 namespace]] :
If [VAR[feed]]'s [F[title][feed's title]] is [[null]],
set [VAR[feed]]'s [F[title][feed's title]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
: [CODE(XMLe)@en[subtitle]] element in the [[Atom namespace]] :
If [VAR[feed]]'s [F[subtitle][feed's subtitle]] is [[null]],
set [VAR[feed]]'s [F[subtitle][feed's subtitle]] to the result of
[[processing an Atom text][process an Atom text]] [VAR[child]].
: [CODE(XMLe)@en[tagline]] element in the [[Atom 0.3 namespace]] :
If [VAR[feed]]'s [F[subtitle][feed's subtitle]] is [[null]],
set [VAR[feed]]'s [F[subtitle][feed's subtitle]] to the result of
[[processing an Atom 0.3 content][process an Atom 0.3 content]] [VAR[child]].
: [CODE(XMLe)@en[updated]] element in the [[Atom namespace]] :
If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]],
set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing an Atom date][process an Atom date]] [VAR[child]].
: [CODE(XMLe)@en[modified]] element in the [[Atom 0.3 namespace]] or in the [[Atom namespace]]:
If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]],
set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[feed]], with [VAR[type]] [CODE[feed]].
: [CODE(XMLe)@en[icon]] element in the [[Atom namespace]] :
If [VAR[feed]]'s [F[icon URL][feed's icon URL]] is [[null]],
set [VAR[feed]]'s [F[icon URL][feed's icon URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[logo]] element in the [[Atom namespace]] :
If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]],
set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[author]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
Append the result of [[processing an Atom person][process an Atom person]] [VAR[child]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[entry]] element in the [[Atom namespace]] or in the [[Atom 0.3 namespace]] :
[FIG(steps)[
= [86] Let [VAR[entry]] be the result of [[processing an Atom entry][process an Atom entry]]
[VAR[child]].
= [85] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [258] [[Cleanup entry][cleanup entry]] [VAR[entry]].
= [87] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
]FIG]
= [25] Return [VAR[feed]].
]FIG]

[301] To [DFN[process an rss element]] [VAR[element]], run these steps:
[FIG(steps)[
= [239] Let [VAR[feed]] be a [[feed]].
= [240] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [302] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[channel]] element in the [[null namespace]] :
[[Process an RSS 2.0 channel][process an RSS 2.0 channel]] [VAR[element]] with [VAR[feed]].
: [CODE(XMLe)@en[item]] element in the [[null namespace]] :
[FIG(steps)[
= [242] Let [VAR[entry]] be the result of [[processing an RSS 2.0 item][process an RSS 2.0 item]]
[VAR[child]].
= [243] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [259] [[Cleanup entry][cleanup entry]] [VAR[entry]].
= [244] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
]FIG]
= [245] Return [VAR[feed]].
]FIG]

[207] To [DFN[process an RDF element]] [VAR[element]], run these steps:
[FIG(steps)[
= [238] Let [VAR[feed]] be a [[feed]].
= [210] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [236] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[channel]] element in the [[RSS namespace]] :
[[Process an RSS 1.0 channel][process an RSS 1.0 channel]] [VAR[element]] with [VAR[feed]].
: [CODE(XMLe)@en[item]] element in the [[RSS namespace]] :
[FIG(steps)[
= [237] Let [VAR[entry]] be the result of [[processing an RSS 1.0 item][process an RSS 1.0 item]]
[VAR[child]].
= [241] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [260] [[Cleanup entry][cleanup entry]] [VAR[entry]].
= [303] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
: [CODE(XMLe)@en[image]] element in the [[RSS namespace]] :
[FIG(steps)[
= [305] If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]]:
== [306] Let [VAR[element]] be [VAR[child]]'s first [CODE(XMLe)@en[url]] child element
in the [[RSS namespace]].
== [307] If [VAR[element]] is not [[null]]:
=== [40] Set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[element]].
]FIG]
]FIG]
= [304] Return [VAR[feed]].
]FIG]

[206] To [DFN[process an RSS 2.0 channel]] [VAR[element]] with [[feed]] [VAR[feed]], 
run these steps:
[FIG(steps)[
= [208] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [209] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[image]] element in the [[null namespace]] :
[FIG(steps)[
= [211] If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]]:
== [213] Let [VAR[element]] be [VAR[child]]'s first [CODE(XMLe)@en[url]] child element
in the [[null namespace]].
== [214] If [VAR[element]] is not [[null]]:
=== [37] Set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[element]].
]FIG]
: [CODE(XMLe)@en[image]] element in the [[iTunes namespace]] :
[FIG(steps)[
= [366] If [VAR[feed]]'s [F[logo URL][feed's logo URL]] is [[null]]:
== [367] Let [VAR[text]] be [VAR[child]]'s [CODE(XMLa)@en[href]] attribute value.
== [368] If [VAR[text]] is not [[null]] or the [[empty string]]:
=== [370] [[Parse][parse a URL]] [VAR[text]] relative to [VAR[child]]'s [F[node document]].
=== [369] If not failed, set [VAR[feed]]'s [F[logo URL][feed's logo URL]] to the [[resulting URL string]].
]FIG]
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[author]] element in the [[iTunes namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[managingEditor]] element in the [[null namespace]] :
Append the result of [[processing an RSS 2.0 person][process an RSS 2.0 person]] [VAR[child]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[pubDate]] or [CODE(XMLe)@en[lastBuildDate]] element in the [[null namespace]]:
If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]],
set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing an RSS 2.0 date][process an RSS 2.0 date]] [VAR[child]].
: [CODE(XMLe)@en[title]] element in the [[null namespace]] :
If [VAR[feed]]'s [F[title][feed's title]] is [[null]],
set [VAR[feed]]'s [F[title][feed's title]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[subtitle]] element in the [[iTunes namespace]] :
If [VAR[feed]]'s [F[subtitle][feed's subtitle]] is [[null]],
set [VAR[feed]]'s [F[subtitle][feed's subtitle]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[description]] element in the [[null namespace]] :
If [VAR[feed]]'s [F[description][feed's description]] is [[null]],
set [VAR[feed]]'s [F[description][feed's description]] to
[VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[summary]] element in the [[iTunes namespace]] :
If [VAR[feed]]'s [F[description][feed's description]] is [[null]],
set [VAR[feed]]'s [F[description][feed's description]] to
[VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[link]] element in the [[null namespace]] :
If [VAR[feed]]'s [F[logo URL][feed's page URL]] is [[null]],
set [VAR[feed]]'s [F[logo URL][feed's page URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[feed]], with [VAR[type]] [CODE[feed]].
: [CODE(XMLe)@en[item]] element in the [[null namespace]] :
[FIG(steps)[
= [147] Let [VAR[entry]] be the result of [[processing an RSS 2.0 item][process an RSS 2.0 item]]
[VAR[child]].
= [148] Set [VAR[entry]]'s [F[feed][entry's feed]] to [VAR[feed]].
= [261] [[Cleanup entry][cleanup entry]] [VAR[entry]].
= [149] Append [VAR[entry]] to [VAR[feed]]'s [F[entries][feed's entry]].
]FIG]
]FIG]
]FIG]

[311] To [DFN[process an RSS 1.0 channel]] [VAR[element]] with [[feed]] [VAR[feed]], 
run these steps:
[FIG(steps)[
= [312] For each [[element]] [VAR[child]] in [VAR[element]]'s [F[children]], in order,
run these substeps:
== [313] Switch by [VAR[child]]'s [F[namespace]] and [F[local name]]:
[FIG(switch)[
: [CODE(XMLe)@en[description]] element in the [[RSS namespace]] :
If [VAR[feed]]'s [F[description][feed's description]] is [[null]],
set [VAR[feed]]'s [F[description][feed's description]] to
[VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[creator]] element in the [[Dublin Core namespace]] :
Append a [[person]] whose [F[name]] is [VAR[element]]'s [F[child text content]]
to [VAR[feed]]'s [F[authors][feed's author]].
: [CODE(XMLe)@en[date]] element in the [[Dublin Core namespace]]:
If [VAR[feed]]'s [F[updated][feed's updated]] is [[null]],
set [VAR[feed]]'s [F[updated][feed's updated]] to the result of
[[processing a W3C-DTF date][process a W3C-DTF date]] [VAR[child]].
: [CODE(XMLe)@en[title]] element in the [[RSS namespace]] :
If [VAR[feed]]'s [F[title][feed's title]] is [[null]],
set [VAR[feed]]'s [F[title][feed's title]] to [VAR[child]]'s [F[child text content]].
: [CODE(XMLe)@en[link]] element in the [[RSS namespace]] :
If [VAR[feed]]'s [F[logo URL][feed's page URL]] is [[null]],
set [VAR[feed]]'s [F[logo URL][feed's page URL]] to the result of
[[processing a URL element][process a URL element]] [VAR[child]].
: [CODE(XMLe)@en[link]] element in the [[Atom namespace]] :
[[Process an Atom link]] [VAR[child]] for [VAR[feed]], with [VAR[type]] [CODE[feed]].
]FIG]
]FIG]

* References

[43] The key word [DFN[[MUST[MUST]]]] is defined by [[RFC 2119]].

[34] The terms [DFN[[[ASCII digits]]]] and [DFN[[[URL record]]]] 
are defined by the [[URL Standard]].

[42] The terms [DFN[[[MIME type]]]], [DFN[[[computed MIME type]]]],
[DFN[[F[type]]]], and
[DFN[[[parse a MIME type]]]] are defined by the [[MIME Sniffing Standard]].

[41] The terms [DFN[[[response]]]], [DFN[[[status][status code]]]],
[DFN[[[url][response's url]]]], and [DFN[[[network error]]]]
are defined by the [[Fetch Standard]].

[26] The interfaces [DFN[[CODE(DOMi)@en[Node]]]] and
[DFN[[CODE(DOMi)@en[DocumentFragment]]]] are defined by the [[DOM Standard]].

[31] The terms [DFN[[F[parent]]]], [DFN[[F[children]]]], [DFN[[[inclusive descendant]]]],
[DFN[[[insert]]]], [DFN[[[remove]]]], [DFN[[[clone]]]],
[DFN[[F[local name]]]], [DFN[[F[namespace]]]], and
[DFN[[F[node document]]]] are defined by the [[DOM Standard]].

[23] The terms
[DFN[[[XML MIME type]]]],
[DFN[[[Unicode code point]]]], [DFN[[[space characters]]]], [DFN[[[ASCII case-insensitive]]]],
[DFN[[[parse a URL]]]], [DFN[[[resulting URL string]]]], [DFN[[[resulting URL string]]]],
[DFN[[[rules for parsing non-negative integers]]]],
[DFN[[F[document's address]]]], [DFN[[F[document's character encoding]]]],
[DFN[[[palpable content]]]], [DFN[[[embedded content]]]],
[DFN[[F[child text content]]]],
[DFN[[F[input byte stream]]]],
[DFN[[[HTML fragment parsing algorithm]]]], [DFN[[[HTML parser]]]], and [DFN[[[XML parser]]]]
are defined by the [[HTML Standard]].

[32] The [DFN[[CODE(HTMLe)@en[div]]]] and [DFN[[CODE(HTMLe)@en[img]]]]
elements are defined by the [[HTML Standard]].