[22] [DFN[[[SOCKS]]]] は、 [[TCP]] [[アプリケーション]]のための[[トンネル]]化[[プロトコル]]です。
[[防火壁]]等を越えて [[HTTP]] その他の[[アプリケーション層プロトコル]]で通信するために使います。

[54] [[SOCKS]] は [[TCP]] の上位層、[[アプリケーション層プロトコル]]の下位層として動作します。

* 仕様書

[REFS[
- [9] [CITE[SOCKS: A protocol for TCP proxy across firewalls]] ([TIME[2002-04-03 17:26:00 +09:00]] 版) <http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol>
- [14] [CITE[SOCKS 4A: A  Simple Extension to SOCKS 4 Protocol]] ([TIME[2012-04-12 19:29:58 +09:00]] 版) <http://www.openssh.com/txt/socks4a.protocol>
- [6] [CITE@en[RFC 1928 - SOCKS Protocol Version 5]] ([TIME[2015-08-02 14:17:13 +09:00]] 版) <https://tools.ietf.org/html/rfc1928>
- [7] [CITE[RFC Errata Report]] ([TIME[2015-09-11 18:57:28 +09:00]] 版) <https://www.rfc-editor.org/errata_search.php?rfc=1928>
- [76] [CITE[Service Name and Transport Protocol Port Number Registry]] ([TIME[2015-09-17 07:18:22 +09:00]] 版) <https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=socks>
- [75] [CITE[SOCKS Methods]] ([TIME[2014-01-31 02:45:14 +09:00]] 版) <https://www.iana.org/assignments/socks-methods/socks-methods.xhtml>
- [8] [CITE@en[RFC 1929 - Username/Password Authentication for SOCKS V5]] ([TIME[2015-07-26 16:21:40 +09:00]] 版) <https://tools.ietf.org/html/rfc1929>
- [10] [CITE@en[RFC 1961 - GSS-API Authentication Method for SOCKS Version 5]] ([TIME[2015-06-21 17:56:54 +09:00]] 版) <https://tools.ietf.org/html/rfc1961>
]REFS]

* 版

[67] [[SOCKS]] には 4、4A、5 の3つの版があります。

[68] 最初に普及したのが 4 で、それに[[ドメイン名]]対応を追加したのが 4A
です。

[69] [[IETF]] で改めて作られたのが 5 です。

[71] [[クライアント]]は 4、4A、5 のいずれを使うべきか事前の知識なく決めることができません。
この意味で版間の互換性がありません。

[70] [[サーバー]]は 4/4A と 5 のいずれであるかを受信内容から区別できます。
4 と 4A のいずれであるかも実用上は区別できます。つまり[[サーバー]]はすべての版を同時に実装可能です。

;; [72] [[IETF]] ではよくあることですが、 [[IETF]] 
の[[専門家]]好みのスタイルに[[プロトコル]]が魔改造された結果互換性が無くなり、
旧版から新版への移行が進まず、かといって新版が無視されるわけでもなく、
新旧両版が十数年以上も併用され続けています。

[FIG(table)[

:v:版
:ipv4:[[IPv4]]
:ipv6:[[IPv6]]
:domain:[[ドメイン名]]
:auth:[[認証]]

:v:4
:ipv4:○
:ipv6:×
:domain:×
:auth:名前

:v:4A
:ipv4:○
:ipv6:×
:domain:○
:auth:名前

:v:5
:ipv4:○
:ipv6:○
:domain:○
:auth:認証なし、[[GSSAPI]]、[[名前]]と[[合言葉]]

]FIG]

* SOCKS 4 / 4A

[19] [[SOCKS]] 4 には [CODE[[[CONNECT]]]] と [CODE[[[BIND]]]] の2つの[RUBYB[操作]@en[operation]]があります [SRC[>>9]]。

[21] [[要求]]には次の欄があります。

[FIG(list members)[
:[CODE[[[VN]]]]: 最初のバイトはプロトコルの版番号で、 [CODE[4]] とするべきです [SRC[>>9]]。
:[CODE[[[CD]]]]: 第2バイトは[RUBYB[命令符号]@en[command code]]で、
[CODE[[[CONNECT]]]] では [CODE[1]] とするべきで、
[CODE[[[BIND]]]] では [CODE[2]] としなければなりません [SRC[>>9]]。
:[CODE[[[DSTPORT]]]]: その次の2バイト [SRC[>>9]] は[[ポート番号]]です。
:[CODE[[[DSTIP]]]]: その次の4バイト [SRC[>>9]] は[[IPアドレス]]です。
:[CODE[[[USERID]]]]: その次の任意の長さのバイト列は userid とします [SRC[>>9]]。
:[CODE[[[NULL]]]]: 最後の1バイトは [CODE[0]] とします [SRC[>>9]]。
:[[ドメイン名]]: [[SOCKS]] 4A では、更に任意の長さの[[ドメイン名]]を含められる場合があります [SRC[>>14]]。
:[CODE[[[NULL]]]]: [[ドメイン名]]がある場合、その次の1バイトは [CODE[0]] とします [SRC[>>14]]。
]FIG]

[FIG(packet)[
:width:32

= 8 VN
= 8 CD
= 16 DSTPORT
= 32 DSTIP
= 56... USERID
= 8 NULL
= 56... ドメイン名
= 8 NULL
]FIG]

[32] 明記されていませんが、 [CODE[[[USERID]]]] や[[ドメイン名]]に [[NULL]]
は含められないと思われます。 [CODE[[[USERID]]]] や[[ドメイン名]]を空 (長さ0)
にすることも禁止はされていません。

[49] [[SOCKS]] 4 では、 USERID の後の NULL までで終わりでした。
[[SOCKS]] 4A では、 [CODE[[[DSTIP]]]] の先頭3バイトをすべて [CODE[0]]、
最終バイトを非 [CODE[0]] とすることで、[[ドメイン名]]とその終端の [[NULL]] 
を使うことができます [SRC[>>14]]。

[50] [CODE[[[DSTIP]]]] の先頭3バイトが [CODE[0]]、最終バイトが非 [CODE[0]]
の時、 [[IPアドレス]]ではなく、[[ドメイン名]]の指定によることを表します [SRC[>>14]]。

;; [51] 明記されていませんが、[[ドメイン名]]は [CODE[.]] で区切られた[[ラベル]]の列と思われます。
時代的に [[ASCII]] のみの[[ドメイン名]]が期待されていると思われますが、
[[非ASCII文字]]をどう扱うべきなのかは定かではありません。

;; [52] 0.0.0.* の * は 0 以外のどの値にしても良いようですが、
その選択に意味はなさそうです。

[37] 返答パケットには次の欄があります [SRC[>>9]]。

[FIG(list members)[
:[[VN]]: 最初の1バイトは、返答符号の版とします。 [CODE[[[0]]]] とするべきです [SRC[>>9]]。
:[[CD]]: 次の1バイトは、結果符号とします [SRC[>>9]]。
:[CODE[[[DSTPORT]]]]: その次の2バイト [SRC[>>9]] は[[ポート番号]]です。
:[CODE[[[DSTIP]]]]: その次の4バイト [SRC[>>9]] は[[IPアドレス]]です。
]FIG]

[FIG(packet)[
:width:32

= 8 VN
= 8 CD
= 16 DSTPORT
= 32 DSTIP
]FIG]

[26] 結果符号は、次のいずれかです [SRC[>>9]]。
[FIG(list)[
- [CODE[[[90]]]] は、要求を受け入れたことを表します。
- [CODE[[[91]]]] は、要求を拒絶または失敗したことを表します。
- [CODE[[[92]]]] は、[[クライアント]]の [[identd]] に接続できなかったために要求を拒絶したことを表します。
- [CODE[[[93]]]] は、[[クライアント]]と [[identd]] が異なる user-id を報告したために要求を拒絶したことを表します。
]FIG]

[48] 明記されていませんが、[[ネットワークバイト順]]と思われます。

[53] [CODE[[[VN]]]] や [CODE[[[CD]]]] が未知の値や相対外の文脈だった時にどう扱うべきかは定かではありません。

** [CODE[CONNECT]] 操作

[20] [[クライアント]]は、他のホストに接続したい時、 [[SOCKS]] [[サーバー]]に接続して、
[CODE[[[CONNECT]]]] [[要求]]を送信します [SRC[>>9]]。

[31] [CODE[[[DSTIP]]]] は[[終点]]の [[IPアドレス]]
(または[[ドメイン名]]の指定があることを表す値 [SRC[>>14]])、
[CODE[[[DSTPORT]]]] は[[終点]]の[[ポート番号]]とします [SRC[>>9]]。

[23] [[サーバー]]は、 [CODE[[[CONNECT]]]] [[要求]]を受信したら、
受け付けるかどうかを次の情報の一部または全部を使って検査します [SRC[>>9]]。
[FIG(list)[
- [[始点]] [[IPアドレス]]
- [[終点]] [[IPアドレス]]
- [[終点]][[ポート番号]]
- [[userid]]
- [[RFC 1413]] [[IDENT]] により得られる情報
]FIG]

[24] [[サーバー]]は、要求を受け付ける場合には、
指定された[[終点]]のホストとポートに接続します [SRC[>>9]]。

[25] [[サーバー]]は、接続が確立されたら、
または拒絶する時や操作が失敗した時は、
返答パケットを送信します [SRC[>>9]]。

[38] 返答パケットの [CODE[[[DSTIP]]]] と [CODE[[[DSTPORT]]]] は、無視します [SRC[>>9]]。

;; [39] サーバーが何を設定するべきなのかは明らかではありません。

[27] [[サーバー]]は失敗または拒絶を通知したら、直ちに[[接続]]を閉じます [SRC[>>9]]。

[45] 一定時間 (例えば2分) 経過後接続が確立できていなければ、
断念して[[クライアント]]との接続も閉じます [SRC[>>9]]。

;; [46] その場合も返答パケットは送信するべきと思われますが、不明瞭です。

[28] 要求を受け入れた場合は、以後送受信を中継します [SRC[>>9]]。

** [CODE[BIND]] 操作

[29] [[クライアント]]は、他のホストからの接続を受け付けたい時、
[[SOCKS]] [[サーバー]]に接続して [CODE[[[BIND]]]]
要求を送信します [SRC[>>9]]。

;; [30] 任意のホストに対するアプリケーションサービスの提供を想定しているのではなく、
[CODE[[[CONNECT]]]] で主たる接続を確立済みの同じアプリケーションでサーバーからクライアントへと補助的な接続を確立する
(のを待ち受ける) ためのもののようです。

[33] [CODE[[[DSTIP]]]] はアプリケーションサーバーの [[IPアドレス]]
(または[[ドメイン名]]の指定があることを表す値 [SRC[>>14]])、
[CODE[[[DSTPORT]]]] は主たる接続の[[ポート番号]]とします [SRC[>>9]]。

;; [34] つまり [CODE[[[CONNECT]]]] 要求で指定した[[終点]]です。

[35] [[サーバー]]は、[[クライアント]]の情報により、
受け付けるかどうか決定します [SRC[>>9]]。

[36] [[サーバー]]は、受け付ける場合も受け付けない場合も、
返答パケットを送信します [SRC[>>9]]。

[40] 受け入れる場合 ([CODE[[[CD]]]] = [CODE[[[90]]]]) は、
[[サーバー]]は接続を待ち受けることとし、その[[IPアドレス]]と[[ポート番号]]を返答パケットの 
[CODE[[[DSTIP]]]] と [CODE[[[DSTPORT]]]] にそれぞれ設定します [SRC[>>9]]。

[41] [CODE[[[DSTIP]]]] が [CODE[[[0]]]] ([CODE[[[INADDR_ANY]]]])
の場合、[[クライアント]]は、[[SOCKS]] [[サーバー]]の
[[IPアドレス]]とみなすべきです [SRC[>>9]]。

[42] それ以外の場合は [CODE[[[DSTIP]]]] と [CODE[[[DSTPORT]]]] は無視されます [SRC[>>9]]。

[43] [[サーバー]]が待ち受けるアドレスに接続があると、
次のようにします。
[FIG(steps)[
= 接続元の[[ホスト]]と [CODE[[[BIND]]]] 要求の [CODE[[[DSTIP]]]] が一致すれば、
== 返答パケットを[[クライアント]]に送信します。 [CODE[[[CD]]]] は [CODE[[[90]]]] とします。
== 以後両接続間の送受信を中継します。
= それ以外なら、
== 返答パケットを[[クライアント]]に送信します。 [CODE[[[CD]]]] は [CODE[[[91]]]] とします。
== 両接続とも、切断します。
]FIG]

[44] 一定時間 (例えば2分) 経過後接続が確立できていなければ、
断念して[[クライアント]]との接続も閉じます [SRC[>>9]]。

;; [47] その場合も返答パケットは送信するべきかもしれませんが、不明瞭です。

* ポート番号

[77] [[TCP]] と [[UDP]] の[[ポート番号]] [DFN[[CODE[[[1080]]]]]] は[[サービス]]
[DFN[[CODE[[[socks]]]]]] として [[IANA登録簿]]に登録されています。
説明は「Socks」となっています。 [SRC[>>76]]

;; [78] 明らかに [[SOCKS]] のことを指しているのでしょうが、
[[IANA登録簿]]には明記されていません。

* URL scheme

[74] [[プロキシ]]の指定などで [[URL]] を指定する時に、次の [[URL scheme]]
が用いられます。

[FIG(short list)[
- [CODE(URI)@en[[[socks:]]]]
- [CODE(URI)@en[[[socks4:]]]]
- [CODE(URI)@en[[[socks4a:]]]]
- [CODE(URI)@en[[[socks5:]]]]
- [CODE(URI)@en[[[socks5h:]]]]
]FIG]

* PAC

[73] [[PAC]] では次の値が使われています。
[FIG(short list)[
- [CODE@en[[[SOCKS]]]]
- [CODE@en[[[SOCKS4]]]]
- [CODE@en[[[SOCKS5]]]]
]FIG]

* 実装

[FIG[
[FIGCAPTION[
[1] [CITE[AnyEvent::HTTP::Socks - search.cpan.org]] ([TIME[2012-04-25 09:51:27 +09:00]] 版) <http://search.cpan.org/~oleg/AnyEvent-HTTP-Socks-0.04/lib/AnyEvent/HTTP/Socks.pm>
]FIGCAPTION]

[PRE(URI code)[
  "socks4://10.0.0.1:1080  socks5://root:123@10.0.0.2:1080  socks4a://85.224.100.1:9010"
]PRE]
]FIG]

[FIG[
[FIGCAPTION[
[3] [CITE[AnyEvent::HTTP::Socks - search.cpan.org]] ([TIME[2012-04-25 09:51:27 +09:00]] 版) <http://search.cpan.org/~oleg/AnyEvent-HTTP-Socks-0.04/lib/AnyEvent/HTTP/Socks.pm>
]FIGCAPTION]

[PRE(URI code)[
  http_get 'http://www.google.com/', socks => 'socks5://localhost:1080', sub {
]PRE]
]FIG]

[4] [CITE[LWP::Protocol::socks - search.cpan.org]]
([TIME[2010-01-20 18:01:04 +09:00]] 版)
<http://search.cpan.org/~scr/LWP-Protocol-socks-1.1/lib/LWP/Protocol/socks.pm>

[FIG[
[FIGCAPTION[
[5] [CITE[SSH: プロキシ設定の定義]] ([TIME[2011-12-14 03:32:52 +09:00]] 版) <http://www.ssh.com/manuals/client-user/43J/firewall.html>
]FIGCAPTION]

> プロキシサーバのアドレスを入力します SOCKSプロキシのためのアドレス形式は次のとおりです。
[PRE(URI code)[
socks://username@socks_server:port/network/netmask,network/netmask...
]PRE]
>
プロキシサーバ設定の例: 
[PRE(URI code)[
socks://socks.ssh.com:1080/203.123.0.0/16,198.74.23.0/24
]PRE]
]FIG]

* メモ

[2] [CITE@ja[SOCKS - Wikipedia]]
( ([TIME[2011-12-10 16:21:00 +09:00]] 版))
<http://ja.wikipedia.org/wiki/SOCKS>

[13] [CITE@en[SOCKS - Wikipedia, the free encyclopedia]] ([TIME[2015-09-05 01:05:46 +09:00]] 版) <https://en.wikipedia.org/wiki/SOCKS>

[11] [CITE@en[RFC 3089 - A SOCKS-based IPv6/IPv4 Gateway Mechanism]] ([TIME[2015-07-26 16:11:34 +09:00]] 版) <https://tools.ietf.org/html/rfc3089>

[12] [CITE@en[draft-ietf-aft-socks-chap-01 - Challenge-Handshake Authentication Protocol for SOCKS V5]] ([TIME[2015-07-20 00:36:46 +09:00]] 版) <https://tools.ietf.org/html/draft-ietf-aft-socks-chap-01>

[15] [CITE[IO::Socket::Socks - search.cpan.org]]
([TIME[2015-09-11 19:05:59 +09:00]] 版)
<http://search.cpan.org/dist/IO-Socket-Socks/lib/IO/Socket/Socks.pm>

[16] [CITE@ja[第 15 章 SOCKS の使用]]
([TIME[2010-12-30 01:42:14 +09:00]] 版)
<https://docs.oracle.com/cd/E19438-01/819-3160/agsocks.html>

[17] [CITE@en[Socks Proxy - Free Socks5 and Socks4 Proxy List]]
([TIME[2015-09-11 19:32:04 +09:00]] 版)
<http://www.socks-proxy.net/>

[18] >>17 によれば 5 が多いですが、 4 (4 か 4a かは不明。) もまだまだ使われているようです。
[TIME[2015-09-11T10:11:54.200Z]]

[FIG(quote)[
[FIGCAPTION[
[55] [CITE[cURL - How To Use]]
([TIME[2015-09-04 03:05:03 +09:00]] 版)
<http://curl.haxx.se/docs/manpage.html>
]FIGCAPTION]

> Since 7.21.7, this option is superfluous since you can specify a socks5 hostname proxy with -x, --proxy using a socks5h:// protocol prefix.

]FIG]


[FIG(quote)[
[FIGCAPTION[
[56] [CITE[cURL - How To Use]]
([TIME[2015-09-04 03:05:03 +09:00]] 版)
<http://curl.haxx.se/docs/manpage.html>
]FIGCAPTION]

> As part of the GSS-API negotiation a protection mode is negotiated. RFC 1961 says in section 4.3/4.4 it should be protected, but the NEC reference implementation does not. The option --socks5-gssapi-nec allows the unprotected exchange of the protection mode negotiation. (Added in 7.19.4).

]FIG]


[57] [CITE@en[122752 – SOCKS: Username/Password Authentication (V5)]]
([TIME[2015-09-14 23:33:41 +09:00]] 版)
<https://bugzilla.mozilla.org/show_bug.cgi?id=122752>

[58] [CITE@en[280661 – SOCKS proxy server connection timeout hard-coded]]
([TIME[2015-09-14 23:34:24 +09:00]] 版)
<https://bugzilla.mozilla.org/show_bug.cgi?id=280661>

[59] [CITE@en[16103 – SOCKS V5 Implementation]]
([TIME[2015-09-14 23:38:28 +09:00]] 版)
<https://bugzilla.mozilla.org/show_bug.cgi?id=16103>

[60] [CITE@en[133939 – ''''''[''''''RFE'''''']'''''' SOCKS: cannot use kerberos v5 (GSS-API) authentication with]]
([TIME[2015-09-14 23:40:17 +09:00]] 版)
<https://bugzilla.mozilla.org/show_bug.cgi?id=133939>

[61] [CITE@en[78176 – PAC: SOCKS return value is not version specific]]
([TIME[2015-09-14 23:43:16 +09:00]] 版)
<https://bugzilla.mozilla.org/show_bug.cgi?id=78176>

[62] [CITE[Configuring a SOCKS proxy server in Chrome - The Chromium Projects]]
([TIME[2015-09-14 19:33:20 +09:00]] 版)
<https://www.chromium.org/developers/design-documents/network-stack/socks-proxy>

[63] [CITE[Issue 29914 - chromium - DNS queries not forwarded through SOCKS v5 proxies - An open-source project to help move the web forward. - Google Project Hosting]]
([TIME[2015-09-14 23:51:54 +09:00]] 版)
<https://code.google.com/p/chromium/issues/detail?id=29914>

[64] [CITE[Issue 469 - chromium - Support SOCKS proxy - An open-source project to help move the web forward. - Google Project Hosting]]
([TIME[2015-09-14 23:58:17 +09:00]] 版)
<https://code.google.com/p/chromium/issues/detail?id=469>

[FIG(quote)[
[FIGCAPTION[
[65] [CITE@en[''''''[''''''chrome'''''']'''''' Contents of /trunk/src/net/socket/socks_client_socket.cc]]
([TIME[2015-09-15 00:02:58 +09:00]] 版)
<http://src.chromium.org/viewvc/chrome/trunk/src/net/socket/socks_client_socket.cc>
]FIGCAPTION]

> 
> 303	    // Resolving the hostname failed; fail the request rather than automatically
> 304	    // falling back to SOCKS4a (since it can be confusing to see invalid IP
> 305	    // addresses being sent to the SOCKS4 server when it doesn't support 4A.)

]FIG]


[FIG(quote)[
[FIGCAPTION[
[66] [CITE[net/socket/socks_client_socket.cc - Issue 113811: Adding socks4 support for chromium. tested for windows and linux.... - Code Review]]
([TIME[2015-09-15 00:10:29 +09:00]] 版)
<https://codereview.chromium.org/113811/diff/11012/net/socket/socks_client_socket.cc>
]FIGCAPTION]

> 
>  210   if (ok) {
>  211     DCHECK(addresses_.head());
>  212 
>  213     // If the host is resolved to an IPv6 address, we revert to SOCKS4a
>  214     // since IPv6 is unsupported by SOCKS4/4a protocol.
>  215     struct sockaddr *host_info = addresses_.head()->ai_addr;
>  216     if (host_info->sa_family == AF_INET) {
>  217       DLOG(INFO) << "Resolved host. Using SOCKS4 to communicate";
>  218       socks_version_ = kSOCKS4;
>  219     } else {
>  220       DLOG(INFO) << "Resolved host but to IPv6. Using SOCKS4a to communicate";
>  221       socks_version_ = kSOCKS4a;
>  222     }
>  223   } else {
>  224     DLOG(INFO) << "Could not resolve host. Using SOCKS4a to communicate";
>  225     socks_version_ = kSOCKS4a;
>  226   }

]FIG]

[79] [CITE@en[draft-ietf-aft-socks-cram-00 - Challenge-Response Authentication Method for SOCKS V5]]
([TIME[2015-07-23 13:33:45 +09:00]] 版)
<https://tools.ietf.org/html/draft-ietf-aft-socks-cram-00>

[80] [CITE@en[draft-ietf-aft-socks-ssl-00 - Secure Sockets Layer for SOCKS Version 5]]
([TIME[2015-07-20 17:44:24 +09:00]] 版)
<https://tools.ietf.org/html/draft-ietf-aft-socks-ssl-00>

[81] [CITE@en[draft-ietf-aft-socks-maf-01 - Multi-Authentication Framework Method for SOCKS V5]]
([TIME[2015-07-20 17:49:20 +09:00]] 版)
<https://tools.ietf.org/html/draft-ietf-aft-socks-maf-01>

[82] [CITE[Dante - Documentation]]
([TIME[2015-08-27 23:18:16 +09:00]] 版)
<https://www.inet.no/dante/doc/>

[FIG(quote)[
[FIGCAPTION[
[83] ([TIME[2015-09-17 23:56:16 +09:00]] 版)
<http://www.novell.com/documentation/nbm39/administration/data/b7qgmq8.html>
]FIGCAPTION]

> None: No authentication. However, data is encrypted if the Secure Sockets Layer (SSL) option is also selected.
> Clear Text User/Password: During Novell IP Gateway user authentication, the user’s password is transmitted across the wire in clear text without encryption. The password is checked against the password stored in NDS, but this is not the same as NDS authentication. However, if SSL is also selected, the password is encrypted before being sent.
> NDS User/Password: The user is authenticated using the NDS username and password with a scheme that protects the secrecy of the password. However, data is not encrypted unless the SSL option is also selected. This option works only if the SOCKS 5 client software supports NDS authentication.
> SSL: The SSL option requires that an SSL connection between the client and the server be established before the Novell IP Gateway can authenticate a user by using any of the other authentication schemes. Enabling this option also ensures the encryption of all data transmitted between the client and the server.
> Key ID: If you select the SSL authentication scheme, you must also select a Key ID from the drop-down list. At least one Key ID must be created for the server in NDS prior to the selection of SSL. Novell Public Key Infrastructure (PKI) Services must be installed on your server.

]FIG]
