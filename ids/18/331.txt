[1] [[CGI]] の[DFN[[RUBYB[要求データ]@en[request data]]]]は、[[HTTP]]
[[要求]]の[[メッセージ本体]]を[[鯖]]から[[CGIスクリプト]]に伝達する手段です。

* 仕様書
[REFS[
- [14] [CITE@en[RFC 3875 - The Common Gateway Interface (CGI) Version 1.1]]
-- [2] '''<http://tools.ietf.org/html/rfc3875#section-4.2>'''
-- [15] <http://tools.ietf.org/html/rfc3875#section-4.3.2>
]REFS]

* 処理モデル

[3] [[要求データ]]へのアクセス方法は[[システム定義]]ですが、別途定義されていない場合、
「[[標準入力]]」[[ファイル記述子]]/[[ファイル・ハンドル]]によって読み取れることになっています [SRC[>>2]]。

[4] [[要求データ]]は、 [CODE(CGI)@en[[[CONTENT_LENGTH]]]] の長さの[[メッセージ本体]]のデータと、
更にその後に続く余分なデータで構成されます。 [SRC[>>2]]

[5] [CODE(CGI)@en[[[CONTENT_LENGTH]]]] が[[NULL]]でない場合は[[メッセージ本体]]がその長さ分提供されます。
[[鯖]]は最低でもその長さのデータを[[CGIスクリプト]]が読み取れるようにしなければ[['''なりません''']]。
[SRC[>>2]]

[6] [[鯖]]はその後に[[EOF]]を続けても構いませんし、更に別のデータを続けても構いません。
[[CGIスクリプト]]はたとえそのような余分なデータがあったとしても、それを読もうとしては[['''なりません''']]。
[SRC[>>2]]

[7] なお、[[CGIスクリプト]]はまったくデータを読まなくても[['''構いません''']]。 [SRC[>>2]]

;; [8] なぜ意味も無い余分なデータの存在を認めているのかは明記されていませんが、
データのやりとりに使う[[バッファ]]の類の管理の都合上、その方が良い場合もあるでしょうから、
それが不適切な実装とならないような配慮でしょうか。ただ 
[[CGIスクリプト]]が正確に動作することに依存した実装は一般的には安全ではありませんね。

[9] [[NPHスクリプト]]に関しては、データは[[鯖]]が変更せずにそのままにして渡す[['''べきです''']]。 [SRC[>>2]]

;; [10] これは >>11 も適用されないということなのでしょうか。

[11] [[鯖]]は[[転送符号化]]を除去して [CODE(CGI)@en[[[CONTENT_LENGTH]]]] はそれを反映したものとしなければ[['''なりません''']]。
バッファ・サイズ等の理由でそれが不可能な場合は[[要求]]を[[誤り]]として拒絶する[['''べきです''']]。
[SRC[>>2]]

;; [18] [CODE(HTTP)@en[[[HTTP_TRANSFER_ENCODING]]]] の値をどうするべきかは不明瞭です。

[12] [[鯖]]は[[内容符号化]]を除去しても[['''構いません''']]。 [SRC[>>2]]
その場合も [CODE(CGI)@en[[[CONTENT_LENGTH]]]] にそれを反映させる必要があります。

;; [17] その場合 [CODE(HTTP)@en[[[HTTP_CONTENT_ENCODING]]]] も変更する必要があると思われますが、明記されていません。

[13] [[鯖]]は[[NPHスクリプト]]以外では[[文字コード]]や[[MIME型]]の変換を適宜行なってから
[[CGIスクリプト]]に引き渡して構わないと考えられます。

[16] [[CGIスクリプト]]は[[要求データ]]を読み込む前に [CODE(CGI)@en[[[CONTENT_LENGTH]]]]
をチェックしなければ[['''なりません''']]。また [CODE(CGI)@en[[[CONTENT_TYPE]]]]
もチェックする[['''べきです''']]。 [SRC[>>15]]

;; [19] [[HTTP]] 仕様上は[[サーバー]]は[[クライアント]]が[[要求]]の全体を送信し終える前に処理を開始しても構わないことになっていますが、
[[CGI]] (やその規定を流用するサーバー側 API の実装) を使う場合には、
[[CGIスクリプト]]が処理を開始できるのは[[サーバー]]が[[要求]]の全体を受信し、
[CODE(CGI)@en[[[CONTENT_LENGTH]]]] が確定した後になります。

;; [20] [CODE(HTTP)@en[[[Content-Length:]]]] [[ヘッダー]]が[[要求]]に含まれる場合でも、
当該 [[HTTP接続]]が[[要求]]の途中で切断された場合に [[CGIスクリプト]]が[[標準入力]]を読めることを保証するため[[要求]]全体が到着するのを待って
[[CGIスクリプト]]を起動するか、あるいは[[CGIスクリプト]]がすべて読ま(め)ずに[[標準入力]]が閉じられることを許容するかの選択を迫られることになります。
[[RFC]] 上はこの場合をどう扱うべきか不明です。

* 派生仕様における要求データ

[21] [[CGI]] から派生した仕様も、[[CGI]] の仕様を引きずっています。

[22] [[PSGI]] では、[[標準入力]]に相当する[[ファイルハンドル]]風[[オブジェクト]]が
[CODE[$env]] に含まれており、[[PSGIアプリケーション]]はそこから [CODE[CONTENT_LENGTH]]
分読み込むことが期待されています。

* 制約

[23] [[要求データ]]の長さを [CODE(CGI)@en[CONTENT_LENGTH]] [[メタ変数]]として[[アプリケーション][CGIスクリプト]]に引き渡さなければならないという制約のため、
[[サーバー][HTTPサーバー]]は[[要求データ]]の長さが確定するまで[[アプリケーション][CGIスクリプト]]を起動できません。
