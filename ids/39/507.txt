[SEE[ [[ISO/IEC 2022]] ]]

* ISO/IEC 2022 Decoder

[1] A [DFN[state]] is:

[FIG(list members)[

: [DFN[[F[C0 designated]]]] : [[C0 set]] or [I[unknown-control]].
Initially, the [[initial C0 set]].
: [DFN[[F[2/0 designated]]]] : [CODE(charname)@en[SP]] or [CODE(charname)@en[MSP]].
Initially, [CODE(charname)@en[SP]].
: [DFN[[F[7/15 designated]]]] : [CODE(charname)@en[DEL]].
: [DFN[[F[C1 designated]]]] : [[C1 set]] or [I[unknown-control]].
Initially, the [[empty C1 set]].
: [DFN[[F[10/0 designated]]]] : [CODE(charname)@en[MSP]] or 
[[character]] ([I[unknown-byte]], [[10/0]]).
Initially, [[character]] ([I[unknown-byte]], [[10/0]]).
: [DFN[[F[15/15 designated]]]] : 
[[Character][character]] ([I[unknown-byte]], [[15/15]]).
: [DFN[[F[G0 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G1 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G2 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G3 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[bits]]]] : [I[8-bit]] or [I[7-bit]].
Initially, [I[8-bit]].
: [DFN[[F[MARC-8 flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[VT response flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[F[Tektronix 4014 flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[GL invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GR invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[current byte sequence]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[current element]]]] : [[C element]] or [[G element]].
: [DFN[[F[current size]]]] : [N[94]] or [N[96]].
: [DFN[[F[current bytes]]]] : [N[1]], [N[2]], or [N[3]].
: [DFN[[F[current I byte]]]] : [[Byte][byte]].
: [DFN[[F[current J byte]]]] : [[Byte][byte]] or [CODE[null]].
: [DFN[[F[PCD PM]]]] : [[Byte][byte]].
: [DFN[[F[PCD PI]]]] : [[Byte][byte]].
: [DFN[[F[PCD LI]]]] : Non-negative integer.
: [DFN[[F[PCD data]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[decoder state]]]] : One of [[decoder states][decoder state]].
Initially, [[initial state]].

]FIG]

[223] A [DFN[C element]] is [I[C0]] or [I[C1]].

[100] A [DFN[G element]] is [I[G0]], [I[G1]], [I[G2]], or [I[G3]].

[117] A [DFN[maximum sequence length]] is an implementation-specific integer,
e.g. [N[15]].

[94] A [DFN[maximum chunk length]] is an implementation-specific integer,
e.g. 2[SUP[30]] - 1.


[315] 
To [DFN[get invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [302] If [VAR[element]] is [CODE[null]]:
== [303] Return [I[unknown-96]].
= [304] Otherwise, if [VAR[element]] is [I[G0]]:
== [305] Return [VAR[state]]'s [F[G0 designated]].
= [306] Otherwise, if [VAR[element]] is [I[G1]]:
== [307] Return [VAR[state]]'s [F[G1 designated]].
= [308] Otherwise, if [VAR[element]] is [I[G2]]:
== [309] Return [VAR[state]]'s [F[G2 designated]].
= [310] Otherwise, if [VAR[element]] is [I[G3]]:
== [311] Return [VAR[state]]'s [F[G3 designated]].
]FIG]

** Input stream

@@

[20] A [[state initialization steps]] is a set of zero or more steps
that modifies [VAR[state]].  It [MAY[MAY]] modify [VAR[state]] in these ways:

- [21] Modify values of [VAR[state]]'s 
[F[C0 designated]],
[F[2/0 designated]],
[F[7/15 designated]],
[F[C1 designated]],
[F[10/0 designated]],
[F[15/15 designated]],
[F[G0 designated]],
[F[G1 designated]],
[F[G2 designated]],
[F[G3 designated]],
[F[bits]],
[F[MARC-8 flag]],
[F[Tektronix 4014 flag]],
[F[VT response flag]],
[F[GL invoked]],
and/or
[F[GR invoked]].


@@
[VAR[input stream]],
[VAR[initialization steps]] a [[state initialization steps]],
run these steps:

[FIG(steps)[
= [8] Let [VAR[state]] be a new [[state]].
= [9] Run [VAR[initialization steps]] with [VAR[state]].
= [6] 
Let [VAR[output stream]] be a [[list]].
[NOTE[
[97] [VAR[output stream]] might contain
[[characters][character]],
[[PCD data]],
and
[[EOF]].
]NOTE]
= [10] 
@@
Process the input stream,
a sequence of zero or more [[bit combinations][bit combination]]
= [7] 
Return [VAR[output stream]].
]FIG]


** Output stream

@@

[4] 
To [DFN[emit a character]] with [[character]] [VAR[char]], run these steps:

[FIG(steps)[
= 
[5] 
[[Append][append]]
[VAR[char]]
to 
[VAR[output stream]].
]FIG]

[115] 
To [DFN[emit a sequence]]  with [[character string]] [VAR[seq]], run these steps:

[FIG(steps)[
=
[116] 
[[Extend][extend]]
[VAR[output stream]]
with 
[VAR[seq]].
]FIG]

[95] 
To [DFN[emit a PCD data]] with [[byte]] [VAR[PM]], [[byte]] [VAR[PI]], 
[[byte sequence]] [VAR[data]], run these steps:

[FIG(steps)[
=
[96] 
[[Append][append]]
a new [[PCD data]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[picture mode]]: [VAR[PM]]
:[F[picture identifier]]: [VAR[PI]]
:[F[picture data entity]]: [VAR[data]]
]FIG]

]FIG]


[355] 
When [DFN[error]], run these steps:

[FIG(steps)[
= [356] An error [MAY[may]] be reported to a [[developer console]].
= [153] [[Emit a character][emit a character]] [CODE[U+FFFD]].
]FIG]

;; [386] There is an illegal sequence.

[58] 
When [DFN[deprecated]], run these steps:

[FIG(steps)[
= [59] A warning [MAY[may]] be reported to a [[developer console]].
]FIG]

;; [385] There is a sequence that is discouraged by a relevant specification,
or that is an extension to the ISO/IEC 2022 standard.


@@[DFN[reconsume]]

@@



** Decoder states

[27] 
The decoder has several [DFN[decoder states]] for processing input 
[[bit combinations][bit combination]].

[719] 
To [DFN[process a control [[character]]]] [VAR[char]], run these steps:

[FIG(steps)[

= [29] If [VAR[char]] is [CODE(charname)@en[ESC]]:
== [30] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].
= [211] Otherwise, if [VAR[char]] is [CODE(charname)@en[LS0]]:
== [209] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].
= [210] Otherwise, if [VAR[char]] is [CODE(charname)@en[LS1]]:
== [212] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [213] Otherwise, if [VAR[char]] is [CODE(charname)@en[SS2]]:
== [226] Set [VAR[state]]'s [F[current element]] to [I[G2]].
== [214] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [215] Otherwise, if [VAR[char]] is [CODE(charname)@en[SS3]]:
== [227] Set [VAR[state]]'s [F[current element]] to [I[G3]].
== [216] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [685] Otherwise, if [VAR[char]] is 
a [[character]] ([I[tektronix]], [I[esc]], [N[0/3]]):
== [686] Set [VAR[state]]'s [F[Tektronix 4014 flag]] to [[false]].
== [718] Set [VAR[state]]'s [F[C1 designated]] to the [[VT C1 set]].
= [31] Otherwise:
== [13] [[Emit][emit a character]] [VAR[char]].
]FIG]


-*-*-

[2] There are the following [[decoder states][decoder state]]:

*** Initial state

[3] The [DFN[initial state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[1/15]] ] :
[FIG(steps)[

= [11] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
= [658] If [VAR[set]] is [I[unknown-control]]:
== [659] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].
== [660] [[Emit][emit a character]]
a [[character]] ([I[unknown-byte]], [VAR[bc]]).
= [661] Otherwise:
== [717] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [314] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [507] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]]:
== [318] [[Emit a character][emit a character]] [VAR[state]]'s [F[2/0 designated]].
= [317] Otherwise, if [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[7/15]]:
== [327] [[Emit a character][emit a character]] [VAR[state]]'s [F[7/15 designated]].
= [422] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [440] Set [VAR[state]]'s [F[decoder state]] to [I[left unassigned state]].
== [441] [[Reconsume][reconsume]] [VAR[bc]].
= [424] Otherwise:
== [448] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [185] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bc]] ].
== [450] Otherwise:
=== [451] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
=== [487] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [452] Set [VAR[state]]'s [F[decoder bytes]] to [I[left leading byte state]].

]FIG]
: [ [N[8/0]], [N[9/15]] ] :
[FIG(steps)[

= [26] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [672] If [VAR[set]] is [I[unknown-control]]:
== [673] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].
== [37] [[Emit][emit a character]]
a [[character]] ([I[unknown-byte]], [VAR[bc]]).
= [675] Otherwise:
== [28] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [334] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [312] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]]:
== [333] [[Emit a character][emit a character]] [VAR[state]]'s [F[10/0 designated]].
= [319] Otherwise, if [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[15/15]]:
== [342] [[Emit a character][emit a character]] [VAR[state]]'s [F[15/15 designated]].
= [313] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [423] Set [VAR[state]]'s [F[decoder state]] to [I[right unassigned state]].
== [430] [[Reconsume][reconsume]] [VAR[bc]].
= [431] Otherwise:
== [432] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [471] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [473] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
== [474] Otherwise:
=== [475] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [490] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [476] Set [VAR[state]]'s [F[decoder bytes]] to [I[right leading byte state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]


*** SS state

[217] The [DFN[SS state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[2/0]], [[7/15]] ], [ [[10/0]], [[15/15]] ]:
[FIG(steps)[

= [344] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [343] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [345] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [346] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [528] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [349] [[Error][error]].
== [354] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [364] [[Reconsume][reconsume]] [VAR[bc]].
= [444] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [271] [[Error][error]].
== [438] Set [VAR[state]]'s [F[decoder state]] to [I[SS unassigned state]].
== [442] [[Reconsume][reconsume]] [VAR[bc]].
= [447] Otherwise:
== [272] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [316] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [326] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
=== [443] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [329] Otherwise:
=== [332] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [341] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [347] Set [VAR[state]]'s [F[decoder bytes]] to [I[SS leading byte state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [357] [[Error][error]].
= [359] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [358] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Left leading byte state

[482] The [DFN[left leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [495] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [320] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [323] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [324] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [325] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [328] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [330] [[Reconsume][reconsume]] [VAR[bc]].
= [321] Otherwise:
== [496] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [331] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
=== [498] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [336] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [499] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [502] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [503] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
=== [504] Otherwise:
==== [335] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]].
==== [501] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [337] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [492] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [493] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [494] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [483] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [485] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Right leading byte state

[338] The [DFN[right leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [339] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [340] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [421] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [426] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [427] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [428] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [429] [[Reconsume][reconsume]] [VAR[bc]].
= [433] Otherwise:
== [434] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [436] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [437] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [453] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [454] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [455] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [456] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [457] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [458] Otherwise:
==== [459] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [461] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [462] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [464] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [465] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [466] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [467] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [468] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** SS leading byte state

[469] The [DFN[SS leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ], [ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [470] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [525] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [526] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [527] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [477] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [478] [[Error][error]].
== [479] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [480] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [481] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [486] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [488] [[Reconsume][reconsume]] [VAR[bc]].
= [489] Otherwise:
== [491] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [505] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [506] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [509] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [510] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [511] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [512] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [513] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [514] Otherwise:
==== [515] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [517] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [518] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [519] [[Error][error]].
= [520] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [521] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [522] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [523] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [524] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Left unassgined state

[446] The [DFN[left unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [536] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [532] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [533] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [534] [[Reconsume][reconsume]] [VAR[bc]].
= [535] Otherwise:
== [531] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [529] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [530] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Right unassgined state

[537] The [DFN[right unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [538] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [539] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [540] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [541] [[Reconsume][reconsume]] [VAR[bc]].
= [542] Otherwise:
== [543] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]] & [N[0b01111111]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [544] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [545] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** SS unassigned state

[546] The [DFN[SS unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [547] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [548] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [549] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [550] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [551] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [552] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [553] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [554] [[Reconsume][reconsume]] [VAR[bc]].
= [555] Otherwise:
== [556] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [559] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [560] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [561] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [562] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [563] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [564] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [565] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [566] [[Reconsume][reconsume]] [VAR[bc]].
= [567] Otherwise:
== [568] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [557] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [558] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape state

[32] The [DFN[escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[


:[ [N[0/0]], [N[1/15]] ]:
[FIG(steps)[

= [204] If [VAR[state]]'s [F[Tektronix 4014 flag]] is [[true]]:
== [205] Let [VAR[set]] be the [[Tektronix 4014 escape C0 set]].
== [720] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [225] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] ].
= [206] Otherwise:
== [207] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
== [208] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
== [224] [[Reconsume][reconsume]] [VAR[bc]].



]FIG]
: [N[2/0]] :
[FIG(steps)[

= [136] Set [VAR[state]]'s [F[decoder state]] to [I[escape announce state]].

]FIG]
: [N[2/1]] :
[FIG(steps)[

= [218] Set [VAR[state]]'s [F[current element]] to [I[C0]].
= [157] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/2]] :
[FIG(steps)[

= [230] Set [VAR[state]]'s [F[current element]] to [I[C1]].
= [158] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/3]] :
[FIG(steps)[

= [388] Set [VAR[state]]'s [F[decoder state]] to [I[escape 3 state]].

]FIG]
: [N[2/4]] :
[FIG(steps)[

= [598] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple state]].

]FIG]
: [[2/5]] :
[FIG(steps)[

@@

]FIG]
: [[2/6]] :
[FIG(steps)[

@@

]FIG]
: [[2/8]] :
[FIG(steps)[

= [104] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [294] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [105] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/9]] :
[FIG(steps)[

= [111] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [168] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [170] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/10]] :
[FIG(steps)[

= [169] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [235] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [295] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/11]] :
[FIG(steps)[

= [234] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [296] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [297] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/12]] :
[FIG(steps)[

= [279] [[Deprecated][deprecated]].
= [277] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [278] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [281] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/13]] :
[FIG(steps)[

= [280] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [283] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [285] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/14]] :
[FIG(steps)[

= [282] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [298] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [299] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/15]] :
[FIG(steps)[

= [284] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [300] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [301] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
:[ [[3/0]], [[3/15]] ], [[6/0]], [[6/1]], [[6/3]], [[6/5]], [[6/6]], [[6/8]], [[6/9]], [[7/1]], [[7/2]], [ [[7/4]], [[7/11]] ]:
[FIG(steps)[

= [35] [[Emit a character][emit a character]]
([I[escape]], [VAR[bc]]).
= [40] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[4/0]], [N[5/15]] ]:
[FIG(steps)[

= [36] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [676] If [VAR[set]] is [I[unknown-control]]:
== [677] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].
== [679] [[Emit][emit a character]]
a [[character]] ([I[unknown-byte]], [VAR[bc]] + [N[0x40]]).
= [680] Otherwise:
== [39] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [38] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] + [N[0x40]] ].


]FIG]
: [N[6/2]] :
[FIG(steps)[

= [41] If [VAR[state]]'s [F[MARC-8 flag]] is [[true]]:
== [49] 
Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with 
[N[94]], [I[escape]], [VAR[bc]].
= [42] Otherwise:
== [43] [[Emit a character][emit a character]]
([I[escape]], [VAR[bc]]).
= [44] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[6/4]] :
[FIG(steps)[

= [48] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
: [[6/7]], [[7/3]] :
[FIG(steps)[

= [273] Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with 
[N[94]], [I[escape]], [VAR[bc]].

]FIG]
: [[6/11]] :
[FIG(steps)[

= [55] [[Deprecated][deprecated]].
= [118] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [119] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [120] Otherwise:
== [52] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
: [[6/12]] :
[FIG(steps)[

= [56] [[Deprecated][deprecated]].
= [121] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [122] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [123] Otherwise:
== [53] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
: [[6/13]] :
[FIG(steps)[

= [57] [[Deprecated][deprecated]].
= [124] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [125] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [126] Otherwise:
== [54] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
: [[6/14]] :
[FIG(steps)[

= [60] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].

]FIG]
: [[6/15]] :
[FIG(steps)[

= [61] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].

]FIG]
: [[7/0]] :
[FIG(steps)[

= [62] If [VAR[state]]'s [F[MARC-8 flag]] is [[true]]:
== [63]  
Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with 
[N[94]], [I[escape]], [VAR[bc]].
== [66] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [64] Otherwise:
== [65] Set [VAR[state]]'s [F[decoder state]] to [I[PCD state]].

]FIG]
: [[7/12]] :
[FIG(steps)[

= [127] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [128] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [129] Otherwise:
== [101] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
: [[7/13]] :
[FIG(steps)[

= [130] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [131] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [132] Otherwise:
== [102] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
: [[7/14]] :
[FIG(steps)[

= [133] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [134] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [135] Otherwise:
== [103] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
: Otherwise :
[FIG(steps)[

= [33] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
= [34] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [156] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape announce state

[137] The [DFN[escape announce state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[N[3/6]], [N[3/7]]:
[FIG(steps)[

= [387] [[Deprecated][deprecated]].
= [381] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[4/1]], [N[7/14]] ]:
[FIG(steps)[

= [138] Let [VAR[announce]] be [VAR[bc]] - 0x40.
= [139] If [VAR[announce]] is one of:
[N[1]],
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [140] Set [VAR[state]]'s [F[GL invoked]] be [I[G0]].
= [141] If [VAR[announce]] is [N[1]] or [N[2]]:
== [142] Set [VAR[state]]'s [F[GR invoked]] be [CODE[null]].
= [143] If [VAR[announce]] is one of:
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [144] Set [VAR[state]]'s [F[GR invoked]] be [I[G1]].
= [145] If [VAR[announce]] is one of:
[N[12]],
[N[13]],
or
[N[14]]:
== [146] Set [VAR[state]]'s [F[2/0 designated]] be [CODE(charname)@en[SP]].
== [147] Set [VAR[state]]'s [F[7/14 designated]] be [CODE(charname)@en[DEL]].
= [148] If [VAR[announce]] is one of:
[N[11]],
[N[12]],
[N[13]],
or
[N[14]]:
== [149] Set [VAR[state]]'s [F[bits]] be [I[8-bit]].
= [150] If [VAR[announce]] is [N[10]]:
== [151] Set [VAR[state]]'s [F[bits]] be [I[7-bit]].
= [380] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [152] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/0]].
= [155] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [154] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape 3 state

[389] The [DFN[escape 3 state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/15]] ]:
[FIG(steps)[

= [397] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [398] Set [VAR[state]]'s [F[decoder state]] to [I[escape ctext version state]].

]FIG]
:[ [N[3/0]], [N[3/9]] ]:
[FIG(steps)[

= [396] [[Emit a character][emit a character]]
([I[vt]], [N[2/3]], [VAR[bc]]).
= [390] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [392] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/3]].
= [394] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [395] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape ctext version state

[399] The [DFN[escape ctext version state]] switches by the [[bit combination]] 
[VAR[bc]]:

[FIG(switch)[

: [N[3/0]] :
[FIG(steps)[

= [401] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[3/1]] :
[FIG(steps)[

= [400] [[Error][error]].
= [403] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [404] [[Error][error]].
= [405] Set [VAR[state]]'s [F[current byte sequence]] to 
[N[2/3]] followed by [VAR[state]]'s [F[current I byte]].
= [407] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [408] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape control state

[159] The [DFN[escape control state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [164] Set [VAR[state]]'s [F[C0 designated]] to the result of 
[[getting a C0 set][get a C0 set]] [VAR[bc]].
= [232] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [233] Set [VAR[state]]'s [F[C1 designated]] to the result of 
[[getting a C1 set][get a C1 set]] [VAR[bc]].
= [382] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [713] Set [VAR[state]]'s [F[C0 designated]] to the [[empty C0 set]].
= [167] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [714] Set [VAR[state]]'s [F[C1 designated]] to the [[empty C1 set]].
= [162] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape graphic state

[236] The [DFN[escape graphic state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/3]] ]:
[FIG(steps)[

= [254] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [255] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [237] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [402] If [VAR[state]]'s [F[current size]] is [N[94]] and [VAR[bc]] is [N[3/1]]:
=== [410] [[Emit a character][emit a character]]
([I[vt]], [N[2/8]], [VAR[bc]]).
== [411] Otherwise:
=== [238] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [239] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [412] If [VAR[state]]'s [F[current size]] is [N[94]] and [VAR[bc]] is [N[3/1]]:
=== [413] [[Emit a character][emit a character]]
([I[vt]], [N[2/9]], [VAR[bc]]).
== [414] Otherwise:
=== [240] Set [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [286] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [287] Set [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [288] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [417] If [VAR[state]]'s [F[current size]] is [N[96]]:
=== [418] [[Emit a character][emit a character]]
([I[vt]], [N[2/15]], [VAR[bc]]).
== [419] Otherwise:
=== [289] Set [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [383] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [415] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [416] Let [VAR[set]] be [I[unknown-96]].
= [166] Otherwise:
== [241] Let [VAR[set]] be [I[unknown-94]].
= [242] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [243] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [244] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [160] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [246] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [161] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [248] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [165] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [251] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [252] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape graphic I state

[253] The [DFN[escape graphic I state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [257] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [256] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [258] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [259] Let [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [290] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [291] Let [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [292] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [293] Let [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [384] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [247] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [249] Let [VAR[set]] be [I[unknown-96]].
= [250] Otherwise:
== [260] Let [VAR[set]] be [I[unknown-94]].
= [261] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [262] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [263] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [264] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [265] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [266] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [267] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [268] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [269] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [270] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape multiple state

[599] The [DFN[escape multiple state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/8]] :
[FIG(steps)[

= [606] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [607] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [608] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/9]] :
[FIG(steps)[

= [609] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [610] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [611] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/10]] :
[FIG(steps)[

= [612] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [613] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [614] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/11]] :
[FIG(steps)[

= [618] [[Deprecated][deprecated]].
= [619] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [620] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [621] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/12]] :
[FIG(steps)[

= [622] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [623] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [624] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/13]] :
[FIG(steps)[

= [625] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [626] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [627] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/14]] :
[FIG(steps)[

= [628] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [629] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [630] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [631] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [615] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [616] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [605] If [VAR[bc]] is ''not'' [N[4/0]], [N[4/1]], or [N[4/2]]:
== [636] [[Deprecated][deprecated]].
= [637] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[N[94]], [CODE[null]], [VAR[bc]].

]FIG]
: Otherwise :
[FIG(steps)[

= [601] Set [VAR[state]]'s [F[current byte sequence]] be [N[2/4]].
= [603] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [604] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape multiple graphic state

[617] The [DFN[escape multiple graphic state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/4]] ]:
[FIG(steps)[

= [632] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [633] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [634] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [635] If [VAR[state]]'s [F[current size]] is [N[94]] and 
[VAR[bc]] is [N[4/0]], [N[4/1]], or [N[4/2]]:
=== [636] [[Deprecated][deprecated]].
== [638] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [639] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [640] Set [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [641] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [642] Set [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [643] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [644] Set [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [645] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [245] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [322] Let [VAR[set]] be [I[unknown-96]].
= [362] Otherwise:
== [363] Let [VAR[set]] be [I[unknown-94]].
= [365] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [366] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [367] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [368] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [369] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [370] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [371] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [372] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [375] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [376] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape multiple graphic I state

[662] The [DFN[escape multiple graphic I state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [663] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [664] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [665] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [666] Let [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [667] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [668] Let [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [669] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [670] Let [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [671] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [377] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [378] Let [VAR[set]] be [I[unknown-96]].
= [379] Otherwise:
== [391] Let [VAR[set]] be [I[unknown-94]].
= [393] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [406] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [409] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [420] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [425] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [435] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [439] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [445] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [460] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [463] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape unassigned state

[106] The [DFN[escape unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [107] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [110] If [VAR[state]]'s [F[current byte sequence]]'s [F[length]]
is equal to the [[maximum sequence length]]:
== [500] [[Error][error]].
== [508] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [108] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [114] [[Emit][emit a character]] 
a [[character]] ([I[esc]], [VAR[state]]'s [F[current byte sequence]]).
= [109] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [472] [[Error][error]].
= [484] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [497] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape trailer state

[516] The [DFN[escape trailer state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [600] Do nothing.

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [602] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [647] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [646] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** PCD state

[67] The [DFN[PCD state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [68] Set [VAR[state]]'s [F[PCD PM]] to [VAR[bc]].
= [69] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PM state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PM state

[70] The [DFN[PCD PM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [71] Set [VAR[state]]'s [F[PCD PI]] to [VAR[bc]].
= [73] Set [VAR[state]]'s [F[PCD LI]] to [N[0]].
= [72] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PI state

[74] The [DFN[PCD PI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[10/0]], [[11/1]] ]:
[FIG(steps)[

= [75] Set [VAR[state]]'s [F[PCD LI]] to ([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [77] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@

]FIG]
:[ [[8/13]], [[9/14]] ]:
[FIG(steps)[

= [78] Set [VAR[state]]'s [F[PCD LI]] to 
([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [79] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@
= [87] Set [VAR[state]]'s [F[PCD data]] to the [[empty byte sequence]].
= [82] If [VAR[state]]'s [F[PCD LI]] is zero:
== [93] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [83] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [84] Otherwise:
== [80] Set [VAR[state]]'s [F[decoder state]] to [I[PCD LI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD LI state

[81] The [DFN[PCD LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [88] [[Append][append to a byte sequence]] [VAR[bc]] to [VAR[state]]'s [F[PCD data]].
= [76] Set [VAR[state]]'s [F[PCD LI]] to [VAR[state]]'s [F[PCD LI]] - 1.
= [85] If [VAR[state]]'s [F[PCD LI]] is zero:
== [92] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [86] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** Unassigned state

[50] The [DFN[unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [51] [[Emit][emit a character]]
a [[character]] ([VAR[unknown-byte]], [VAR[bc]]).

]FIG]
: [[EOF]] :
[FIG(steps)[

= [674] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [682] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

* Characters

[18] 
A [DFN[character]] is one of followings:

- [CODE(charname)@en[ESC]]
- [CODE(charname)@en[SP]]
- [CODE(charname)@en[MSP]]
- [CODE(charname)@en[DEL]]
- [CODE(charname)@en[LS0]]
- [CODE(charname)@en[LS1]]
- [CODE(charname)@en[SS2]]
- [CODE(charname)@en[SS3]]
- [CODE(charname)@en[DCS]]
- any other [[code point]]
- [[tuple]] ([I[escape]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- [[tuple]] ([I[esc]], [VAR[bytes]]), where [VAR[bytes]] is a [[byte sequence]]
- [[tuple]] ([I[unknown-byte]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- [[tuple]] ([I[C0]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- [[tuple]] ([I[C1]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- [[tuple]] ([I[94]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- [[tuple]] ([I[96]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- [[tuple]] ([I[94[SUP[2]]]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[2]]
- [[tuple]] ([I[96[SUP[2]]]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[2]]
- [[tuple]] ([I[94[SUP[3]]]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[3]]
- [[tuple]] ([I[vt]], [N[2/3]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/9]] ]
- [[tuple]] ([I[vt]], [N[2/8]], [N[3/1]])
- [[tuple]] ([I[vt]], [N[2/9]], [N[3/1]])
- [[tuple]] ([I[vt]], [N[2/15]], [VAR[bc]]), 
where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- [[tuple]] ([I[vt]], [I[C1]], [VAR[bc]]), 
where [VAR[bc]] is in [ [N[8/0]], [N[9/15]] ]
- [[tuple]] ([I[vt52]], [I[C1]], [VAR[bc]]), 
where [VAR[bc]] is in [ [N[8/0]], [N[9/15]] ]
- [[tuple]] ([I[tektronix]], [I[esc]], [VAR[bc]]), 
where [VAR[bc]] is in [ [N[0/0]], [N[1/15]] ]



;; [186] 
Interpretation of these [[tuples][tuple]] are application-specific.

[112] 
A [DFN[character string]] is a [[list]] of zero or more [[characters][character]].

[113] 
An [DFN[empty character string]] is a [[character string]] whose [[length]]
is [N[0]].


[98] 
A [DFN[PCD data]]
is a [[tuple]] consisting of:
[DFN[[F[picture mode]]]] ([[byte]]),
[DFN[[F[picture identifier]]]] ([[byte]]),
and
[DFN[[F[picture data]]]] ([[byte sequence]]).

@@
[99] 
[DFN[EOF]]



* Character sets

[17] 
A [DFN[character set]] is an [[ordered map]],
where [[keys][key]] are [[byte sequences][byte sequence]] and
[[values][value]] are a [[character]].

;; [575] By definition, there are no duplicate [[keys][key]].

[574] 
A [[character set]] [VAR[set]] [DFN[has 1-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
[VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1.

[576] 
A [[character set]] [VAR[set]] [DFN[has 2-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[2]].

[577] 
A [[character set]] [VAR[set]] [DFN[has 3-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[3]].

[171] 
To [DFN[get a 1-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [172] Let [VAR[set]] be a new [[character set]].
= [173] [[For each]] [VAR[c]] in [ [VAR[start]], [VAR[end]] ]:
== [174] Let [VAR[set]] [ [VAR[c]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[c]]).
= [175] Return [VAR[set]].

]FIG]


[583] 
To [DFN[get a 2-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [584] Let [VAR[set]] be a new [[character set]].
= [585] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [586] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [589] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]].
=== [587] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [588] Return [VAR[set]].

]FIG]


[590] 
To [DFN[get a 3-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [591] Let [VAR[set]] be a new [[character set]].
= [592] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [593] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [594] [[For each]] [VAR[c3]] in [ [VAR[start]], [VAR[end]] ]:
==== [595] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]] followed by [VAR[c3]].
==== [596] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [597] Return [VAR[set]].

]FIG]


[22] 
A [DFN[C0 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[0/0]], [N[1/15]] ].

[176] 
To [DFN[get a C0 set]] [VAR[F]], run these steps:

[FIG(steps)[

= [652] If [VAR[F]] is ''not'' in [ [N[4/0]], [N[7/14]] ]:
== [653] Return [I[unknown-c0]].
== [654] Abort these steps.
= [177] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[0/0]], [[1/15]], [I[C0]], and [VAR[F]].
= [180] If [VAR[F]] is ''not'' [[7/14]]:
== [178] Set [VAR[set]] [ [[1/11]] ] to [CODE(charname)@en[ESC]].
= [187] If [VAR[F]] is one of:
[[4/1]] ([[ISO-IR]] 1),
[[4/3]] ([[ISO-IR]] 26),
[[4/4]] ([[ISO-IR]] 36),
[[4/6]] ([[ISO-IR]] 74),
[[4/11]] ([[ISO-IR]] 135),
[[4/12]] ([[ISO-IR]] 140),
[[4/5]] ([[ISO-IR]] 106),
[[4/8]] ([[ISO-IR]] 130),
or
[[4/10]] ([[ISO-IR]] 134):
== [188] Set [VAR[set]] [ [[0/14]] ] to [CODE(charname)@en[LS1]].
== [189] Set [VAR[set]] [ [[0/15]] ] to [CODE(charname)@en[LS0]].
= [190] If [VAR[F]] is [[4/4]] ([[ISO-IR]] 36):
== [191] Set [VAR[set]] [ [[1/12]] ] to [CODE(charname)@en[SS2]].
= [192] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 106),
[[4/9]] ([[ISO-IR]] 132),
[[4/10]] ([[ISO-IR]] 134),
or 
[[4/12]] ([[ISO-IR]] 135):
== [193] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
== [193] Set [VAR[set]] [ [[1/14]] ] to [CODE(charname)@en[SS3]].
= [194] If [VAR[F]] is [[4/12]] ([[ISO-IR]] 140):
== [195] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
= [179] Return [VAR[set]].

]FIG]

[19] 
The [DFN[initial C0 set]] is the result of running these steps:

[FIG(steps)[

= [648] Let [VAR[set]] be a new [[character set]].
= [649] [[For each]] [VAR[c]] in [ [N[0/0]], [N[1/15]] ]:
== [650] Let [VAR[set]] [ [VAR[c]] ] be
a [[character]] ([I[unknown-byte]], [VAR[c]]).
= [687] Set [VAR[set]] [ [N[1/11]] ] to [CODE(charname)@en[ESC]].
= [651] Return [VAR[set]].

]FIG]

[228] The [DFN[Tektronix 4014 escape C0 set]] is the result of running these steps:

[FIG(steps)[

= [229] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[0/0]], [[1/15]], [I[tektronix]], [I[esc]].
= [681] Return [VAR[set]].

]FIG]

[23] 
A [DFN[C1 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[8/0]], [N[9/15]] ].

[25] 
To [DFN[get a C1 set]] [VAR[F]], run these steps:

[FIG(steps)[

= [655] If [VAR[F]] is ''not'' in [ [N[4/0]], [N[7/14]] ]:
== [656] Return [I[unknown-c1]].
== [657] Abort these steps.
= [181] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[C1]], [VAR[F]].
= [196] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 40),
[[4/3]] ([[ISO-IR]] 77),
or
[[4/7]] ([[ISO-IR]] 105):
== [197] Set [VAR[set]] [ [[8/14]] ] to [CODE(charname)@en[SS2]].
== [198] Set [VAR[set]] [ [[8/15]] ] to [CODE(charname)@en[SS3]].
= [182] Return [VAR[set]].

]FIG]

[24] 
The [DFN[empty C1 set]] is the result of 
[[getting a C1 set][get a C1 set]] [[7/14]].

[683] 
The [DFN[VT C1 set]] is the result of running these steps:

[FIG(steps)[

= [684] Let [VAR[set]] be a new [[character set]].
= [199] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[vt]], [I[C1]].
= [688] Set [VAR[set]] [ [N[8/14]] ] to [CODE(charname)@en[LS1]].
= [689] Set [VAR[set]] [ [N[8/15]] ] to [CODE(charname)@en[LS0]].
= [715] Set [VAR[set]] [ [N[9/0]] ] to [CODE(charname)@en[DCS]].
= [716] Return [VAR[set]].

]FIG]

[200] 
The [DFN[VT52 C1 set]] is the result of running these steps:

[FIG(steps)[

= [201] Let [VAR[set]] be a new [[character set]].
= [202] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[vt52]], [I[C1]].
= [203] Return [VAR[set]].

]FIG]


[45] 
A [DFN[G set]] is 
[[94 set]], [[96 set]],
[[94[SUP[2]] set]], [[96[SUP[2]] set]],
or
[[94[SUP[3]] set]].

[578] 
A [DFN[94 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/1]], [N[7/14]] ].

[579] 
A [DFN[96 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/0]], [N[7/15]] ].

[580] 
A [DFN[94[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/1]], [N[7/14]] ].

[581] 
A [DFN[96[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/0]], [N[7/15]] ].

[582] 
A [DFN[94[SUP[3]] set]] is a [[character set]]
that [[has 3-byte range]] [ [N[2/1]], [N[7/14]] ].


[374] 
To determine whether [DFN[is 96 size]] [VAR[set]], run these steps:

[FIG(steps)[

= [569] If [VAR[set]] is [I[unknown-96]], return [[true]].
= [570] Otherwise, if [VAR[set]] is a [[96 set]], return [[true]].
= [373] Otherwise, if [VAR[set]] is a [[96[SUP[2]] set]], return [[true]].
= [571] Otherwise, return [[false]].

]FIG]

[348] 
To determine [[character set]] [VAR[set]]'s [DFN[byte length]],
run these steps:

[FIG(steps)[

= [350] If [VAR[set]] is a [[94 set]] or [[96 set]]:
== [351] Return [N[1]].
= [352] Otherwise, if [VAR[set]] is a [[94[SUP[2]] set]] or [[96[SUP[2]] set]]:
== [353] Return [N[2]].
= [360] Otherwise, if [VAR[set]] is a [[94[SUP[3]] set]]:
== [361] Return [N[3]].

]FIG]


[46] 
To [DFN[get a graphic set]] with 
[VAR[size]], [VAR[I]], and [VAR[F]], run these steps:

[FIG(steps)[

= [47] If 
[VAR[size]] is [N[94]],
[VAR[I]] is [I[escape]], and 
[VAR[F]] is [[7/3]]:
== [275] Return the result of
[[getting a graphic set][get a graphic set]] with
[N[94]], [CODE[null]], [[4/2]].
[NOTE[
This is [[MARC-8]]'s [[ASCII]].
]NOTE]
== [276] Abort these steps.
= [220] If [VAR[I]] is ''not'' [CODE[null]]:
== [221] Let [VAR[f]] be [VAR[I]] followed by [VAR[F]].
= [222] Otherwise:
== [219] Let [VAR[f]] be [VAR[F]].
= [696] If [VAR[size]] is [N[94]]:
== [183] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [[2/1]], [[7/14]], [N[94]], [VAR[f]].
= [697] Otherwise, if [VAR[size]] is [N[96]]:
== [698] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [[2/0]], [[7/15]], [N[96]], [VAR[f]].
= [184] Return [VAR[set]].

]FIG]

[NOTE[
[274] The following combinations of 
[VAR[size]], [VAR[I]], and [VAR[F]] are used:

- ([VAR[size]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [[3/0]], [[3/15]] ]
- ([VAR[size]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [[4/0]], [[7/13]] ]
- ([VAR[size]], [CODE[null]], [[7/14]]) where
[VAR[size]] is [N[94]] or [N[96]]
- ([VAR[size]], [[2/0]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [[3/0]], [[7/14]] ]
- ([VAR[size]], [VAR[I]], [VAR[F]]) where
[VAR[size]] is [N[94]] or [N[96]], 
[VAR[I]] is in [ [[2/1]], [[2/3]] ], and
[VAR[F]] is in [ [[3/0]], [[3/15]] ]
- ([VAR[size]], [VAR[I]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]],
[VAR[I]] is in [ [[2/1]], [[2/3]] ], and
[VAR[F]] is in [ [[4/0]], [[7/14]] ]
- ([N[94]], [I[escape]], [[6/2]])
- ([N[94]], [I[escape]], [[6/7]])
- ([N[94]], [I[escape]], [[7/0]])
- ([N[94]], [I[escape]], [[7/3]])

]NOTE]

[678] 
To [DFN[get a multiple graphic set]] with 
[VAR[size]], [VAR[I]], and [VAR[F]], run these steps:

[FIG(steps)[

= [690] If [VAR[I]] is ''not'' [CODE[null]]:
== [691] Let [VAR[f]] be [VAR[I]] followed by [VAR[F]].
= [692] Otherwise:
== [693] Let [VAR[f]] be [VAR[F]].
= [694] If [VAR[F]] is in [ [N[4/0]], [N[4/15]] ]:
== [699] If [VAR[size]] is [N[94]]:
=== [700] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [[2/1]], [[7/14]], 94[SUP[2]], [VAR[f]].
== [701] Otherwise, if [VAR[size]] is [N[96]]:
=== [702] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [[2/0]], [[7/15]], 96[SUP[2]], [VAR[f]].
= [695] Otherwise, if [VAR[F]] is in [ [N[5/0]], [N[5/15]] ]:
== [704] If [VAR[size]] is [N[94]]:
=== [705] Let [VAR[set]] be the result of [[getting a 3-byte set][get a 3-byte set]] 
with [[2/1]], [[7/14]], 94[SUP[3]], [VAR[f]].
== [706] Otherwise, if [VAR[size]] is [N[96]]:
=== [707] Let [VAR[set]] be [I[unknown-96]].
= [708] Otherwise:
== [709] If [VAR[size]] is [N[94]]:
=== [710] Let [VAR[set]] be [I[unknown-94]].
== [711] Otherwise, if [VAR[size]] is [N[96]]:
=== [712] Let [VAR[set]] be [I[unknown-96]].
= [703] Return [VAR[set]].

]FIG]



* Definitions

[14] 
This document depends on the [CITE[Infra Standard]].

[15] 
The terms
[DFN[for each][For each]],
[DFN[boolean]],
[DFN[byte]],
[DFN[byte sequence]],
[DFN[[F[length]]]],
[DFN[code point]],
[DFN[tuple]],
[DFN[list]],
[DFN[[F[size]]]],
[DFN[append]],
[DFN[extend]],
[DFN[ordered map]],
[DFN[entry]],
[DFN[key]],
and
[DFN[value]]
are defined by the [CITE[Infra Standard]].


-*-*-

[572] 
A [DFN[range]] [VAR[range]] is a [[tuple]] of two integers 
([DFN[[F[start]]]], [DFN[[F[end]]]]),
where [VAR[range]]'s [F[start]] ≦ [VAR[range]]'s [F[end]].
It represents a set of all the integers [VAR[i]]
that satisfies [VAR[range]]'s [F[start]] ≦ [VAR[i]] ≦ [VAR[range]]'s [F[end]].

[573] 
A value [VAR[i]] is in a [[range]] [VAR[range]] if 
[VAR[i]] is an item in the set represented by [VAR[range]].

@@ switch

-*-*-


[16] 
A [DFN[bit combination]] is a [[byte]].
A [[bit combination]] is represented as "[VAR[X]]/[VAR[Y]]",
where [VAR[X]] and [VAR[Y]] are integers in [ [N[0]], [N[15]] ],
which represents a [[byte]] [VAR[X]] × [N[16]] + [VAR[Y]].

[89] 
To [DFN[append][append to a byte sequence]] a [[bit combination]] [VAR[bc]]
to a [[byte sequence]] [VAR[bytes]], run these steps:

[FIG(steps)[
= [90] Replace [VAR[bytes]]'s content by [VAR[bytes]] followed by [VAR[bc]].
]FIG]

[91] The [DFN[empty byte sequence]] is a [[byte sequence]] whose [[length]]
is [N[0]].


* Notes

@@macro code,
[[SCI]],
[[OSC]],
[[DCS]],
[[APC]]
