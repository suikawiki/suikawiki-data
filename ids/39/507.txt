[SEE[ [[ISO/IEC 2022]] ]]

* ISO/IEC 2022 Decoder

[1] A [DFN[state]] is:

[FIG(list members)[

: [DFN[[F[fixed set]]]] : [[Character set][character set]].
: [DFN[[F[escape set]]]] : [[Character set][character set]].
: [DFN[[F[94 final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[96 final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94[SUP[[VAR[n]]]] final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[96[SUP[[VAR[n]]]] final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94[SUP[[VAR[n]]]] final RL set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[C0 designated]]]] : [[C0 set]].  Initially, the [[initial C0 set]].
: [DFN[[F[C1 designated]]]] : [[C1 set]].  Initially, the [[empty C1 set]].
: [DFN[[F[G0 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G1 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G2 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G3 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G0 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G1 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G2 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G3 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[left designated]]]] : [[128 set]].
: [DFN[[F[right designated]]]] : [[128 set]].
: [DFN[[F[CR invoked]]]] : [[C element]].
Initially, [I[C1]].
: [DFN[[F[GL invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GR invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GL mode]]]] :
[I[iso2022]], [I[ascii]], or [I[single]].  Initially, [I[iso2022]].
: [DFN[[F[right mode]]]] :
[I[iso2022]], [I[utf-1]], [I[utf-8]],
[I[single]],
[I[sjis]], [I[sjis-2000]],
[I[big5]],
[I[uhc]], [I[johab]],
[I[gbk]], [I[gb18030]],
or
[I[x-moe-internal]].
Initially, [I[iso2022]].
: [DFN[[F[bits]]]] : [I[8-bit]] or [I[7-bit]].
Initially, [I[8-bit]].
: [DFN[[F[VT response flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[ISO 4873 Latin-1 flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[UTF-8 GL flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[current byte sequence]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[current element]]]] : [[C element]] or [[G element]].
: [DFN[[F[current size]]]] : [N[94]] or [N[96]].
: [DFN[[F[current bytes]]]] : [N[1]], [N[2]], or [N[3]].
: [DFN[[F[current I byte]]]] : [[Byte][byte]].
: [DFN[[F[current J byte]]]] : [[Byte][byte]] or [CODE[null]].
: [DFN[[F[current revision byte]]]] : [[Byte][byte]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[current PCD PM]]]] : [[Byte][byte]].
: [DFN[[F[current PCD PI]]]] : [[Byte][byte]].
: [DFN[[F[current segment length]]]] : Non-negative integer.
: [DFN[[F[current segment data]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[decoder state]]]] : One of [[decoder states][decoder state]].
Initially, [[initial state]].

]FIG]

[223] A [DFN[C element]] is [I[C0]] or [I[C1]].

[100] A [DFN[G element]] is [I[G0]], [I[G1]], [I[G2]], or [I[G3]].

[117] A [DFN[maximum sequence length]] is an implementation-specific integer,
e.g. [N[15]].

[94] A [DFN[maximum chunk length]] is an implementation-specific integer,
e.g. 2[SUP[30]] - 1.


[315] 
To [DFN[get invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [302] If [VAR[element]] is [CODE[null]]:
== [303] Return [I[unknown-96]].
= [304] Otherwise, if [VAR[element]] is [I[G0]]:
== [305] Return [VAR[state]]'s [F[G0 designated]].
= [306] Otherwise, if [VAR[element]] is [I[G1]]:
== [307] Return [VAR[state]]'s [F[G1 designated]].
= [308] Otherwise, if [VAR[element]] is [I[G2]]:
== [309] Return [VAR[state]]'s [F[G2 designated]].
= [310] Otherwise, if [VAR[element]] is [I[G3]]:
== [311] Return [VAR[state]]'s [F[G3 designated]].
]FIG]

[796] 
To [DFN[get RL invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [797] If [VAR[element]] is [CODE[null]]:
== [798] Return [I[unknown-94]].
= [799] Otherwise, if [VAR[element]] is [I[G0]]:
== [800] Return [VAR[state]]'s [F[G0 RL designated]].
= [801] Otherwise, if [VAR[element]] is [I[G1]]:
== [802] Return [VAR[state]]'s [F[G1 RL designated]].
= [803] Otherwise, if [VAR[element]] is [I[G2]]:
== [804] Return [VAR[state]]'s [F[G2 RL designated]].
= [805] Otherwise, if [VAR[element]] is [I[G3]]:
== [806] Return [VAR[state]]'s [F[G3 RL designated]].
]FIG]

** Input stream

@@

[20] A [[state initialization steps]] is a set of zero or more steps
that modifies [VAR[state]].  It can modify [VAR[state]] in these ways:

- [21] It [MAY[MAY]] modify values of [VAR[state]]'s 
[F[C0 designated]],
[F[C1 designated]],
[F[G0 designated]],
[F[G1 designated]],
[F[G2 designated]],
[F[G3 designated]],
[F[right designated]],
[F[G0 RL designated]],
[F[G1 RL designated]],
[F[G2 RL designated]],
[F[G3 RL designated]],
[F[CR invoked]],
[F[GL invoked]],
[F[GR invoked]],
[F[GL mode]],
[F[right mode]],
[F[bits]],
[F[VT response flag]],
[F[ISO 4873 Latin-1 flag]],
and/or
[F[UTF-8 GL flag]].
- [319] It [MAY[MAY]] invoke the steps to [[modify character sets]]
of [VAR[state]] for some [VAR[features]].
- [807] If [VAR[state]]'s [F[G0 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G0 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],
- [808] If [VAR[state]]'s [F[G1 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G1 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],
- [809] If [VAR[state]]'s [F[G2 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G2 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],
- [810] If [VAR[state]]'s [F[G3 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G3 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],


@@
[VAR[input stream]],
[VAR[initialization steps]] a [[state initialization steps]],
run these steps:

[FIG(steps)[
= [8] Let [VAR[state]] be a new [[state]].
= [327] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "fixed", "fallback", "iso2022" ».
= [9] Run [VAR[initialization steps]] with [VAR[state]].
= [6] 
Let [VAR[output stream]] be a [[list]].
[NOTE[
[97] [VAR[output stream]] might contain
[[characters][character]],
[[extended segment]],
[[direct cursor address]],
[[PCD data]],
and
[[EOF]].
]NOTE]
= [10] 
@@
Process the input stream,
a sequence of zero or more [[bit combinations][bit combination]]
= [7] 
Return [VAR[output stream]].
]FIG]


** Output stream

@@

[4] 
To [DFN[emit a character]] with [[character]] [VAR[char]], run these steps:

[FIG(steps)[
= 
[5] 
[[Append][append]]
[VAR[char]]
to 
[VAR[output stream]].
]FIG]

[115] 
To [DFN[emit a sequence]]  with [[character string]] [VAR[seq]], run these steps:

[FIG(steps)[
=
[116] 
[[Extend][extend]]
[VAR[output stream]]
with 
[VAR[seq]].
]FIG]


[1165] 
To [DFN[emit an extended segment]] with 
[[byte]] [VAR[F]], 
[[byte sequence]] [VAR[data]],
and
[[boolean]] [VAR[incomplete]], run these steps:

[FIG(steps)[
=
[1166] 
[[Append][append]]
a new [[extended segment]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[final]]: [VAR[F]]
:[F[data]]: [VAR[data]]
:[F[incomplete]]: [VAR[incomplete]]
]FIG]

]FIG]



[735] 
To [DFN[emit a direct cursor address]] with 
[[byte]] [VAR[line]] and [[byte]] [VAR[column]],
run these steps:

[FIG(steps)[
=
[736] 
[[Append][append]]
a new [[direct cursor address]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[line]]:[VAR[line]] - [N[0x1F]]
:[F[column]]:[VAR[column]] - [N[0x1F]]
]FIG]


]FIG]

[95] 
To [DFN[emit a PCD data]] with 
[[byte]] [VAR[PM]], 
[[byte]] [VAR[PI]], 
[[byte sequence]] [VAR[data]],
and
[[boolean]] [VAR[incomplete]], run these steps:

[FIG(steps)[
=
[96] 
[[Append][append]]
a new [[PCD data]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[picture mode]]: [VAR[PM]]
:[F[picture identifier]]: [VAR[PI]]
:[F[picture data entity]]: [VAR[data]]
:[F[incomplete]]: [VAR[incomplete]]
]FIG]

]FIG]


[355] 
When [DFN[error]], run these steps:

[FIG(steps)[
= [356] An error [MAY[may]] be reported to a [[developer console]].
= [153] [[Emit a character][emit a character]] [CODE[U+FFFD]].
]FIG]

;; [386] There is an illegal sequence.

[58] 
When [DFN[deprecated]], run these steps:

[FIG(steps)[
= [59] A warning [MAY[may]] be reported to a [[developer console]].
]FIG]

;; [385] There is a sequence that is discouraged by a relevant specification,
or that is an extension to the ISO/IEC 2022 standard.


@@[DFN[reconsume]]

@@



** Decoder states

[27] 
The decoder has several [DFN[decoder states]] for processing input 
[[bit combinations][bit combination]].

[719] 
To [DFN[process a control [[character]]]] [VAR[char]], 
[[switch]] by [VAR[char]]:

[FIG(switch)[

:[CODE(charname)@en[ESC]]:
[FIG(steps)[

= [30] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].

]FIG]
:[CODE(charname)@en[LS0]]:
[FIG(steps)[

= [209] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].

]FIG]
:[CODE(charname)@en[LS1]]:
[FIG(steps)[

= [212] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].

]FIG]
:[CODE(charname)@en[LS2]]:
[FIG(steps)[

= [750] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].

]FIG]
:[CODE(charname)@en[LS3]]:
[FIG(steps)[

= [752] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].

]FIG]
:[CODE(charname)@en[LS1R]]:
[FIG(steps)[

= [61] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [101] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [102] Otherwise:
== [127] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
:[CODE(charname)@en[LS2R]]:
[FIG(steps)[

= [129] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [130] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [131] Otherwise:
== [132] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
:[CODE(charname)@en[LS3R]]:
[FIG(steps)[

= [754] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [133] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [134] Otherwise:
== [135] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
:[CODE(charname)@en[SS2]]:
[FIG(steps)[

= [226] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [214] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].

]FIG]
:[CODE(charname)@en[SS3]]:
[FIG(steps)[

= [227] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [216] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].

]FIG]
:([I[marc]], [I[esc]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]:
[FIG(steps)[

= [103] [[Deprecated][deprecated]].
= [31] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [N[1/11]] followed by [VAR[bc]] ]. 
= [968] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].

]FIG]
:([I[vt]], [I[C1]], [VAR[bc]]) where [VAR[bc]] is [N[8/6]] or [N[8/7]]:
[FIG(steps)[

= [789] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bc]] ]. 
= [969] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].

]FIG]
:([I[vt]], [I[esc]], [N[3/12]]):
[FIG(steps)[

= [785] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "vt" ».
= [786] [[Emit][emit a character]] [VAR[char]].

]FIG]
:([I[tektronix]], [I[esc]], [N[0/3]]):
[FIG(steps)[

= [718] Set [VAR[state]]'s [F[C1 designated]] to the [[VT C1 set]].
= [677] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "noescc0", "vt" ».
= [738] [[Emit][emit a character]] [VAR[char]].

]FIG]
:([I[vt]], [I[esc]], [N[7/11]]):
[FIG(steps)[

= [679] Set [VAR[state]]'s [F[decoder state]] to [I[file state]].

]FIG]
:([I[vt52]], [I[C1]], [N[9/9]]):
[FIG(steps)[

= [722] Set [VAR[state]]'s [F[decoder state]] to [I[cursor address state]].

]FIG]
:[CODE(charname)@en[PCD]]:
[FIG(steps)[

= [65] Set [VAR[state]]'s [F[decoder state]] to [I[PCD state]].

]FIG]
:[CODE(charname)@en[CMD]]:
[FIG(steps)[

= [48] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
:([I[unknown-control]], [VAR[bytes]]) where [VAR[bytes]] is a [[byte sequence]]:
[FIG(steps)[

= [660] [[Emit][emit a character]] [VAR[char]].
= [659] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
:([I[deprecated]], [VAR[c]]) where [VAR[c]] is a [[character]]:
[FIG(steps)[

= [756] [[Deprecated][deprecated]].
= [755] [[Process][process a control character]] [VAR[c]].

]FIG]
:Otherwise:
[FIG(steps)[

= [13] [[Emit][emit a character]] [VAR[char]].

]FIG]


]FIG]


-*-*-

[2] There are the following [[decoder states][decoder state]]:

*** Initial state

[3] The [DFN[initial state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[1/15]] ] :
[FIG(steps)[

= [1110] If [VAR[state]]'s [F[GL mode]] is [I[single]]:
== [1111] Let [VAR[set]] be [VAR[state]]'s [F[left designated]].
= [1112] Otherwise:
== [11] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
= [717] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [1078] If [VAR[state]]'s [F[GL mode]] is [I[ascii]]:
== [1079] Let [VAR[set]] be the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [1109] Otherwise, if [VAR[state]]'s [F[GL mode]] is [I[single]]:
== [1079] Let [VAR[set]] be [VAR[state]]'s [F[left designated]].
= [1080] Otherwise, if [VAR[state]]'s [F[GL mode]] is [I[iso2022]]:
== [314] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [507] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [318] [[Emit a character][emit a character]] 
[VAR[state]]'s [F[fixed set]] [ [VAR[bc]] ].
= [422] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [440] Set [VAR[state]]'s [F[decoder state]] to [I[left unassigned state]].
== [441] [[Reconsume][reconsume]] [VAR[bc]].
= [424] Otherwise:
== [448] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [185] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bc]] ].
== [450] Otherwise:
=== [451] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
=== [487] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [452] Set [VAR[state]]'s [F[decoder bytes]] to [I[left leading byte state]].

]FIG]
: [ [N[8/0]], [N[9/15]] ] :
[FIG(steps)[

= [1081] If [VAR[state]]'s [F[right mode]] is ''not'' [I[iso2022]]:
== [1082] Set [VAR[state]]'s [F[decoder state]] to [I[foreign right state]].
== [1083] [[Reconsume][reconsume]] [VAR[bc]].
= [834] Otherwise, if [VAR[state]]'s [F[CR invoked]] is [I[C1]]:
== [26] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
== [28] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] ].
= [835] Otherwise, if [VAR[state]]'s [F[CR invoked]] is [I[C0]]:
== [836] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
== [837] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [334] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [1084] If [VAR[state]]'s [F[right mode]] is ''not'' [I[iso2022]]:
== [1085] Set [VAR[state]]'s [F[decoder state]] to [I[foreign right state]].
== [1086] [[Reconsume][reconsume]] [VAR[bc]].
= [312] Otherwise, if [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [317] [[Emit a character][emit a character]] 
[VAR[state]]'s [F[fixed set]] [ [VAR[bc]] ].
= [313] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [423] Set [VAR[state]]'s [F[decoder state]] to [I[right unassigned state]].
== [430] [[Reconsume][reconsume]] [VAR[bc]].
= [431] Otherwise:
== [432] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [471] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [473] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
== [474] Otherwise:
=== [475] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [490] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [476] Set [VAR[state]]'s [F[decoder bytes]] to [I[right leading byte state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]


*** SS state

[217] The [DFN[SS state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[2/0]], [[7/15]] ], [ [[10/0]], [[15/15]] ]:
[FIG(steps)[

= [344] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [343] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [345] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [346] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [528] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [349] [[Error][error]].
== [354] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [364] [[Reconsume][reconsume]] [VAR[bc]].
= [444] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [271] [[Error][error]].
== [438] Set [VAR[state]]'s [F[decoder state]] to [I[SS unassigned state]].
== [442] [[Reconsume][reconsume]] [VAR[bc]].
= [447] Otherwise:
== [272] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [316] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [326] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
=== [443] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [329] Otherwise:
=== [332] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [341] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [347] Set [VAR[state]]'s [F[decoder bytes]] to [I[SS leading byte state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [357] [[Error][error]].
= [359] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [358] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Left leading byte state

[482] The [DFN[left leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [495] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [320] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [323] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [324] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [325] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [328] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [330] [[Reconsume][reconsume]] [VAR[bc]].
= [321] Otherwise:
== [496] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [331] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
=== [498] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [336] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [499] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [502] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [503] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
=== [504] Otherwise:
==== [335] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]].
==== [501] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [337] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [492] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [493] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [494] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [483] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [485] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Right leading byte state

[338] The [DFN[right leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/1]], [N[7/14]] ]:
[FIG(steps)[

= [648] Let [VAR[set]] be the result of
[[getting RL invoked set][get RL invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [649] If [VAR[set]] is [I[unassigned-94]]:
== [792] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [793] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [794] [[Reconsume][reconsume]] [VAR[bc]].
= [795] Otherwise:
== [650] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
== [651] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
== [687] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [339] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [340] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [421] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [426] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [427] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [428] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [429] [[Reconsume][reconsume]] [VAR[bc]].
= [433] Otherwise:
== [434] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [436] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [437] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [453] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [454] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [455] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [456] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [457] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [458] Otherwise:
==== [459] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [461] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [462] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [464] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [465] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [466] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [467] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [468] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** SS leading byte state

[469] The [DFN[SS leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ], [ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [470] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [525] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [526] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [527] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [477] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [478] [[Error][error]].
== [479] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [480] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [481] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [486] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [488] [[Reconsume][reconsume]] [VAR[bc]].
= [489] Otherwise:
== [491] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [505] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [506] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [509] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [510] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [511] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [512] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [513] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [514] Otherwise:
==== [515] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [517] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [518] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [519] [[Error][error]].
= [520] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [521] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [522] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [523] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [524] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Left unassigned state

[446] The [DFN[left unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [536] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [532] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [533] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [534] [[Reconsume][reconsume]] [VAR[bc]].
= [535] Otherwise:
== [531] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [529] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [530] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Right unassigned state

[537] The [DFN[right unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [538] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [539] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [540] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [541] [[Reconsume][reconsume]] [VAR[bc]].
= [542] Otherwise:
== [543] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]] & [N[0b01111111]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [544] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [545] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** SS unassigned state

[546] The [DFN[SS unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [547] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [548] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [549] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [550] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [551] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [552] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [553] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [554] [[Reconsume][reconsume]] [VAR[bc]].
= [555] Otherwise:
== [556] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [559] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [560] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [561] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [562] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [563] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [564] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [565] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [566] [[Reconsume][reconsume]] [VAR[bc]].
= [567] Otherwise:
== [568] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [557] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [558] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape state

[32] The [DFN[escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[


:[ [N[0/0]], [N[1/15]] ]:
[FIG(steps)[

= [204] If [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] [[exists]]:
== [720] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [225] [[Process a control character][process a control character]]
[VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].
= [206] Otherwise:
== [207] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
== [208] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
== [224] [[Reconsume][reconsume]] [VAR[bc]].



]FIG]
: [N[2/0]] :
[FIG(steps)[

= [136] Set [VAR[state]]'s [F[decoder state]] to [I[escape announce state]].

]FIG]
: [N[2/1]] :
[FIG(steps)[

= [218] Set [VAR[state]]'s [F[current element]] to [I[C0]].
= [157] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/2]] :
[FIG(steps)[

= [230] Set [VAR[state]]'s [F[current element]] to [I[C1]].
= [158] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/3]] :
[FIG(steps)[

= [388] Set [VAR[state]]'s [F[decoder state]] to [I[escape 3 state]].

]FIG]
: [N[2/4]] :
[FIG(steps)[

= [598] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple state]].

]FIG]
: [[2/5]] :
[FIG(steps)[

= [999] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system state]].

]FIG]
: [[2/6]] :
[FIG(steps)[

= [978] Set [VAR[state]]'s [F[decoder state]] to [I[escape revision state]].

]FIG]
: [[2/8]] :
[FIG(steps)[

= [104] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [294] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [105] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/9]] :
[FIG(steps)[

= [111] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [168] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [170] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/10]] :
[FIG(steps)[

= [169] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [235] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [295] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/11]] :
[FIG(steps)[

= [234] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [296] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [297] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/12]] :
[FIG(steps)[

= [279] [[Deprecated][deprecated]].
= [277] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [278] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [281] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/13]] :
[FIG(steps)[

= [280] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [283] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [285] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/14]] :
[FIG(steps)[

= [282] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [298] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [299] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/15]] :
[FIG(steps)[

= [284] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [300] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [301] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
:[ [N[3/0]], [N[3/15]] ], [ [N[6/0]], [N[7/14]] ]:
[FIG(steps)[

= [40] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [35] [[Process a control character][process a control character]]
[VAR[char]] be [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].

]FIG]
:[ [N[4/0]], [N[5/15]] ]:
[FIG(steps)[

= [36] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [39] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [38] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] + [N[0x40]] ].


]FIG]
:Otherwise:
[FIG(steps)[

= [33] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
= [34] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [156] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape announce state

[137] The [DFN[escape announce state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/5]] ], [ [N[3/8]], [N[3/15]] ]:
[FIG(steps)[

= [828] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [829] [[Process][process a control character]]
[[character]] ([I[unknown-control]], 
[N[1/11]] followed by [N[2/0]] followed by [VAR[bc]]).

]FIG]
: [N[3/6]] :
[FIG(steps)[

= [387] [[Deprecated][deprecated]].
= [833] Set [VAR[state]]'s [F[CR invoked]] to [I[C0]].
= [381] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[3/7]] :
[FIG(steps)[

= [830] [[Deprecated][deprecated]].
= [832] Set [VAR[state]]'s [F[CR invoked]] to [I[C1]].
= [831] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[4/1]], [N[7/14]] ]:
[FIG(steps)[

= [138] Let [VAR[announce]] be [VAR[bc]] - 0x40.
= [139] If [VAR[announce]] is one of:
[N[1]],
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [140] Set [VAR[state]]'s [F[GL invoked]] be [I[G0]].
= [141] If [VAR[announce]] is [N[1]] or [N[2]]:
== [142] Set [VAR[state]]'s [F[GR invoked]] be [CODE[null]].
= [143] If [VAR[announce]] is one of:
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [144] Set [VAR[state]]'s [F[GR invoked]] be [I[G1]].
= [145] If [VAR[announce]] is one of:
[N[12]],
[N[13]],
or
[N[14]]:
== [146] Set [VAR[state]]'s [F[2/0 designated]] be [CODE(charname)@en[SP]].
== [147] Set [VAR[state]]'s [F[7/14 designated]] be [CODE(charname)@en[DEL]].
== [838] If [VAR[state]]'s [F[ISO 4873 Latin-1 flag]] is [[true]]:
=== [839] 
@@
[CODE(charname)@en[ESC]] [N[2/8]] [N[4/2]] [CODE(charname)@en[ESC]] [N[2/13]] [N[4/1]]
= [148] If [VAR[announce]] is one of:
[N[11]],
[N[12]],
[N[13]],
or
[N[14]]:
== [149] Set [VAR[state]]'s [F[bits]] be [I[8-bit]].
= [150] If [VAR[announce]] is [N[10]]:
== [151] Set [VAR[state]]'s [F[bits]] be [I[7-bit]].
= [380] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [152] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/0]].
= [155] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [154] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape 3 state

[389] The [DFN[escape 3 state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/15]] ]:
[FIG(steps)[

= [397] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [398] Set [VAR[state]]'s [F[decoder state]] to [I[escape ctext version state]].

]FIG]
:[ [N[3/0]], [N[3/9]] ]:
[FIG(steps)[

= [396] [[Emit][emit a character]]
[[character]] ([I[vt]], [N[2/3]], [VAR[bc]]).
= [390] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[3/10]], [N[3/15]] ]:
[FIG(steps)[

= [749] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [747] [[Process][process a control character]]
[[character]] ([I[unknown-control]], 
[N[1/11]] followed by [N[2/3]] followed by [VAR[bc]]).

]FIG]
: Otherwise :
[FIG(steps)[

= [392] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/3]].
= [394] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [395] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape ctext version state

[399] The [DFN[escape ctext version state]] switches by the [[bit combination]] 
[VAR[bc]]:

[FIG(switch)[

: [N[3/0]] :
[FIG(steps)[

= [401] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[3/1]] :
[FIG(steps)[

= [400] [[Error][error]].
= [403] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[3/2]], [N[3/15]] ]:
[FIG(steps)[

= [751] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [753] [[Process][process a control character]]
[[character]] ([I[unknown-control]], 
[N[1/11]] followed by [N[2/3]] followed by [VAR[state]]'s [F[current I byte]]
followed by [VAR[bc]]).

]FIG]
: Otherwise :
[FIG(steps)[

= [404] [[Error][error]].
= [407] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].
= [408] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape revision state

[979] The [DFN[escape revision state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[4/0]], [N[7/14]] ]:
[FIG(steps)[

= [980] Set [VAR[state]]'s [F[current revision byte]] to [VAR[bc]].
= [984] Set [VAR[state]]'s [F[decoder state]] to [I[IRR state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [981] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/6]].
= [982] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [983] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** IRR state

[985] The [DFN[IRR state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[1/11]] :
[FIG(steps)[

= [986] Set [VAR[state]]'s [F[decoder state]] to [I[IRR escape state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [989] [[Error][error]].
= [987] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [988] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** IRR escape state

[990] The [DFN[IRR state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/1]], [N[2/2]], [N[2/4]], [ [N[2/8]], [N[2/15]] ] :
[FIG(steps)[

= [991] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].
= [992] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
: Otherwise :
[FIG(steps)[

= [993] [[Error][error]].
= [996] Set [VAR[state]]'s [F[current revision byte]] to [CODE[null]].
= [994] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].
= [995] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape control state

[159] The [DFN[escape control state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [164] Set [VAR[state]]'s [F[C0 designated]] to the result of 
[[getting a C0 set][get a C0 set]] with
[VAR[bc]] and [VAR[state]]'s [F[current revision byte]].
= [232] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [233] Set [VAR[state]]'s [F[C1 designated]] to the result of 
[[getting a C1 set][get a C1 set]] with
[VAR[bc]] and [VAR[state]]'s [F[current revision byte]].
= [382] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [787] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [713] Set [VAR[state]]'s [F[C0 designated]] to the [[empty C0 set]].
= [167] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [714] Set [VAR[state]]'s [F[C1 designated]] to the [[empty C1 set]].
= [162] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape graphic state

[236] The [DFN[escape graphic state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/5]] ]:
[FIG(steps)[

= [254] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [255] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [237] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [402] If 
[VAR[state]]'s [F[VT response flag]] is [[true]],
[VAR[state]]'s [F[current size]] is [N[94]], and 
[VAR[bc]] is [N[3/1]]:
=== [410] [[Emit a character][emit a character]]
([I[vt]], [N[2/8]], [VAR[bc]]).
== [411] Otherwise:
=== [41] If [VAR[state]]'s [F[current size]] is [N[94]]:
==== [238] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bc]] ].
=== [46] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
==== [47] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bc]] ].
=== [964] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [239] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [412] If 
[VAR[state]]'s [F[VT response flag]] is [[true]],
[VAR[state]]'s [F[current size]] is [N[94]], and 
[VAR[bc]] is [N[3/1]]:
=== [413] [[Emit a character][emit a character]]
([I[vt]], [N[2/9]], [VAR[bc]]).
== [414] Otherwise:
=== [64] If [VAR[state]]'s [F[current size]] is [N[94]]:
==== [66] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bc]] ].
=== [119] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
==== [183] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bc]] ].
=== [965] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [286] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [184] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [200] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bc]] ].
== [201] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [202] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bc]] ].
== [966] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [288] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [417] If 
[VAR[state]]'s [F[VT response flag]] is [[true]] and
[VAR[state]]'s [F[current size]] is [N[96]]:
=== [418] [[Emit a character][emit a character]]
([I[vt]], [N[2/15]], [VAR[bc]]).
== [419] Otherwise:
=== [203] If [VAR[state]]'s [F[current size]] is [N[94]]:
==== [219] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bc]] ].
=== [220] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
==== [221] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bc]] ].
=== [967] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [383] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [166] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [241] Let [VAR[set]] be [I[unknown-94]].
= [415] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [416] Let [VAR[set]] be [I[unknown-96]].
= [242] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [243] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [960] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [244] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [160] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [961] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [246] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [161] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [962] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [248] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [165] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [963] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [251] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [252] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape graphic I state

[253] The [DFN[escape graphic I state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [257] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [222] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [240] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [256] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [275] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
= [258] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [259] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [276] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [287] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [289] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
= [290] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [291] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [293] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [678] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [690] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
= [292] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [691] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [692] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [693] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [694] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96 final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
= [384] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].


]FIG]
: Otherwise :
[FIG(steps)[

= [247] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [260] Let [VAR[set]] be [I[unknown-94]].
= [250] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [249] Let [VAR[set]] be [I[unknown-96]].
= [261] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [262] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [956] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [263] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [264] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [957] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [265] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [266] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [958] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [267] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [268] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [959] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [269] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [270] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape multiple state

[599] The [DFN[escape multiple state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/8]] :
[FIG(steps)[

= [606] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [607] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [608] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/9]] :
[FIG(steps)[

= [609] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [610] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [611] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/10]] :
[FIG(steps)[

= [612] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [613] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [614] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/11]] :
[FIG(steps)[

= [618] [[Deprecated][deprecated]].
= [619] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [620] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [621] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/12]] :
[FIG(steps)[

= [622] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [623] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [624] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/13]] :
[FIG(steps)[

= [625] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [626] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [627] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/14]] :
[FIG(steps)[

= [628] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [629] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [630] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [631] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [615] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [616] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [605] If [VAR[bc]] is ''not'' [N[4/0]], [N[4/1]], or [N[4/2]]:
== [788] [[Deprecated][deprecated]].
== [695] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
== [637] Set [VAR[state]]'s [F[G0 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bc]] ].


]FIG]
: Otherwise :
[FIG(steps)[

= [601] Set [VAR[state]]'s [F[current byte sequence]] be [N[2/4]].
= [603] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [604] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape multiple graphic state

[617] The [DFN[escape multiple graphic state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/5]] ]:
[FIG(steps)[

= [632] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [633] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [634] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [635] If [VAR[state]]'s [F[current size]] is [N[94]] and 
[VAR[bc]] is [N[4/0]], [N[4/1]], or [N[4/2]]:
=== [636] [[Deprecated][deprecated]].
== [696] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [698] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [699] Set [VAR[state]]'s [F[G0 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bc]] ].
== [700] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [701] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [702] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [639] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [638] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [640] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [703] Set [VAR[state]]'s [F[G1 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bc]] ].
== [704] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [705] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [706] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [641] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [642] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [707] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [708] Set [VAR[state]]'s [F[G2 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bc]] ].
== [709] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [710] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [711] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [643] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [644] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [712] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [790] Set [VAR[state]]'s [F[G3 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bc]] ].
== [791] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [811] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bc]] ].
=== [812] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [645] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [245] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [362] Let [VAR[set]] be [I[unknown-94]].
= [363] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [322] Let [VAR[set]] be [I[unknown-96]].
= [365] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [366] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [952] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [367] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [368] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [953] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [369] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [370] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [954] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [371] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [372] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [955] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [375] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [376] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape multiple graphic I state

[662] The [DFN[escape multiple graphic I state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [663] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [664] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [813] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [814] Set [VAR[state]]'s [F[G0 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [815] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [816] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [820] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [665] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [666] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [817] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [821] Set [VAR[state]]'s [F[G1 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [822] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [823] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [824] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [667] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [668] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [818] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [825] Set [VAR[state]]'s [F[G2 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [826] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [938] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [943] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [669] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [670] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [819] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [944] Set [VAR[state]]'s [F[G3 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
== [945] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [946] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] 
[ [VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] ].
=== [947] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [671] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [377] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [378] Let [VAR[set]] be [I[unknown-94]].
= [379] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [391] Let [VAR[set]] be [I[unknown-96]].
= [393] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [406] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [948] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [409] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [420] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [949] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [425] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [435] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [950] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [439] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [445] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [951] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [460] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [463] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape coding system state

[1000] The [DFN[escape coding system state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/0]] :
[FIG(steps)[

= [1004] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system 0 state]].

]FIG]
: [N[2/1]] :
[FIG(steps)[

= [1005] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system moe state]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [1006] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system wo state]].

]FIG]
: [N[3/0]], [N[4/0]] :
[FIG(steps)[

= [1121] [[Emit][emit a character]]
[[character]] ([I[protocol]], [N[4/0]]).
= [1040] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1035] Set [VAR[state]]'s [F[right mode]] to [I[iso2022]].

]FIG]
: [N[3/1]], [N[3/2]], [N[3/3]], [ [N[3/5]], [N[3/7]] ], [ [N[3/9]], [N[3/12]] ], [N[3/14]], [N[3/15]] :
[FIG(steps)[

@@

]FIG]
: [N[3/4]], [N[4/1]] :
[FIG(steps)[

= [1118] 
@@[[NAPLPS]]

]FIG]
: [N[3/8]] :
[FIG(steps)[

= [1119] [[Emit][emit a character]]
[[character]] ([I[protocol]], [VAR[bc]]).
= [1037] If [VAR[state]]'s [F[UTF-8 GL flag]] is [[true]]:
== [1072] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1073] Otherwise:
== [1074] Set [VAR[state]]'s [F[GL mode]] to [I[ascii]].
= [1036] Set [VAR[state]]'s [F[right mode]] to [I[utf-8]].

]FIG]
: [N[3/13]] :
[FIG(steps)[

= [1120] [[Emit][emit a character]]
[[character]] ([I[protocol]], [VAR[bc]]).

]FIG]
: [ [N[4/3]], [N[4/6]] ], [N[4/9]]:
[FIG(steps)[

@@


]FIG]
: [N[4/2]] :
[FIG(steps)[

= [1039] Set [VAR[state]]'s [F[GL mode]] to [I[ascii]].
= [1038] Set [VAR[state]]'s [F[right mode]] to [I[utf-1]].

]FIG]
: [N[4/7]] :
[FIG(steps)[

= [1075] If [VAR[state]]'s [F[UTF-8 GL flag]] is [[true]]:
== [1076] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1077] Otherwise:
== [1012] Set [VAR[state]]'s [F[GL mode]] to [I[ascii]].
= [1041] Set [VAR[state]]'s [F[right mode]] to [I[utf-8]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1001] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/5]].
= [1002] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [1003] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Escape coding system 0 state

[1007] The [DFN[escape coding system 0 state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[3/0]] :
[FIG(steps)[

= [1011] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
= [1105] Set [VAR[state]]'s [F[right mode]] to [I[single]].
= [1108] Set [VAR[state]]'s [F[left designated]] to  
the result of 
[[getting a 128 set][get a 128 set]] with
[I[single]], [I[barcode]].
= [1107] Set [VAR[state]]'s [F[right designated]] to
[VAR[state]]'s [F[left designated]].
= [1106] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1008] Set [VAR[state]]'s [F[current byte sequence]] to 
[N[2/5]] followed by [N[2/0]].
= [1009] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [1010] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape coding system moe state

[1013] The [DFN[escape coding system moe state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[2/0]], [N[2/15]] ] :
[FIG(steps)[

= [1022] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [1014] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system moe I state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1015] Set [VAR[state]]'s [F[current byte sequence]] to 
[N[2/5]] followed by [N[2/1]].
= [1016] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [1017] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape coding system moe I state

[1018] The [DFN[escape coding system moe I state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/15]] ]:
[FIG(steps)[

= [1023] Let [VAR[n]] be 
([F[state]]'s [F[current I byte]] - [N[0x20]]) × [N[16]] + [VAR[bc]] - [N[0x30]].
= [1043] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1045] If [VAR[n]] is in [N[1]]:
== [1047] Set [VAR[state]]'s [F[right mode]] to [I[single]].
== [1048] Set [VAR[state]]'s [F[right designated]] 
to the result of 
[[getting a 128 set][get a 128 set]] with
[I[ct]], [I[koi8-r]].
= [1170] Otherwise, if [VAR[n]] is in [N[2]]:
== [1171] Set [VAR[state]]'s [F[right mode]] to [I[single]].
== [1172] Set [VAR[state]]'s [F[right designated]] 
to the result of 
[[getting a 128 set][get a 128 set]] with
[I[ct]], [I[koi8-u]].
= [1173] If [VAR[n]] is in [ [N[3]], [N[11]] ]:
== [1174] Set [VAR[state]]'s [F[right mode]] to [I[single]].
== [1175] Set [VAR[state]]'s [F[right designated]] 
to the result of 
[[getting a G set][get a G set]] with
[N[128]], [N[1]], [I[cp]], [N[1250]] + [VAR[n]] - 3.
= [1049] Otherwise, if [VAR[n]] is [N[12]]:
== [1050] Set [VAR[state]]'s [F[right mode]] to [I[sjis]].
= [1046] Otherwise, if [VAR[n]] is [N[13]]:
== [1051] Set [VAR[state]]'s [F[right mode]] to [I[sjis-2000]].
= [1052] Otherwise, if [VAR[n]] is [N[14]]:
== [1053] Set [VAR[state]]'s [F[right mode]] to [I[big5]].
= [1054] Otherwise, if [VAR[n]] is [N[15]]:
== [1055] Set [VAR[state]]'s [F[right mode]] to [I[johab]].
= [1056] Otherwise, if [VAR[n]] is [N[16]]:
== [1057] Set [VAR[state]]'s [F[right mode]] to [I[uhc]].
= [1058] Otherwise, if [VAR[n]] is [N[17]]:
== [1059] Set [VAR[state]]'s [F[right mode]] to [I[iso2022]].
== [1060] Set [VAR[state]]'s [F[G1 designated]] 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [I[cns]], [N[1]].
== [1061] Set [VAR[state]]'s [F[G2 designated]] 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [I[euctw2]].
= [1062] Otherwise, if [VAR[n]] is [N[18]]:
== [1063] Set [VAR[state]]'s [F[right mode]] to [I[iso2022]].
== [1064] Set [VAR[state]]'s [F[G1 designated]] to 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/15]].
== [1065] Set [VAR[state]]'s [F[G2 designated]] to 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/9]].
== [1066] Set [VAR[state]]'s [F[G3 designated]] to 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[jis]], [I[jisx0212jisx0213]].
= [1067] Otherwise, if [VAR[n]] is [N[19]]:
== [1068] Set [VAR[state]]'s [F[right mode]] to [I[gbk]].
= [1069] Otherwise, if [VAR[n]] is [N[20]]:
== [1070] Set [VAR[state]]'s [F[right mode]] to [I[gb18030]].
= [1042] Otherwise:
== [1044] Set [VAR[state]]'s [F[right mode]] to [I[x-moe-internal]].
= [1071] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].



]FIG]
: Otherwise :
[FIG(steps)[

= [1024] Set [VAR[state]]'s [F[current byte sequence]] to 
[N[2/5]] followed by [N[2/1]] followed by [VAR[state]]'s [F[current I byte]].
= [1019] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [1020] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape coding system wo state

[1021] The [DFN[escape coding system wo state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/15]] ]:
[FIG(steps)[

= [1025] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [1139] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment state]].

]FIG]
: [N[4/0]], [N[4/1]], [ [N[4/3]], [N[4/12]] ]:
[FIG(steps)[

@@

]FIG]
: [N[4/2]] :
[FIG(steps)[

@@

]FIG]
: Otherwise :
[FIG(steps)[

= [1026] Set [VAR[state]]'s [F[current byte sequence]] to 
[N[2/5]] followed by [N[2/15]].
= [1027] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [1028] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape coding system wo unassigned state

[1033] The [DFN[escape coding system wo unassigned state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/15]] ]:
[FIG(steps)[

= [1030] Do nothing.

]FIG]
:[ [N[3/0]], [N[3/15]] ]:
[FIG(steps)[

= [1034] [[Error][error]].
= [1025] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1029] [[Error][error]].
= [1031] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1032] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Escape unassigned state

[106] The [DFN[escape unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [107] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [110] If [VAR[state]]'s [F[current byte sequence]]'s [F[length]]
is equal to the [[maximum sequence length]]:
== [500] [[Error][error]].
== [508] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [108] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [114] [[Emit][emit a character]] 
a [[character]] ([I[esc]], [VAR[state]]'s [F[current byte sequence]]).
= [109] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [472] [[Error][error]].
= [484] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [497] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape trailer state

[516] The [DFN[escape trailer state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [600] Do nothing.

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [602] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [647] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [646] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Foreign right state

[1087] The [DFN[foreign right state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[8/0]], [N[15/15]] ]:
[FIG(steps)[

= [1090] If [VAR[state]]'s [F[right mode]] is [I[single]]:
== [1091] Let [VAR[set]] be [VAR[state]]'s [F[right designated]].
== [1092] [[Emit a character][emit a character]]
[VAR[set]] [ [VAR[bc]] & 0b01111111 ].
[NOTE[
[1117] Control characters are not interpreted.
]NOTE]
== [1094] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1093] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[utf-1]]:
==
@@
= [1104] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[utf-8]]:
==
@@
= [1096] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[sjis]]:
==
@@
= [1097] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[sjis-2000]]:
==
@@
= [1098] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[big5]]:
==
@@
= [1099] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[uhc]]:
==
@@
= [1100] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[johab]]:
==
@@
= [1101] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[gbk]]:
==
@@
= [1102] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[gb18030]]:
==
@@
= [1103] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[x-moe-internal]]:
==
@@

]FIG]
:Otherwise:
[FIG(steps)[

= [1088] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1089] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Extended segment state

[1140] The [DFN[extended segment state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[8/0]], [N[15/15]] ]:
[FIG(steps)[

= [1144] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
= [1145] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment length state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1141] [[Error][error]].
= [1142] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1143] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Extended segment length state

[1146] The [DFN[extended segment length state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[8/0]], [N[15/15]] ]:
[FIG(steps)[

= [1147] Set [VAR[state]]'s [F[current segment length]] to
(([VAR[state]]'s [F[current J byte]] - [N[128]]) × [N[128]]) + ([VAR[bc]] - [N[128]]).
= [1148] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1149] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1151] [[Error][error]].
== [1152] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1150] Otherwise:
== [1145] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment data state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1153] [[Error][error]].
= [1154] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1155] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Extended segment data state

[1156] The [DFN[extended segment data state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[0/0]], [N[0/1]], [ [N[0/3]], [N[15/15]] ]:
[FIG(steps)[

= [1158] Set [VAR[state]]'s [F[current segment data]] to
[VAR[state]]'s [F[current segment data]] followed by [VAR[bc]].
= [1159] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [1160] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1157] [[Emit an extended segment][emit an extended segment]]
[VAR[state]]'s [F[I byte]], 
[VAR[state]]'s [F[current segment data]],
[[false]].
== [1161] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[0/2]] :
[FIG(steps)[

= [1217] Let [VAR[set]] be the result of
[[getting a CT character set][get a CT character set]]
with
[VAR[state]]'s [F[current I byte]] and 
[VAR[state]]'s [F[current segment data]].
= [1212] Set [VAR[state]]'s [F[current segment data]] to
[VAR[state]]'s [F[current segment data]] followed by [VAR[bc]].
= [1213] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [1218] If [VAR[set]] is ''not'' [CODE[null]]:
== [1224] Set [VAR[state]]'s [F[current CT set]] to [VAR[set]].
== [1228] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
== [1225] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment text state]].
== [1219] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
=== [1220] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1221] Otherwise:
== [1214] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
=== [1215] [[Emit an extended segment][emit an extended segment]]
[VAR[state]]'s [F[I byte]], 
[VAR[state]]'s [F[current segment data]],
[[false]].
=== [1216] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1164] [[Emit an extended segment][emit an extended segment]]
[VAR[state]]'s [F[I byte]], 
[VAR[state]]'s [F[current segment data]],
[[true]].
= [1162] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Extended segment text state

[1222] The [DFN[extended segment text state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1223] Let [VAR[set]] be [VAR[state]]'s [F[current CT set]].
= [1226] Set [VAR[state]]'s [F[current segment data]] to
[VAR[state]]'s [F[current segment data]] followed by [VAR[bc]].
= [1227] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [1229] If [VAR[set]] is a [[94 set]], [[96 set]], or [[128 set]]:
== [1242] Let [VAR[bytes]] be [VAR[bc]] & [N[0b01111111]].
== [1230] If [VAR[set]] [ [VAR[bytes]] ] [[exists]]:
=== [1232] Let [VAR[char]] be [VAR[set]] [ [VAR[bytes]] ].
== [1233] Otherwise:
=== [1234] Let [VAR[char]] be [[character]] ([I[unknown-byte]], [VAR[bc]]).
== [1244] [[Emit][emit a character]] [VAR[char]].
== [1235] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1231] Otherwise, if [VAR[set]] is a [[94[SUP[2]] set]] or [[256[SUP[2]] set]]:
== [1237] If [VAR[state]]'s [F[current segment data]]'s [[length]] is [N[2]]:
=== [1251] If [VAR[set]] is a [[94[SUP[2]] set]]:
==== [1238] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current segment data]]'s first byte & [N[0b01111111]]
followed by 
[VAR[state]]'s [F[current segment data]]'s second byte & [N[0b01111111]].
=== [1252] Otherwise, if [VAR[set]] is a [[256[SUP[2]] set]]:
==== [1253] Let [VAR[bytes]] be [VAR[state]]'s [F[current segment data]].
=== [1243] If [VAR[set]] [ [VAR[bytes]] ] [[exists]]:
==== [1241] Let [VAR[char]] be [VAR[set]] [ [VAR[bytes]] ].
==== [1246] [[Emit][emit a character]] [VAR[char]].
=== [1247] Otherwise:
==== [1248] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], 
[VAR[state]]'s [F[current segment data]]'s first byte).
==== [1249] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], 
[VAR[state]]'s [F[current segment data]]'s second byte).
=== [1245] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
== [1262] Otherwise, if [VAR[state]]'s [F[current I byte]] is [N[3/0]]:
=== [1264] If [VAR[state]]'s [F[current segment data]] is in [ [N[0/0]], [N[7/15]] ]:
==== [1265] Let [VAR[char]] be a [[code point]] whose value is [VAR[bc]].
==== [1267] [[Emit][emit a character]] [VAR[char]].
==== [1266] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1236] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1239] If [VAR[state]]'s [F[current segment data]]'s [[length]] is ''not'' [N[0]]:
=== [1240] [[Error][error]].
== [1254] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1256] If [VAR[state]]'s [F[current segment data]]'s [[length]] is ''not'' [N[0]]:
== [1257] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current segment data]]).
= [1255] [[Error][error]].
= [1259] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1260] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Cursor address state

[723] The [DFN[cursor address state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[15/15]] ]:
[FIG(steps)[

= [724] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [725] Set [VAR[state]]'s [F[decoder state]] to [I[cursor address line state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [726] [[Error][error]].
= [727] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [728] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Cursor address line state

[729] The [DFN[cursor address line state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[15/15]] ]:
[FIG(steps)[

= [730] [[Emit a direct cursor address][emit a direct cursor address]]
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [731] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [732] [[Error][error]].
= [733] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [734] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** File state

[680] The [DFN[file state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [685] [[Emit][emit a character]]
[[character]] ([I[vt]], [I[file]], [VAR[bc]]).
= [721] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [742] [[Error][error]].
= [745] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [746] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD state

[67] The [DFN[PCD state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [68] Set [VAR[state]]'s [F[current PCD PM]] to [VAR[bc]].
= [69] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PM state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1123] [[Error][error]].
= [1122] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1128] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** PCD PM state

[70] The [DFN[PCD PM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [71] Set [VAR[state]]'s [F[current PCD PI]] to [VAR[bc]].
= [73] Set [VAR[state]]'s [F[current segment length]] to [N[0]].
= [72] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PI state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1124] [[Error][error]].
= [1125] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1129] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD PI state

[74] The [DFN[PCD PI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[10/0]], [[11/1]] ]:
[FIG(steps)[

= [75] Set [VAR[state]]'s [F[current segment length]] to 
([VAR[state]]'s [F[current segment length]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [77] If [VAR[state]]'s [F[current segment length]] is greater than the
[[maximum chunk length]]:
== [1131] [[Error][error]].
== [1132] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
:[ [[8/13]], [[9/14]] ]:
[FIG(steps)[

= [78] Set [VAR[state]]'s [F[current segment length]] to 
([VAR[state]]'s [F[current segment length]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [79] If [VAR[state]]'s [F[current segment length]] is greater than the
[[maximum chunk length]]:
== [1133] [[Error][error]].
== [1134] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].
= [87] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [82] If [VAR[state]]'s [F[current segment length]] is zero:
== [93] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[current PCD PM]],
[VAR[state]]'s [F[current PCD PI]],
[VAR[state]]'s [F[current segment data]],
[[false]].
== [83] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [84] Otherwise:
== [80] Set [VAR[state]]'s [F[decoder state]] to [I[PCD LI state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1126] [[Error][error]].
= [1127] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1130] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD LI state

[81] The [DFN[PCD LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [88] [[Append][append to a byte sequence]] [VAR[bc]] to
[VAR[state]]'s [F[current segment data]].
= [76] Set [VAR[state]]'s [F[current segment length]] to 
[VAR[state]]'s [F[current segment length]] - 1.
= [85] If [VAR[state]]'s [F[current segment length]] is zero:
== [92] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[current PCD PM]],
[VAR[state]]'s [F[current PCD PI]],
[VAR[state]]'s [F[current segment data]],
[[false]].
== [86] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1135] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[current PCD PM]],
[VAR[state]]'s [F[current PCD PI]],
[VAR[state]]'s [F[current segment data]],
[[true]].
= [1136] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [1137] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Unassigned state

[50] The [DFN[unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [51] [[Emit][emit a character]]
a [[character]] ([VAR[unknown-byte]], [VAR[bc]]).

]FIG]
: [[EOF]] :
[FIG(steps)[

= [674] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [682] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

* Characters

[18] 
A [DFN[character]] is one of followings:

- [CODE(charname)@en[ESC]]
- [CODE(charname)@en[SP]]
- [CODE(charname)@en[MSP]]
- [CODE(charname)@en[DEL]]
- [CODE(charname)@en[LS0]]
- [CODE(charname)@en[LS1]]
- [CODE(charname)@en[LS2]]
- [CODE(charname)@en[LS3]]
- [CODE(charname)@en[LS1R]]
- [CODE(charname)@en[LS2R]]
- [CODE(charname)@en[LS3R]]
- [CODE(charname)@en[SS2]]
- [CODE(charname)@en[SS3]]
- [CODE(charname)@en[DCS]]
- [CODE(charname)@en[CMD]]
- [CODE(charname)@en[PCD]]
- any other [[code point]]
- ([I[esc]], [VAR[bytes]]), where [VAR[bytes]] is a [[byte sequence]]
- ([I[protocol]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- ([I[unknown-byte]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- ([I[unknown-control]], [VAR[bytes]]), where [VAR[bytes]] is a [[byte sequence]]
- ([I[C0]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and [VAR[bytes]] is a [[byte sequence]]
- ([I[C1]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and [VAR[bytes]] is a [[byte sequence]]
- ([VAR[t1]], [VAR[t2]], [VAR[bytes]]), 
where [VAR[t1]] and [VAR[t2]] are valid [VAR[t1]] and [VAR[t2]] pairs for 
the steps to 
[[get a G set]],
[[get a 128 set]],
[[get a 256 set]], or
[[get a 256[SUP[2]] set]]
and [VAR[bytes]] is a [[byte sequence]]
- ([I[marc]], [VAR[bc]], [VAR[bytes]]), 
where [VAR[bc]] is a [[bit combination]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[vt]], [N[8/6]], [VAR[bytes]]), 
where [VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[vt52]], [N[8/6]], [VAR[bytes]]), 
where [VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[vt]], [N[2/3]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/9]] ]
- ([I[vt]], [N[2/8]], [N[3/1]])
- ([I[vt]], [N[2/9]], [N[3/1]])
- ([I[vt]], [N[2/15]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[file]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[C1]], [VAR[bc]]), where [VAR[bc]] is in [ [N[8/0]], [N[9/15]] ]
- ([I[vt52]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt105]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/1]], [N[3/2]] ]
- ([I[tektronix]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[0/0]], [N[1/15]] ]
- ([I[tektronix]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/15]] ]
- ([I[mule]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/4]] ]
- ([I[deprecated]], [VAR[char]]) where [VAR[char]] is a [[character]]


;; [186] 
Interpretation of these [[tuples][tuple]] are application-specific.

[112] 
A [DFN[character string]] is a [[list]] of zero or more [[characters][character]].

[113] 
An [DFN[empty character string]] is a [[character string]] whose [[length]]
is [N[0]].

[1138] 
An [DFN[extended segment]]
is a [[tuple]] of
[DFN[[F[final]]]] ([[bit combination]]),
[DFN[[F[data]]]] ([[byte sequence]]),
and
[DFN[[F[incomplete]]]] ([[boolean]]).


[737] 
A [DFN[direct cursor address]]
is a [[tuple]] of
[DFN[[F[line]]]] (non-negative integer)
and
[DFN[[F[column]]]] (non-negative integer).

[98] 
A [DFN[PCD data]]
is a [[tuple]] of
[DFN[[F[picture mode]]]] ([[byte]]),
[DFN[[F[picture identifier]]]] ([[byte]]),
[DFN[[F[picture data]]]] ([[byte sequence]]),
and
[DFN[[F[incomplete]]]] ([[boolean]]).

@@
[99] 
[DFN[EOF]]



* Character sets

[17] 
A [DFN[character set]] is an [[ordered map]],
where [[keys][key]] are [[byte sequences][byte sequence]] and
[[values][value]] are a [[character]].

;; [575] By definition, there are no duplicate [[keys][key]].

[574] 
A [[character set]] [VAR[set]] [DFN[has 1-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
[VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1.

[576] 
A [[character set]] [VAR[set]] [DFN[has 2-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[2]].

[577] 
A [[character set]] [VAR[set]] [DFN[has 3-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[3]].

[171] 
To [DFN[get a 1-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [172] Let [VAR[set]] be a new [[character set]].
= [173] [[For each]] [VAR[c]] in [ [VAR[start]], [VAR[end]] ]:
== [174] Let [VAR[set]] [ [VAR[c]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[c]]).
= [175] Return [VAR[set]].

]FIG]


[583] 
To [DFN[get a 2-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [584] Let [VAR[set]] be a new [[character set]].
= [585] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [586] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [589] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]].
=== [587] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [588] Return [VAR[set]].

]FIG]


[590] 
To [DFN[get a 3-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [591] Let [VAR[set]] be a new [[character set]].
= [592] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [593] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [594] [[For each]] [VAR[c3]] in [ [VAR[start]], [VAR[end]] ]:
==== [595] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]] followed by [VAR[c3]].
==== [596] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [597] Return [VAR[set]].

]FIG]

-*-*-

[22] 
A [DFN[C0 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[0/0]], [N[1/15]] ].

[176] 
To [DFN[get a C0 set]] with [VAR[F]] and [VAR[R]], run these steps:

[FIG(steps)[

= [652] If [VAR[R]] is [CODE[null]]:
== [655] Let [VAR[bytes]] be [VAR[F]].
= [654] Otherwise:
== [653] Let [VAR[bytes]] be [VAR[F]] followed by [VAR[R]].
= [177] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[0/0]], [[1/15]], [I[C0]], and [VAR[bytes]].
= [180] If [VAR[F]] is ''not'' [[7/14]]:
== [178] Set [VAR[set]] [ [[1/11]] ] to [CODE(charname)@en[ESC]].
= [187] If [VAR[F]] is one of:
[[4/1]] ([[ISO-IR]] 1),
[[4/3]] ([[ISO-IR]] 26),
[[4/4]] ([[ISO-IR]] 36),
[[4/6]] ([[ISO-IR]] 74),
[[4/11]] ([[ISO-IR]] 135),
[[4/12]] ([[ISO-IR]] 140),
[[4/5]] ([[ISO-IR]] 106),
[[4/8]] ([[ISO-IR]] 130),
or
[[4/10]] ([[ISO-IR]] 134):
== [188] Set [VAR[set]] [ [[0/14]] ] to [CODE(charname)@en[LS1]].
== [189] Set [VAR[set]] [ [[0/15]] ] to [CODE(charname)@en[LS0]].
= [190] If [VAR[F]] is [[4/4]] ([[ISO-IR]] 36):
== [191] Set [VAR[set]] [ [[1/12]] ] to [CODE(charname)@en[SS2]].
= [192] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 106),
[[4/9]] ([[ISO-IR]] 132),
[[4/10]] ([[ISO-IR]] 134),
or 
[[4/12]] ([[ISO-IR]] 135):
== [193] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
== [193] Set [VAR[set]] [ [[1/14]] ] to [CODE(charname)@en[SS3]].
= [194] If [VAR[F]] is [[4/12]] ([[ISO-IR]] 140):
== [195] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
= [179] Return [VAR[set]].

]FIG]

[19] 
The [DFN[initial C0 set]] is the result of 
[[getting a C0 set][get a C0 set]] with [N[4/7]] and [CODE[null]].


[37] 
The [DFN[unknown C0 set]] is the result of running these steps:

[FIG(steps)[

= [213] Let [VAR[set]] be a new [[character set]].
= [215] [[For each]] [VAR[c]] in [ [N[0/0]], [N[1/15]] ]:
== [273] Let [VAR[set]] [ [VAR[c]] ] be
[[character]] ([I[unknown-control]], [VAR[c]]).
= [658] Return [VAR[set]].

]FIG]



[23] 
A [DFN[C1 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[8/0]], [N[9/15]] ].

[25] 
To [DFN[get a C1 set]] with [VAR[F]] and [VAR[R]], run these steps:

[FIG(steps)[

= [656] If [VAR[R]] is [CODE[null]]:
== [657] Let [VAR[bytes]] be [VAR[F]].
= [997] Otherwise:
== [998] Let [VAR[bytes]] be [VAR[F]] followed by [VAR[R]].
= [181] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[C1]], [VAR[bytes]].
= [196] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 40),
[[4/3]] ([[ISO-IR]] 77),
or
[[4/7]] ([[ISO-IR]] 105):
== [197] Set [VAR[set]] [ [[8/14]] ] to [CODE(charname)@en[SS2]].
== [198] Set [VAR[set]] [ [[8/15]] ] to [CODE(charname)@en[SS3]].
= [182] Return [VAR[set]].

]FIG]

[24] 
The [DFN[empty C1 set]] is the result of 
[[getting a C1 set][get a C1 set]] with [N[7/14]] and [CODE[null]].

[661] 
The [DFN[unknown C1 set]] is the result of running these steps:

[FIG(steps)[

= [672] Let [VAR[set]] be a new [[character set]].
= [673] [[For each]] [VAR[c]] in [ [N[8/0]], [N[9/15]] ]:
== [675] Let [VAR[set]] [ [VAR[c]] ] be
[[character]] ([I[unknown-control]], [VAR[c]]).
= [676] Return [VAR[set]].

]FIG]


[683] 
The [DFN[VT C1 set]] is the result of running these steps:

[FIG(steps)[

= [684] Let [VAR[set]] be a new [[character set]].
= [199] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[vt]], [I[C1]].
= [688] Set [VAR[set]] [ [N[8/14]] ] to [CODE(charname)@en[LS1]].
= [689] Set [VAR[set]] [ [N[8/15]] ] to [CODE(charname)@en[LS0]].
= [715] Set [VAR[set]] [ [N[9/0]] ] to [CODE(charname)@en[DCS]].
= [716] Return [VAR[set]].

]FIG]

-*-*-

[45] 
A [DFN[G set]] is 
[[94 set]], [[96 set]],
[[94[SUP[2]] set]], [[96[SUP[2]] set]],
or
[[94[SUP[3]] set]].

[578] 
A [DFN[94 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/1]], [N[7/14]] ].

[579] 
A [DFN[96 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/0]], [N[7/15]] ].

[580] 
A [DFN[94[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/1]], [N[7/14]] ].

[581] 
A [DFN[96[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/0]], [N[7/15]] ].

[582] 
A [DFN[94[SUP[3]] set]] is a [[character set]]
that [[has 3-byte range]] [ [N[2/1]], [N[7/14]] ].


[374] 
To determine whether [DFN[is 96 size]] [VAR[set]], run these steps:

[FIG(steps)[

= [569] If [VAR[set]] is [I[unknown-96]], return [[true]].
= [570] Otherwise, if [VAR[set]] is a [[96 set]], return [[true]].
= [373] Otherwise, if [VAR[set]] is a [[96[SUP[2]] set]], return [[true]].
= [571] Otherwise, return [[false]].

]FIG]

[348] 
To determine [[character set]] [VAR[set]]'s [DFN[byte length]],
run these steps:

[FIG(steps)[

= [350] If [VAR[set]] is a [[94 set]] or [[96 set]]:
== [351] Return [N[1]].
= [352] Otherwise, if [VAR[set]] is a [[94[SUP[2]] set]] or [[96[SUP[2]] set]]:
== [353] Return [N[2]].
= [360] Otherwise, if [VAR[set]] is a [[94[SUP[3]] set]]:
== [361] Return [N[3]].

]FIG]





[854] To [DFN[get a G set]] with
[VAR[size]],
[VAR[length]],
[VAR[t1]], 
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [855] If [VAR[size]] is [N[94]] and [VAR[length]] is [N[1]]:
== [856] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [697] Otherwise, if [VAR[size]] is [N[96]] and [VAR[length]] is [N[1]]:
== [857] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [858] Otherwise, if [VAR[size]] is [N[94]] and [VAR[length]] is [N[2]]:
== [859] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [860] Otherwise, if [VAR[size]] is [N[96]] and [VAR[length]] is [N[2]]:
== [861] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[2/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [862] Otherwise, if [VAR[size]] is [N[94]] and [VAR[length]] is [N[3]]:
== [863] Let [VAR[set]] be the result of [[getting a 3-byte set][get a 3-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [864] Return [VAR[set]].

]FIG]

[NOTE[

[827] The following combinations of 
[VAR[size]], [VAR[length]], [VAR[t1]], and [VAR[t2]] are used:

- ([VAR[size]], [N[1]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([VAR[size]], [N[1]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [N[4/0]], [N[7/13]] ]
- ([VAR[size]], [N[1]], [CODE[null]], [[7/14]]) where
[VAR[size]] is [N[94]] or [N[96]]
- ([VAR[size]], [N[1]], [[2/0]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [N[3/0]], [N[7/14]] ]
- ([VAR[size]], [N[1]], [VAR[I]], [VAR[F]]) where
[VAR[size]] is [N[94]] or [N[96]], 
[VAR[I]] is in [ [N[2/1]], [N[2/3]] ], and
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([VAR[size]], [N[1]], [VAR[I]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]],
[VAR[I]] is in [ [N[2/1]], [N[2/3]] ], and
[VAR[F]] is in [ [N[4/0]], [N[7/14]] ]
- ([N[94]], [N[1]], [I[marc]], [N[6/2]])
- ([N[94]], [N[1]], [I[marc]], [N[6/7]])
- ([N[94]], [N[1]], [I[marc]], [N[7/0]])
- ([N[94]], [N[1]], [I[marc]], [N[7/3]])
- ([N[94]], [N[1]], [I[vt]], [N[8/6]])
- ([N[94]], [N[1]], [I[vt52]], [N[8/6]])
- ([N[94]], [N[1]], [I[vt]], [N[8/7]])
- ([N[94]], [N[1]], [I[marc]], [VAR[F]]) where [VAR[F]] is in [ [N[3/2]], [N[3/4]] ]
- ([N[94]], [N[1]], [I[arib]], [VAR[F]]) where [VAR[F]] is in [ [N[3/1]], [N[3/8]] ]
- ([N[94]], [N[1]], [I[videotex]], [N[3/3]])
- ([N[94]], [N[1]], [I[mule-94]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/5]] ]
- ([N[94]], [N[1]], [I[vt]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/14]] ]
- ([N[94]], [N[1]], [I[vt]], [N[4/11]])
- ([N[94]], [N[1]], [I[vt]], [N[5/5]])
- ([N[94]], [N[1]], [I[vt]], [N[2/2]] followed by [N[3/1]])
- ([N[94]], [N[1]], [I[vt]], [N[2/2]] followed by [N[3/4]])
- ([N[94]], [N[1]], [I[vt]], [N[2/5]] followed by [VAR[F]]) where 
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([N[96]], [N[1]], [I[videotex]], [VAR[F]]) where [VAR[F]] is in [ [N[3/8]], [N[3/9]] ]
- ([N[96]], [N[1]], [I[mule-96]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/2]] ]
- ([N[94]], [N[2]], [I[94[SUP[2]]]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[2]], [I[dec]], [I[udc1978]])
- ([N[94]], [N[2]], [I[jef]], [CODE[null]])
- ([N[94]], [N[2]], [I[open]], [I[jisx0208nec]])
- ([N[94]], [N[2]], [I[open]], [I[jisx0212ibm]])
- ([N[94]], [N[2]], [I[jis]], [I[jisx0212jisx0213]])
- ([N[94]], [N[2]], [I[mule-94[SUP[2]]]], [VAR[F]]) where 
[VAR[F]] is in [ [N[3/0]], [N[3/8]] ]
- ([N[94]], [N[2]], [I[arib]], [VAR[F]]) where [VAR[F]] is in [ [N[3/9]], [N[3/11]] ]
- ([N[94]], [N[2]], [I[cns]], [VAR[p]]) where [VAR[p]] is in [ [N[1]], [N[80]] ]
- ([N[94]], [N[2]], [I[cns]], [I[old14]])
- ([N[94]], [N[3]], [I[94[SUP[3]]]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[3]], [I[cns]], [I[euctw2]])
- ([N[94]], [N[3]], [I[marc]], [N[3/1]])
- ([N[96]], [N[2]], [I[mule-96[SUP[2]]]], [VAR[F]]) where 
[VAR[F]] is in [ [N[3/1]], [N[3/4]] ]


]NOTE]

-*-*-

[1095] 
A [DFN[128 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[0/0]], [N[7/15]] ].

[1183] 
A [DFN[256 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[0/0]], [N[15/15]] ].

[1176] 
A [DFN[256[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[0/0]], [N[15/15]] ].

[1184] 
To [DFN[get a 128 set]]
with [VAR[t1]] and [VAR[t2]],
run these steps:

[FIG(steps)[

= [1113] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[0/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [1115] If [VAR[t1]] is [I[single]] and [VAR[t2]] is [I[barcode]]:
== [1116] Set [VAR[set]] [ [N[1/11]] ] to [CODE(charname)@en[ESC]].
= [1114] Return [VAR[set]].

]FIG]

[NOTE[

[1186] The following combinations of 
[VAR[t1]] and [VAR[t2]] are used:

- ([I[cp]], [VAR[i]]) where [VAR[i]] is in [ [N[1250]], [N[1258]] ]
- ([I[ct]], [VAR[n]]) where [VAR[n]] is a [[CT right encoding name]]
- ([I[single]], [I[barcode]])

]NOTE]


[1268] 
To [DFN[get a 256 set]]
with [VAR[t1]] and [VAR[t2]],
run these steps:

[FIG(steps)[

= [1269] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[0/0]], [N[15/15]], [VAR[t1]], [VAR[t2]].
= [1270] Return [VAR[set]].

]FIG]

[NOTE[

[1271] The following combinations of 
[VAR[t1]] and [VAR[t2]] are used:

- ([I[vts]], [I[transparent]])

]NOTE]

[1185] 
To [DFN[get a 256[SUP[2]] set]]
with [VAR[t1]] and [VAR[t2]],
run these steps:

[FIG(steps)[

= [1182] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[0/0]], [N[15/15]], [VAR[t1]], [VAR[t2]].
= [1181] Return [VAR[set]].

]FIG]

[NOTE[

[1187] The following combinations of 
[VAR[t1]] and [VAR[t2]] are used:

- ([I[sjis]], [CODE[null]])
- ([I[sjis]], [I[2000]])
- ([I[gbk]], [CODE[null]])
- ([I[big5]], [CODE[null]])
- ([I[big5]], [I[hp]])
- ([I[big5]], [I[hkscs]])
- ([I[uhc]], [CODE[null]])
- ([I[johab]], [CODE[null]])
- ([I[unicode]], [I[1.1]])

]NOTE]


[1167] A [DFN[CT right encoding name]] is one of the followings:

- [CODE[omron_UDC]]
- [CODE[omron_UDC_ja]]
- [CODE[omron_UDC_zh]]
- [CODE[omron_UDC_tw]]
- [CODE[iso8859-14]]
- [CODE[iso8859-15]]
- [CODE[armscii-8]]
- [CODE[georgian-academy]]
- [CODE[georgian-ps]]
- [CODE[ibm-cp1133]]
- [CODE[iscii-dev]]
- [CODE[isiri-3342]]
- [CODE[iso8859-9e]]
- [CODE[koi8-c]]
- [CODE[koi8-r]]
- [CODE[koi8-u]]
- [CODE[microsoft-cp1251]]
- [CODE[microsoft-cp1255]]
- [CODE[microsoft-cp1256]]
- [CODE[mulelao-1]]
- [CODE[nokhchi-1]]
- [CODE[tatar-cyr]]
- [CODE[tscii-0]]
- [CODE[tcvn-5712]]
- [CODE[viscii1.1-1]]

[1168] A [DFN[CT 2-byte encoding name]] is one of the followings:

- [CODE[fujitsu.u90x03]]
- [CODE[DEC.CNS11643.1986-2]]
- [CODE[DEC.DTSCS.1990-2]]
- [CODE[big5-0]]
- [CODE[big5hkscs-0]]
- [CODE[gbk-0]]
- [CODE[BIG5-0]]
- [CODE[HP-BIG5]]

[1177] 
To [DFN[get a CT character set]] with [VAR[F]] and [VAR[encoding name]],
run these steps:

[FIG(steps)[

= [1178] If [VAR[F]] is [N[3/1]] and [VAR[encoding name]] is 
a [[CT right encoding name]]:
== [1188] If [VAR[encoding name]] is [CODE[iso8859-14]]:
=== [1189] Return the result of 
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[96]], [N[5/15]].
== [1190] Otherwise, if [VAR[encoding name]] is [CODE[iso8859-15]]:
=== [1191] Return the result of 
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[96]], [N[6/2]].
== [1194] Otherwise, if [VAR[encoding name]] is [CODE[mulelao-1]]:
=== [1195] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[mule-94]], [N[3/1]].
== [1196] Otherwise, if [VAR[encoding name]] is [CODE[iscii-dev]]:
=== [1197] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[mule-94]], [N[3/5]].
== [1199] Otherwise, if [VAR[encoding name]] is 
[CODE[omron_UDC_zh]] or [CODE[omron_UDC_tw]]:
=== [1200] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[mule-94]], [N[3/0]].
== [1192] Otherwise:
=== [1193] Return the result of
[[getting a 128 set][get a 128 set]] with
[I[ct]], [VAR[enoding name]].
= [1179] Otherwise, if [VAR[F]] is [N[3/2]] and [VAR[encoding name]] is
a [[CT 2-byte encoding name]]:
== [1198] If [VAR[encoding name]] is [CODE[fujitsu.u90x03]]:
=== [1201] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[jef]], [CODE[null]].
== [1202] Otherwise, if [VAR[encoding name]] is [CODE[DEC.CNS11643.1986-2]]:
=== [1203] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[cns]], [N[2]].
== [1204] Otherwise, if [VAR[encoding name]] is [CODE[DEC.DTSCS.1990-2]]:
=== [1205] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[cns]], [I[old14]].
== [1206] Otherwise, if [VAR[encoding name]] is [CODE[big5-0]] or [CODE[BIG5-0]]:
=== [1207] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[big5]], [CODE[null]].
== [1208] Otherwise, if [VAR[encoding name]] is [CODE[big5hkscs-0]]:
=== [1209] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[big5]], [I[hkscs]].
== [1210] Otherwise, if [VAR[encoding name]] is [CODE[gbk-0]]:
=== [1211] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[gbk]], [CODE[null]].
= [1261] If [VAR[F]] is [N[3/0]] and [VAR[encoding name]] is [CODE[HP-BIG5]]:
== [1263] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[big5]], [I[hp]].
= [1169] Otherwise:
== [1180] Return [CODE[null]].


]FIG]

-*-*-

[333] 
To [DFN[modify character sets]] of [[state]] [VAR[state]] for
[[list]] [VAR[features]], run these steps:

[FIG(steps)[

= [342] [[For each]] [VAR[feature]] in [VAR[features]]:
== [739] [[Switch]] by [VAR[feature]]:
[FIG(switch)[

: "fixed" :
[FIG(steps)[

= [741] Set [VAR[state]]'s [F[fixed set]] [ [N[7/15]] ] to [CODE(charname)@en[DEL]].
= [748] Set [VAR[state]]'s [F[fixed set]] [ [N[10/0]] ] to [CODE(charname)@en[MSP]].
= [743] Set [VAR[state]]'s [F[fixed set]] [ [N[15/15]] ] to 
[[character]] ([I[unknown-byte]], [N[15/15]]).
= [54] Set [VAR[state]]'s [F[escape set]] [ [N[6/13]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS3R]]).
= [55] Set [VAR[state]]'s [F[escape set]] [ [N[6/14]] ] to [CODE(charname)@en[LS2]].
= [56] Set [VAR[state]]'s [F[escape set]] [ [N[6/15]] ] to [CODE(charname)@en[LS3]].
= [57] Set [VAR[state]]'s [F[escape set]] [ [N[7/12]] ] to [CODE(charname)@en[LS3R]].
= [60] Set [VAR[state]]'s [F[escape set]] [ [N[7/13]] ] to [CODE(charname)@en[LS2R]].
= [118] Set [VAR[state]]'s [F[escape set]] [ [N[7/14]] ] to [CODE(charname)@en[LS1R]].
= [49] Set [VAR[state]]'s [F[escape set]] [ [N[6/7]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[6/7]]).
= [62] Set [VAR[state]]'s [F[escape set]] [ [N[7/3]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[7/3]]).
= [123] Set [VAR[state]]'s [F[escape set]] [ [N[7/11]] ] to
[[character]] ([I[vt]], [I[esc]], [N[7/11]]).
= [775] Set [VAR[state]]'s [F[escape set]] [ [N[3/5]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/5]]).
= [776] Set [VAR[state]]'s [F[escape set]] [ [N[3/6]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/6]]).
= [777] Set [VAR[state]]'s [F[escape set]] [ [N[3/7]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/7]]).
= [686] Set [VAR[state]]'s [F[escape set]] [ [N[3/12]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/12]]).
= [760] Set [VAR[state]]'s [F[escape set]] [ [N[3/13]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/13]]).
= [761] Set [VAR[state]]'s [F[escape set]] [ [N[3/14]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/14]]).
= [782] Set [VAR[state]]'s [F[escape set]] [ [N[3/15]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/15]]).
= [764] Set [VAR[state]]'s [F[escape set]] [ [N[3/10]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/10]]).
= [765] Set [VAR[state]]'s [F[escape set]] [ [N[3/11]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/11]]).
= [766] Set [VAR[state]]'s [F[escape set]] [ [N[3/0]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/0]]).
= [840] [[For each]] [VAR[bc]] in [ [N[3/0]], [N[7/14]] ]:
== [842] Set [VAR[bytes]] be [VAR[bc]].
== [841] Set [VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [CODE[null]], [VAR[bc]].
== [846] Set [VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [CODE[null]], [VAR[bc]].
== [878] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [879] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
== [880] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [843] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [844] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [845] Set [VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [VAR[ibc]], [VAR[bc]].
=== [847] Set [VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [VAR[ibc]], [VAR[bc]].
=== [881] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
=== [882] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
=== [883] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [274] [[For each]] [VAR[bc]] in [ [N[4/0]], [N[5/15]] ]:
== [865] Set [VAR[bytes]] be [VAR[bc]].
== [866] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [CODE[null]], [VAR[bc]].
== [848] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [CODE[null]], [VAR[bc]].
== [849] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [850] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [867] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [868] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [CODE[null]], [VAR[bc]].
=== [851] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [CODE[null]], [VAR[bc]].
=== [852] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [853] [[For each]] [VAR[bc]] in [ [N[6/0]], [N[6/15]] ]:
== [869] Set [VAR[bytes]] be [VAR[bc]].
== [870] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [CODE[null]], [VAR[bc]].
== [871] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
== [872] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [873] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [874] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [875] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [CODE[null]], [VAR[bc]].
=== [876] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
=== [877] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [920] [[For each]] [VAR[F]] in 
[N[3/9]], 
[ [N[3/12]], [N[3/14]] ],
[N[2/2]] followed by [N[3/1]],
[N[2/2]] followed by [N[3/4]],
[N[2/5]] followed by [N[3/0]],
[N[2/5]] followed by [N[3/2]],
[N[2/5]] followed by [N[3/4]],
[N[2/5]] followed by [N[3/5]],
[N[2/5]] followed by [N[3/6]],
[N[2/5]] followed by [N[3/13]], and
[N[2/5]] followed by [N[3/15]]:
== [921] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [VAR[F]].
= [915] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/2]] ]:
== [916] Set [VAR[state]]'s [F[96 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[mule-96]], [VAR[F]].
= [917] Set [VAR[state]]'s [F[96 final set]] [ [N[3/8]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[3/8]].
= [918] Set [VAR[state]]'s [F[96 final set]] [ [N[3/9]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[3/9]].
= [919] Set [VAR[state]]'s [F[96 final set]] [ [N[2/2]] followed by [N[3/15]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[3/12]].
= [898] [[For each]] [VAR[F]] in [ [N[4/7]], [N[4/13]] ]:
== [897] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x47]] + 1.
= [888] [[For each]] [VAR[F]] in [N[3/2]], [N[3/4]], and [ [N[3/12]], [N[3/14]] ]:
== [887] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x30]] + 1.
= [886] [[For each]] [VAR[I]] in [ [N[2/1]], [N[2/4]] ]:
== [889] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/15]] ]:
=== [890] Let [VAR[p]] be 
([VAR[I]] - [N[0x20]]) × [N[0x10]] + [VAR[F]] - [N[0x30]] + [N[1]].
=== [891] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[p]].
= [885] [[For each]] [VAR[F]] in [ [N[3/1]], [N[3/4]] ]:
== [884] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [I[mule-96[SUP[2]]]], [VAR[F]].
= [912] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [N[2/2]] followed by [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/0]].
= [913] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] 
[ [N[2/2]] followed by [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[dec]], [I[udc1978]].
= [936] [[For each]] [VAR[F]] in [N[6/2]], [N[6/7]], and [N[7/0]]:
== [935] Set [VAR[state]]'s [F[94 final set]] [ [N[1/11]] followed by [VAR[F]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[marc]], [VAR[F]].
= [937] Set [VAR[state]]'s [F[94 final set]] [ [N[1/11]] followed by [N[7/3]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [939] Set [VAR[state]]'s [F[94 final set]] [ [N[8/7]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].




]FIG]
: "fallback" :
[FIG(steps)[

= [740] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to [CODE(charname)@en[SP]].
= [125] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/4]]).
= [126] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/2]]).
= [128] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[7/0]]).
= [210] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/11]]).
= [211] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/12]]).
= [758] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [759] [[Remove][remove an entry]] [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].
= [778] [[For each]] [VAR[bc]] in [ [N[3/1]], [N[3/4]] ]:
== [779] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[unknown-control]], [VAR[bc]]).
= [780] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to 
[[character]] ([I[unknown-control]], [N[3/8]]).
= [781] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to 
[[character]] ([I[unknown-control]], [N[3/9]]).
= [922] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/8]] ]:
== [923] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [VAR[F]].
= [894] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/3]], [ [N[3/5]], [N[3/11]] ], and [N[3/15]]:
== [896] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [VAR[F]].
= [895] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to [I[unassigned-94]].
= [908] [[For each]] [VAR[F]] in [N[3/1]], [N[3/3]], [ [N[4/0]], [N[4/2]] ]:
== [911] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [VAR[F]] ]
to [I[unassigned-94]].
= [940] Set [VAR[state]]'s [F[94 final set]] [ [N[8/6]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[8/6]].
= [974] [[For each]] [VAR[F]] in 
[N[4/3]], [N[4/5]], [N[4/8]], [N[4/11]], [N[5/1]], and [N[5/5]]:
== [975] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [VAR[F]].

]FIG]
: "iso2022" :
[FIG(steps)[

= [29] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to [CODE(charname)@en[CMD]].
= [42] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[esc]], [N[6/2]]).
= [43] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to [CODE(charname)@en[PCD]].

]FIG]
: "cns" :
[FIG(steps)[

= [892] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/1]], [N[3/3]], [ [N[3/5]], [N[3/11]] ], and [N[3/15]]:
== [893] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x30]] + 1.

]FIG]
: "mongolian" :
[FIG(steps)[

= [744] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to [CODE(charname)@en[MSP]].

]FIG]
: "jisold" :
[FIG(steps)[

= [977] Set [VAR[state]]'s [F[94 final set]] [ [N[4/8]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/10]].

]FIG]
: "ks" :
[FIG(steps)[

= [901] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/3]].

]FIG]
: "naplps" :
[FIG(steps)[

= [52] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS1R]]).
= [53] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS2R]]).

]FIG]
: "videotex" :
[FIG(steps)[

= [932] Set [VAR[state]]'s [F[94 final set]] [ [N[3/3]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[videotex]], [N[3/3]].

]FIG]
: "marc" :
[FIG(steps)[

= [44] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[6/2]]).
= [63] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[7/0]]).
= [902] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [I[marc]], [N[4/1]].
= [930] [[For each]] [VAR[F]] in [ [N[3/2]], [N[3/4]] ]:
== [931] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[marc]], [VAR[F]].


]FIG]
: "arib" :
[FIG(steps)[

= [928] [[For each]] [VAR[F]] in [ [N[3/1]], [N[3/8]] ]:
== [929] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[arib]], [VAR[F]].
= [904] [[For each]] [VAR[F]] in [ [N[3/9]], [N[3/11]] ]:
== [903] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[arib]], [VAR[F]].


]FIG]
: "vt" :
[FIG(steps)[

= [120] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to
[[character]] ([I[vt]], [I[esc]], [N[6/4]]).
= [121] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to
[[character]] ([I[vt]], [I[esc]], [N[6/11]]).
= [122] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to
[[character]] ([I[vt]], [I[esc]], [N[6/12]]).
= [229] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/1]]).
= [681] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/2]]).
= [773] Set [VAR[state]]'s [F[escape set]] [ [N[3/3]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/3]]).
= [774] Set [VAR[state]]'s [F[escape set]] [ [N[3/4]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/4]]).
= [771] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/8]]).
= [772] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/9]]).
= [924] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/8]] ]:
== [925] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [VAR[F]].
= [970] Set [VAR[state]]'s [F[94 final set]] [ [N[4/3]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/5]].
= [971] Set [VAR[state]]'s [F[94 final set]] [ [N[4/5]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/6]].
= [972] Set [VAR[state]]'s [F[94 final set]] [ [N[4/8]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/7]].
= [973] Set [VAR[state]]'s [F[94 final set]] [ [N[5/1]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/9]].
= [124] Set [VAR[state]]'s [F[94 final set]] [ [N[4/11]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[4/11]].
= [976] Set [VAR[state]]'s [F[94 final set]] [ [N[5/5]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[5/5]].




]FIG]
: "vt52" :
[FIG(steps)[

= [942] Set [VAR[state]]'s [F[94 final set]] [ [N[8/6]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt52]], [N[8/6]].

]FIG]
: "vt100" :
[FIG(steps)[

= [941] Set [VAR[state]]'s [F[94 final set]] [ [N[8/6]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[8/6]].

]FIG]
: "vt105" :
[FIG(steps)[

= [783] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[vt105]], [I[esc]], [N[3/1]]).
= [784] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[vt105]], [I[esc]], [N[3/2]]).

]FIG]
: "tektronix" :
[FIG(steps)[

= [405] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [757] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[tektronix]], [I[esc]], [VAR[bc]]).
= [762] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/8]]).
= [763] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/9]]).

]FIG]
: "escshift" :
[FIG(steps)[

= [933] Set [VAR[state]]'s [F[escape set]] [ [N[0/14]] ] to
[[character]] ([I[deprecated]], [CODE(charname)@en[LS1]]).
= [934] Set [VAR[state]]'s [F[escape set]] [ [N[0/15]] ] to
[[character]] ([I[deprecated]], [CODE(charname)@en[LS0]]).


]FIG]
: "noesccl" :
[FIG(steps)[

= [205] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [228] [[Remove][remove an entry]] [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].

]FIG]
: "decea" :
[FIG(steps)[

= [905] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[3/0]].
= [906] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/0]].
= [907] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/3]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]].
= [909] [[For each]] [VAR[F]] in [N[3/1]], [N[3/3]], [N[4/1]], and [N[4/2]]:
== [910] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[3/0]].
= [914] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[dec]], [I[udc1978]].


]FIG]
: "mule" :
[FIG(steps)[

= [767] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/1]]).
= [768] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/2]]).
= [769] Set [VAR[state]]'s [F[escape set]] [ [N[3/3]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/3]]).
= [770] Set [VAR[state]]'s [F[escape set]] [ [N[3/4]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/4]]).
= [926] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/5]] ]:
== [927] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[mule-94]], [VAR[F]].
= [900] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/1]], [N[3/3]], and [ [N[3/5]], [N[3/8]] ]:
== [899] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[mule-94[SUP[2]]]], [VAR[F]].

]FIG]


]FIG]

]FIG]

* Definitions

[14] 
This document depends on the [CITE[Infra Standard]].

[15] 
The terms
[DFN[for each][For each]],
[DFN[boolean]],
[DFN[byte]],
[DFN[byte sequence]],
[DFN[[F[length]]]],
[DFN[code point]],
[DFN[tuple]],
[DFN[list]],
[DFN[[F[size]]]],
[DFN[append]],
[DFN[extend]],
[DFN[ordered map]],
[DFN[entry]],
[DFN[key]],
[DFN[value]],
[DFN[exists]],
[DFN[remove an entry]],
and
[DFN[is empty]]
are defined by the [CITE[Infra Standard]].


-*-*-

[572] 
A [DFN[range]] [VAR[range]] is a [[tuple]] of two integers 
([DFN[[F[start]]]], [DFN[[F[end]]]]),
where [VAR[range]]'s [F[start]] ≦ [VAR[range]]'s [F[end]].
It represents a set of all the integers [VAR[i]]
that satisfies [VAR[range]]'s [F[start]] ≦ [VAR[i]] ≦ [VAR[range]]'s [F[end]].

[573] 
A value [VAR[i]] is in a [[range]] [VAR[range]] if 
[VAR[i]] is an item in the set represented by [VAR[range]].

@@ switch

-*-*-


[16] 
A [DFN[bit combination]] is a [[byte]].
A [[bit combination]] is represented as "[VAR[X]]/[VAR[Y]]",
where [VAR[X]] and [VAR[Y]] are integers in [ [N[0]], [N[15]] ],
which represents a [[byte]] [VAR[X]] × [N[16]] + [VAR[Y]].

[89] 
To [DFN[append][append to a byte sequence]] a [[bit combination]] [VAR[bc]]
to a [[byte sequence]] [VAR[bytes]], run these steps:

[FIG(steps)[
= [90] Replace [VAR[bytes]]'s content by [VAR[bytes]] followed by [VAR[bc]].
]FIG]

[91] The [DFN[empty byte sequence]] is a [[byte sequence]] whose [[length]]
is [N[0]].


* Notes

@@macro code,
[[SCI]],
[[OSC]],
[[DCS]],
[[APC]]
