[SEE[ [[ISO/IEC 2022]] ]]

* ISO/IEC 2022 Decoder

[1] A [DFN[state]] is:

[FIG(list members)[

: [DFN[[F[fixed set]]]] : [[Character set][character set]].
: [DFN[[F[escape set]]]] : [[Character set][character set]].
: [DFN[[F[94 final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[96 final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94[SUP[[VAR[n]]]] final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[96[SUP[[VAR[n]]]] final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94[SUP[[VAR[n]]]] final RL set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[C0 designated]]]] : [[C0 set]].  Initially, the [[initial C0 set]].
: [DFN[[F[C1 designated]]]] : [[C1 set]].  Initially, the [[empty C1 set]].
: [DFN[[F[G0 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G1 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G2 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G3 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G0 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G1 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G2 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G3 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[CR invoked]]]] : [[C element]].
Initially, [I[C1]].
: [DFN[[F[GL invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GR invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[bits]]]] : [I[8-bit]] or [I[7-bit]].
Initially, [I[8-bit]].
: [DFN[[F[VT response flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[ISO 4873 Latin-1 flag]]]] : [[Boolean]].
Initially, [[false]].
: [DFN[[F[current byte sequence]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[current element]]]] : [[C element]] or [[G element]].
: [DFN[[F[current size]]]] : [N[94]] or [N[96]].
: [DFN[[F[current bytes]]]] : [N[1]], [N[2]], or [N[3]].
: [DFN[[F[current I byte]]]] : [[Byte][byte]].
: [DFN[[F[current J byte]]]] : [[Byte][byte]] or [CODE[null]].
: [DFN[[F[PCD PM]]]] : [[Byte][byte]].
: [DFN[[F[PCD PI]]]] : [[Byte][byte]].
: [DFN[[F[PCD LI]]]] : Non-negative integer.
: [DFN[[F[PCD data]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[decoder state]]]] : One of [[decoder states][decoder state]].
Initially, [[initial state]].

]FIG]

[223] A [DFN[C element]] is [I[C0]] or [I[C1]].

[100] A [DFN[G element]] is [I[G0]], [I[G1]], [I[G2]], or [I[G3]].

[117] A [DFN[maximum sequence length]] is an implementation-specific integer,
e.g. [N[15]].

[94] A [DFN[maximum chunk length]] is an implementation-specific integer,
e.g. 2[SUP[30]] - 1.


[315] 
To [DFN[get invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [302] If [VAR[element]] is [CODE[null]]:
== [303] Return [I[unknown-96]].
= [304] Otherwise, if [VAR[element]] is [I[G0]]:
== [305] Return [VAR[state]]'s [F[G0 designated]].
= [306] Otherwise, if [VAR[element]] is [I[G1]]:
== [307] Return [VAR[state]]'s [F[G1 designated]].
= [308] Otherwise, if [VAR[element]] is [I[G2]]:
== [309] Return [VAR[state]]'s [F[G2 designated]].
= [310] Otherwise, if [VAR[element]] is [I[G3]]:
== [311] Return [VAR[state]]'s [F[G3 designated]].
]FIG]

[796] 
To [DFN[get RL invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [797] If [VAR[element]] is [CODE[null]]:
== [798] Return [I[unknown-94]].
= [799] Otherwise, if [VAR[element]] is [I[G0]]:
== [800] Return [VAR[state]]'s [F[G0 RL designated]].
= [801] Otherwise, if [VAR[element]] is [I[G1]]:
== [802] Return [VAR[state]]'s [F[G1 RL designated]].
= [803] Otherwise, if [VAR[element]] is [I[G2]]:
== [804] Return [VAR[state]]'s [F[G2 RL designated]].
= [805] Otherwise, if [VAR[element]] is [I[G3]]:
== [806] Return [VAR[state]]'s [F[G3 RL designated]].
]FIG]

** Input stream

@@

[20] A [[state initialization steps]] is a set of zero or more steps
that modifies [VAR[state]].  It can modify [VAR[state]] in these ways:

- [21] It [MAY[MAY]] modify values of [VAR[state]]'s 
[F[C0 designated]],
[F[C1 designated]],
[F[G0 designated]],
[F[G1 designated]],
[F[G2 designated]],
[F[G3 designated]],
[F[G0 RL designated]],
[F[G1 RL designated]],
[F[G2 RL designated]],
[F[G3 RL designated]],
[F[bits]],
[F[VT response flag]],
[F[ISO 4873 Latin-1 flag]],
[F[CR invoked]],
[F[GL invoked]],
and/or
[F[GR invoked]].
- [319] It [MAY[MAY]] invoke the steps to [[modify character sets]]
of [VAR[state]] for some [VAR[features]].
- [807] If [VAR[state]]'s [F[G0 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G0 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],
- [808] If [VAR[state]]'s [F[G1 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G1 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],
- [809] If [VAR[state]]'s [F[G2 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G2 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],
- [810] If [VAR[state]]'s [F[G3 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G3 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]],


@@
[VAR[input stream]],
[VAR[initialization steps]] a [[state initialization steps]],
run these steps:

[FIG(steps)[
= [8] Let [VAR[state]] be a new [[state]].
= [327] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "fixed", "fallback", "iso2022" ».
= [9] Run [VAR[initialization steps]] with [VAR[state]].
= [6] 
Let [VAR[output stream]] be a [[list]].
[NOTE[
[97] [VAR[output stream]] might contain
[[characters][character]],
[[PCD data]],
and
[[EOF]].
]NOTE]
= [10] 
@@
Process the input stream,
a sequence of zero or more [[bit combinations][bit combination]]
= [7] 
Return [VAR[output stream]].
]FIG]


** Output stream

@@

[4] 
To [DFN[emit a character]] with [[character]] [VAR[char]], run these steps:

[FIG(steps)[
= 
[5] 
[[Append][append]]
[VAR[char]]
to 
[VAR[output stream]].
]FIG]

[115] 
To [DFN[emit a sequence]]  with [[character string]] [VAR[seq]], run these steps:

[FIG(steps)[
=
[116] 
[[Extend][extend]]
[VAR[output stream]]
with 
[VAR[seq]].
]FIG]

[735] 
To [DFN[emit a direct cursor address]] with 
[[byte]] [VAR[line]] and [[byte]] [VAR[column]],
run these steps:

[FIG(steps)[
=
[736] 
[[Append][append]]
a new [[direct cursor address]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[line]]:[VAR[line]] - [N[0x1F]]
:[F[column]]:[VAR[column]] - [N[0x1F]]
]FIG]


]FIG]

[95] 
To [DFN[emit a PCD data]] with [[byte]] [VAR[PM]], [[byte]] [VAR[PI]], 
[[byte sequence]] [VAR[data]], run these steps:

[FIG(steps)[
=
[96] 
[[Append][append]]
a new [[PCD data]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[picture mode]]: [VAR[PM]]
:[F[picture identifier]]: [VAR[PI]]
:[F[picture data entity]]: [VAR[data]]
]FIG]

]FIG]


[355] 
When [DFN[error]], run these steps:

[FIG(steps)[
= [356] An error [MAY[may]] be reported to a [[developer console]].
= [153] [[Emit a character][emit a character]] [CODE[U+FFFD]].
]FIG]

;; [386] There is an illegal sequence.

[58] 
When [DFN[deprecated]], run these steps:

[FIG(steps)[
= [59] A warning [MAY[may]] be reported to a [[developer console]].
]FIG]

;; [385] There is a sequence that is discouraged by a relevant specification,
or that is an extension to the ISO/IEC 2022 standard.


@@[DFN[reconsume]]

@@



** Decoder states

[27] 
The decoder has several [DFN[decoder states]] for processing input 
[[bit combinations][bit combination]].

[719] 
To [DFN[process a control [[character]]]] [VAR[char]], 
[[switch]] by [VAR[char]]:

[FIG(switch)[

:[CODE(charname)@en[ESC]]:
[FIG(steps)[

= [30] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].

]FIG]
:[CODE(charname)@en[LS0]]:
[FIG(steps)[

= [209] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].

]FIG]
:[CODE(charname)@en[LS1]]:
[FIG(steps)[

= [212] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].

]FIG]
:[CODE(charname)@en[LS2]]:
[FIG(steps)[

= [750] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].

]FIG]
:[CODE(charname)@en[LS3]]:
[FIG(steps)[

= [752] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].

]FIG]
:[CODE(charname)@en[LS1R]]:
[FIG(steps)[

= [61] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [101] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [102] Otherwise:
== [127] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
:[CODE(charname)@en[LS2R]]:
[FIG(steps)[

= [129] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [130] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [131] Otherwise:
== [132] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
:[CODE(charname)@en[LS3R]]:
[FIG(steps)[

= [754] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [133] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [134] Otherwise:
== [135] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
:[CODE(charname)@en[SS2]]:
[FIG(steps)[

= [226] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [214] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].

]FIG]
:[CODE(charname)@en[SS3]]:
[FIG(steps)[

= [227] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [216] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].

]FIG]
:([I[marc]], [I[esc]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]:
[FIG(steps)[

= [103] [[Deprecated][deprecated]].
= [31] 
Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with [N[94]], [I[marc]], [VAR[bc]].

]FIG]
:([I[vt]], [I[C1]], [N[8/6]]), ([I[vt]], [I[C1]], [N[8/7]]):
[FIG(steps)[

= [789] 
Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with [N[94]], [I[vt]], [VAR[bc]].

]FIG]
:([I[vt]], [I[esc]], [N[3/12]]):
[FIG(steps)[

= [785] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "vt" ».
= [786] [[Emit][emit a character]] [VAR[char]].

]FIG]
:([I[tektronix]], [I[esc]], [N[0/3]]):
[FIG(steps)[

= [718] Set [VAR[state]]'s [F[C1 designated]] to the [[VT C1 set]].
= [677] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "notektronix", "vt" ».
= [738] [[Emit][emit a character]] [VAR[char]].

]FIG]
:([I[vt]], [I[esc]], [N[7/11]]):
[FIG(steps)[

= [679] Set [VAR[state]]'s [F[decoder state]] to [I[file state]].

]FIG]
:([I[vt52]], [I[C1]], [N[9/9]]):
[FIG(steps)[

= [722] Set [VAR[state]]'s [F[decoder state]] to [I[cursor address state]].

]FIG]
:[CODE(charname)@en[PCD]]:
[FIG(steps)[

= [65] Set [VAR[state]]'s [F[decoder state]] to [I[PCD state]].

]FIG]
:[CODE(charname)@en[CMD]]:
[FIG(steps)[

= [48] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
:([I[unknown-control]], [VAR[bytes]]) where [VAR[bytes]] is a [[byte sequence]]:
[FIG(steps)[

= [660] [[Emit][emit a character]] [VAR[char]].
= [659] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].

]FIG]
:([I[deprecated]], [VAR[c]]) where [VAR[c]] is a [[character]]:
[FIG(steps)[

= [756] [[Deprecated][deprecated]].
= [755] [[Process][process a control character]] [VAR[c]].

]FIG]
:Otherwise:
[FIG(steps)[

= [13] [[Emit][emit a character]] [VAR[char]].

]FIG]


]FIG]


-*-*-

[2] There are the following [[decoder states][decoder state]]:

*** Initial state

[3] The [DFN[initial state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[1/15]] ] :
[FIG(steps)[

= [11] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
= [717] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [314] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [507] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [318] [[Emit a character][emit a character]] 
[VAR[state]]'s [F[fixed set]] [ [VAR[bc]] ].
= [422] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [440] Set [VAR[state]]'s [F[decoder state]] to [I[left unassigned state]].
== [441] [[Reconsume][reconsume]] [VAR[bc]].
= [424] Otherwise:
== [448] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [185] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bc]] ].
== [450] Otherwise:
=== [451] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
=== [487] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [452] Set [VAR[state]]'s [F[decoder bytes]] to [I[left leading byte state]].

]FIG]
: [ [N[8/0]], [N[9/15]] ] :
[FIG(steps)[

= [834] If [VAR[state]]'s [F[CR invoked]] is [I[C1]]:
== [26] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
== [28] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] ].
= [835] Otherwise, if [VAR[state]]'s [F[CR invoked]] is [I[C0]]:
== [836] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
== [837] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [334] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [312] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [317] [[Emit a character][emit a character]] 
[VAR[state]]'s [F[fixed set]] [ [VAR[bc]] ].
= [313] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [423] Set [VAR[state]]'s [F[decoder state]] to [I[right unassigned state]].
== [430] [[Reconsume][reconsume]] [VAR[bc]].
= [431] Otherwise:
== [432] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [471] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [473] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
== [474] Otherwise:
=== [475] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [490] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [476] Set [VAR[state]]'s [F[decoder bytes]] to [I[right leading byte state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]


*** SS state

[217] The [DFN[SS state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[2/0]], [[7/15]] ], [ [[10/0]], [[15/15]] ]:
[FIG(steps)[

= [344] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [343] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [345] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [346] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [528] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [349] [[Error][error]].
== [354] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [364] [[Reconsume][reconsume]] [VAR[bc]].
= [444] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [271] [[Error][error]].
== [438] Set [VAR[state]]'s [F[decoder state]] to [I[SS unassigned state]].
== [442] [[Reconsume][reconsume]] [VAR[bc]].
= [447] Otherwise:
== [272] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [316] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [326] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
=== [443] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [329] Otherwise:
=== [332] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [341] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [347] Set [VAR[state]]'s [F[decoder bytes]] to [I[SS leading byte state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [357] [[Error][error]].
= [359] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [358] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Left leading byte state

[482] The [DFN[left leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [495] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [320] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [323] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [324] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [325] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [328] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [330] [[Reconsume][reconsume]] [VAR[bc]].
= [321] Otherwise:
== [496] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [331] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
=== [498] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [336] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [499] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [502] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [503] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
=== [504] Otherwise:
==== [335] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]].
==== [501] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [337] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [492] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [493] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [494] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [483] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [485] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Right leading byte state

[338] The [DFN[right leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/1]], [N[7/14]] ]:
[FIG(steps)[

= [648] Let [VAR[set]] be the result of
[[getting RL invoked set][get RL invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [649] If [VAR[set]] is [I[unassigned-94]]:
== [792] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [793] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [794] [[Reconsume][reconsume]] [VAR[bc]].
= [795] Otherwise:
== [650] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
== [651] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
== [687] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [339] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [340] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [421] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [426] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [427] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [428] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [429] [[Reconsume][reconsume]] [VAR[bc]].
= [433] Otherwise:
== [434] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [436] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [437] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [453] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [454] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [455] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [456] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [457] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [458] Otherwise:
==== [459] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [461] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [462] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [464] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [465] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [466] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [467] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [468] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** SS leading byte state

[469] The [DFN[SS leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ], [ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [470] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [525] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [526] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [527] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [477] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [478] [[Error][error]].
== [479] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
== [480] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [481] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
== [486] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [488] [[Reconsume][reconsume]] [VAR[bc]].
= [489] Otherwise:
== [491] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [505] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [506] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [509] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [510] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [511] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [512] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [513] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [514] Otherwise:
==== [515] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [517] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [518] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [519] [[Error][error]].
= [520] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current I byte]]).
= [521] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [522] [[Emit][emit a character]] 
a [[character]] ([I[unknown-byte]], [VAR[state]]'s [F[current J byte]]).
= [523] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [524] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Left unassigned state

[446] The [DFN[left unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [536] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [532] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [533] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [534] [[Reconsume][reconsume]] [VAR[bc]].
= [535] Otherwise:
== [531] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [529] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [530] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Right unassigned state

[537] The [DFN[right unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [538] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [539] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [540] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [541] [[Reconsume][reconsume]] [VAR[bc]].
= [542] Otherwise:
== [543] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]] & [N[0b01111111]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [544] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [545] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** SS unassigned state

[546] The [DFN[SS unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [547] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [548] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [549] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [550] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [551] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [552] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [553] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [554] [[Reconsume][reconsume]] [VAR[bc]].
= [555] Otherwise:
== [556] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [559] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [560] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [561] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [562] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [563] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [564] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [565] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [566] [[Reconsume][reconsume]] [VAR[bc]].
= [567] Otherwise:
== [568] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [557] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [558] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape state

[32] The [DFN[escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[


:[ [N[0/0]], [N[1/15]] ]:
[FIG(steps)[

= [204] If [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] [[exists]]:
== [720] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [225] [[Process a control character][process a control character]]
[VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].
= [206] Otherwise:
== [207] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
== [208] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
== [224] [[Reconsume][reconsume]] [VAR[bc]].



]FIG]
: [N[2/0]] :
[FIG(steps)[

= [136] Set [VAR[state]]'s [F[decoder state]] to [I[escape announce state]].

]FIG]
: [N[2/1]] :
[FIG(steps)[

= [218] Set [VAR[state]]'s [F[current element]] to [I[C0]].
= [157] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/2]] :
[FIG(steps)[

= [230] Set [VAR[state]]'s [F[current element]] to [I[C1]].
= [158] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/3]] :
[FIG(steps)[

= [388] Set [VAR[state]]'s [F[decoder state]] to [I[escape 3 state]].

]FIG]
: [N[2/4]] :
[FIG(steps)[

= [598] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple state]].

]FIG]
: [[2/5]] :
[FIG(steps)[

@@

]FIG]
: [[2/6]] :
[FIG(steps)[

@@

]FIG]
: [[2/8]] :
[FIG(steps)[

= [104] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [294] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [105] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/9]] :
[FIG(steps)[

= [111] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [168] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [170] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/10]] :
[FIG(steps)[

= [169] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [235] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [295] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/11]] :
[FIG(steps)[

= [234] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [296] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [297] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/12]] :
[FIG(steps)[

= [279] [[Deprecated][deprecated]].
= [277] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [278] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [281] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/13]] :
[FIG(steps)[

= [280] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [283] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [285] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/14]] :
[FIG(steps)[

= [282] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [298] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [299] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/15]] :
[FIG(steps)[

= [284] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [300] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [301] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
:[ [N[3/0]], [N[3/15]] ], [ [N[6/0]], [N[7/14]] ]:
[FIG(steps)[

= [40] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [35] [[Process a control character][process a control character]]
[VAR[char]] be [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].

]FIG]
:[ [N[4/0]], [N[5/15]] ]:
[FIG(steps)[

= [36] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [39] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [38] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] + [N[0x40]] ].


]FIG]
:Otherwise:
[FIG(steps)[

= [33] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
= [34] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [156] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape announce state

[137] The [DFN[escape announce state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/5]] ], [ [N[3/8]], [N[3/15]] ]:
[FIG(steps)[

= [828] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [829] [[Process][process a control character]]
[[character]] ([I[unknown-control]], 
[N[1/11]] followed by [N[2/0]] followed by [VAR[bc]]).

]FIG]
: [N[3/6]] :
[FIG(steps)[

= [387] [[Deprecated][deprecated]].
= [833] Set [VAR[state]]'s [F[CR invoked]] to [I[C0]].
= [381] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[3/7]] :
[FIG(steps)[

= [830] [[Deprecated][deprecated]].
= [832] Set [VAR[state]]'s [F[CR invoked]] to [I[C1]].
= [831] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[4/1]], [N[7/14]] ]:
[FIG(steps)[

= [138] Let [VAR[announce]] be [VAR[bc]] - 0x40.
= [139] If [VAR[announce]] is one of:
[N[1]],
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [140] Set [VAR[state]]'s [F[GL invoked]] be [I[G0]].
= [141] If [VAR[announce]] is [N[1]] or [N[2]]:
== [142] Set [VAR[state]]'s [F[GR invoked]] be [CODE[null]].
= [143] If [VAR[announce]] is one of:
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [144] Set [VAR[state]]'s [F[GR invoked]] be [I[G1]].
= [145] If [VAR[announce]] is one of:
[N[12]],
[N[13]],
or
[N[14]]:
== [146] Set [VAR[state]]'s [F[2/0 designated]] be [CODE(charname)@en[SP]].
== [147] Set [VAR[state]]'s [F[7/14 designated]] be [CODE(charname)@en[DEL]].
== [838] If [VAR[state]]'s [F[ISO 4873 Latin-1 flag]] is [[true]]:
=== [839] 
@@
[CODE(charname)@en[ESC]] [N[2/8]] [N[4/2]] [CODE(charname)@en[ESC]] [N[2/13]] [N[4/1]]
= [148] If [VAR[announce]] is one of:
[N[11]],
[N[12]],
[N[13]],
or
[N[14]]:
== [149] Set [VAR[state]]'s [F[bits]] be [I[8-bit]].
= [150] If [VAR[announce]] is [N[10]]:
== [151] Set [VAR[state]]'s [F[bits]] be [I[7-bit]].
= [380] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [152] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/0]].
= [155] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [154] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape 3 state

[389] The [DFN[escape 3 state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/15]] ]:
[FIG(steps)[

= [397] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [398] Set [VAR[state]]'s [F[decoder state]] to [I[escape ctext version state]].

]FIG]
:[ [N[3/0]], [N[3/9]] ]:
[FIG(steps)[

= [396] [[Emit][emit a character]]
[[character]] ([I[vt]], [N[2/3]], [VAR[bc]]).
= [390] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[3/10]], [N[3/15]] ]:
[FIG(steps)[

= [749] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [747] [[Process][process a control character]]
[[character]] ([I[unknown-control]], 
[N[1/11]] followed by [N[2/3]] followed by [VAR[bc]]).

]FIG]
: Otherwise :
[FIG(steps)[

= [392] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/3]].
= [394] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [395] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape ctext version state

[399] The [DFN[escape ctext version state]] switches by the [[bit combination]] 
[VAR[bc]]:

[FIG(switch)[

: [N[3/0]] :
[FIG(steps)[

= [401] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [N[3/1]] :
[FIG(steps)[

= [400] [[Error][error]].
= [403] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [N[3/2]], [N[3/15]] ]:
[FIG(steps)[

= [751] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [753] [[Process][process a control character]]
[[character]] ([I[unknown-control]], 
[N[1/11]] followed by [N[2/3]] followed by [VAR[state]]'s [F[current I byte]]
followed by [VAR[bc]]).

]FIG]
: Otherwise :
[FIG(steps)[

= [404] [[Error][error]].
= [407] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned state]].
= [408] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape control state

[159] The [DFN[escape control state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [164] Set [VAR[state]]'s [F[C0 designated]] to the result of 
[[getting a C0 set][get a C0 set]] [VAR[bc]].
= [232] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [233] Set [VAR[state]]'s [F[C1 designated]] to the result of 
[[getting a C1 set][get a C1 set]] [VAR[bc]].
= [382] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [787] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [713] Set [VAR[state]]'s [F[C0 designated]] to the [[empty C0 set]].
= [167] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [714] Set [VAR[state]]'s [F[C1 designated]] to the [[empty C1 set]].
= [162] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape graphic state

[236] The [DFN[escape graphic state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/5]] ]:
[FIG(steps)[

= [254] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [255] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [237] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [402] If 
[VAR[state]]'s [F[VT response flag]] is [[true]],
[VAR[state]]'s [F[current size]] is [N[94]], and 
[VAR[bc]] is [N[3/1]]:
=== [410] [[Emit a character][emit a character]]
([I[vt]], [N[2/8]], [VAR[bc]]).
== [411] Otherwise:
=== [238] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [239] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [412] If 
[VAR[state]]'s [F[VT response flag]] is [[true]],
[VAR[state]]'s [F[current size]] is [N[94]], and 
[VAR[bc]] is [N[3/1]]:
=== [413] [[Emit a character][emit a character]]
([I[vt]], [N[2/9]], [VAR[bc]]).
== [414] Otherwise:
=== [240] Set [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [286] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [287] Set [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [288] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [417] If 
[VAR[state]]'s [F[VT response flag]] is [[true]] and
[VAR[state]]'s [F[current size]] is [N[96]]:
=== [418] [[Emit a character][emit a character]]
([I[vt]], [N[2/15]], [VAR[bc]]).
== [419] Otherwise:
=== [289] Set [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [383] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [415] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [416] Let [VAR[set]] be [I[unknown-96]].
= [166] Otherwise:
== [241] Let [VAR[set]] be [I[unknown-94]].
= [242] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [243] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [244] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [160] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [246] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [161] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [248] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [165] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [251] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [252] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape graphic I state

[253] The [DFN[escape graphic I state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [257] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [256] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [258] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [259] Let [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [290] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [291] Let [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [292] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [293] Let [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [384] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].


]FIG]
: Otherwise :
[FIG(steps)[

= [247] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [249] Let [VAR[set]] be [I[unknown-96]].
= [250] Otherwise:
== [260] Let [VAR[set]] be [I[unknown-94]].
= [261] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [262] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [263] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [264] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [265] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [266] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [267] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [268] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [269] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [270] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape multiple state

[599] The [DFN[escape multiple state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/8]] :
[FIG(steps)[

= [606] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [607] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [608] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/9]] :
[FIG(steps)[

= [609] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [610] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [611] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/10]] :
[FIG(steps)[

= [612] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [613] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [614] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/11]] :
[FIG(steps)[

= [618] [[Deprecated][deprecated]].
= [619] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [620] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [621] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/12]] :
[FIG(steps)[

= [622] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [623] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [624] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/13]] :
[FIG(steps)[

= [625] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [626] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [627] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/14]] :
[FIG(steps)[

= [628] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [629] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [630] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [631] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [615] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [616] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [605] If [VAR[bc]] is ''not'' [N[4/0]], [N[4/1]], or [N[4/2]]:
== [788] [[Deprecated][deprecated]].
= [637] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[N[94]], [CODE[null]], [VAR[bc]], [[false]].
= [811] Set [VAR[state]]'s [F[G0 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[N[94]], [CODE[null]], [VAR[bc]], [[true]].

]FIG]
: Otherwise :
[FIG(steps)[

= [601] Set [VAR[state]]'s [F[current byte sequence]] be [N[2/4]].
= [603] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [604] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape multiple graphic state

[617] The [DFN[escape multiple graphic state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/5]] ]:
[FIG(steps)[

= [632] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [633] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [634] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [635] If [VAR[state]]'s [F[current size]] is [N[94]] and 
[VAR[bc]] is [N[4/0]], [N[4/1]], or [N[4/2]]:
=== [636] [[Deprecated][deprecated]].
== [638] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[false]].
== [812] Set [VAR[state]]'s [F[G0 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[true]].
= [639] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [640] Set [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[false]].
== [813] Set [VAR[state]]'s [F[G1 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[true]].
= [641] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [642] Set [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[false]].
== [814] Set [VAR[state]]'s [F[G2 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[true]].
= [643] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [644] Set [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[false]].
== [815] Set [VAR[state]]'s [F[G3 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]], [[true]].
= [645] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [245] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [322] Let [VAR[set]] be [I[unknown-96]].
= [362] Otherwise:
== [363] Let [VAR[set]] be [I[unknown-94]].
= [365] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [366] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [367] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [368] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [369] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [370] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [371] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [372] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [375] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [376] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape multiple graphic I state

[662] The [DFN[escape multiple graphic I state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [663] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [664] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[false]].
== [816] Set [VAR[state]]'s [F[G0 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[true]].
= [665] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [666] Let [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[false]].
== [817] Let [VAR[state]]'s [F[G1 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[true]].
= [667] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [668] Let [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[false]].
== [818] Let [VAR[state]]'s [F[G2 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[true]].
= [669] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [670] Let [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[false]].
== [819] Let [VAR[state]]'s [F[G3 RL designated]] to the result of
[[getting a multiple graphic set][get a multiple graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]], [[true]].
= [671] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [377] If [VAR[state]]'s [F[current size]] is [N[96]]:
== [378] Let [VAR[set]] be [I[unknown-96]].
= [379] Otherwise:
== [391] Let [VAR[set]] be [I[unknown-94]].
= [393] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [406] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
= [409] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [420] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
= [425] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [435] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
= [439] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [445] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
= [460] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [463] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape unassigned state

[106] The [DFN[escape unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [107] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [110] If [VAR[state]]'s [F[current byte sequence]]'s [F[length]]
is equal to the [[maximum sequence length]]:
== [500] [[Error][error]].
== [508] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [108] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [114] [[Emit][emit a character]] 
a [[character]] ([I[esc]], [VAR[state]]'s [F[current byte sequence]]).
= [109] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [472] [[Error][error]].
= [484] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [497] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape trailer state

[516] The [DFN[escape trailer state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [600] Do nothing.

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [602] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [647] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [646] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Cursor address state

[723] The [DFN[cursor address state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[15/15]] ]:
[FIG(steps)[

= [724] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [725] Set [VAR[state]]'s [F[decoder state]] to [I[cursor address line state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [726] [[Error][error]].
= [727] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [728] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Cursor address line state

[729] The [DFN[cursor address line state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[15/15]] ]:
[FIG(steps)[

= [730] [[Emit a direct cursor address][emit a direct cursor address]]
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [731] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [732] [[Error][error]].
= [733] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [734] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** File state

[680] The [DFN[file state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [685] [[Emit][emit a character]]
[[character]] ([I[vt]], [I[file]], [VAR[bc]]).
= [721] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [742] [[Error][error]].
= [745] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [746] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD state

[67] The [DFN[PCD state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [68] Set [VAR[state]]'s [F[PCD PM]] to [VAR[bc]].
= [69] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PM state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PM state

[70] The [DFN[PCD PM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [71] Set [VAR[state]]'s [F[PCD PI]] to [VAR[bc]].
= [73] Set [VAR[state]]'s [F[PCD LI]] to [N[0]].
= [72] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PI state

[74] The [DFN[PCD PI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[10/0]], [[11/1]] ]:
[FIG(steps)[

= [75] Set [VAR[state]]'s [F[PCD LI]] to ([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [77] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@

]FIG]
:[ [[8/13]], [[9/14]] ]:
[FIG(steps)[

= [78] Set [VAR[state]]'s [F[PCD LI]] to 
([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [79] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@
= [87] Set [VAR[state]]'s [F[PCD data]] to the [[empty byte sequence]].
= [82] If [VAR[state]]'s [F[PCD LI]] is zero:
== [93] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [83] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [84] Otherwise:
== [80] Set [VAR[state]]'s [F[decoder state]] to [I[PCD LI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD LI state

[81] The [DFN[PCD LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [88] [[Append][append to a byte sequence]] [VAR[bc]] to [VAR[state]]'s [F[PCD data]].
= [76] Set [VAR[state]]'s [F[PCD LI]] to [VAR[state]]'s [F[PCD LI]] - 1.
= [85] If [VAR[state]]'s [F[PCD LI]] is zero:
== [92] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [86] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** Unassigned state

[50] The [DFN[unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [51] [[Emit][emit a character]]
a [[character]] ([VAR[unknown-byte]], [VAR[bc]]).

]FIG]
: [[EOF]] :
[FIG(steps)[

= [674] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [682] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

* Characters

[18] 
A [DFN[character]] is one of followings:

- [CODE(charname)@en[ESC]]
- [CODE(charname)@en[SP]]
- [CODE(charname)@en[MSP]]
- [CODE(charname)@en[DEL]]
- [CODE(charname)@en[LS0]]
- [CODE(charname)@en[LS1]]
- [CODE(charname)@en[LS2]]
- [CODE(charname)@en[LS3]]
- [CODE(charname)@en[LS1R]]
- [CODE(charname)@en[LS2R]]
- [CODE(charname)@en[LS3R]]
- [CODE(charname)@en[SS2]]
- [CODE(charname)@en[SS3]]
- [CODE(charname)@en[DCS]]
- [CODE(charname)@en[CMD]]
- [CODE(charname)@en[PCD]]
- any other [[code point]]
- ([I[esc]], [VAR[bytes]]), where [VAR[bytes]] is a [[byte sequence]]
- ([I[unknown-byte]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- ([I[unknown-control]], [VAR[bytes]]), where [VAR[bytes]] is a [[byte sequence]]
- ([I[C0]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[C1]], [VAR[IF]], [VAR[bytes]]), 
where [VAR[IF]] is a [[byte sequence]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([VAR[t1]], [VAR[t2]], [VAR[bytes]]), 
where [VAR[t1]] and [VAR[t2]] are valid [VAR[t1]] and [VAR[t2]] pairs for 
the steps to [[get a G set]] and [VAR[bytes]] is a [[byte sequence]]
- ([I[marc]], [VAR[bc]], [VAR[bytes]]), 
where [VAR[bc]] is a [[bit combination]] and
[VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[vt]], [N[8/6]], [VAR[bytes]]), 
where [VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[vt52]], [N[8/6]], [VAR[bytes]]), 
where [VAR[bytes]] is a [[byte sequence]] of [[length]] [N[1]]
- ([I[vt]], [N[2/3]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/9]] ]
- ([I[vt]], [N[2/8]], [N[3/1]])
- ([I[vt]], [N[2/9]], [N[3/1]])
- ([I[vt]], [N[2/15]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[file]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[C1]], [VAR[bc]]), where [VAR[bc]] is in [ [N[8/0]], [N[9/15]] ]
- ([I[vt52]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt52]], [I[C1]], [N[8/6]]).
- ([I[vt105]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/1]], [N[3/2]] ]
- ([I[tektronix]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[0/0]], [N[1/15]] ]
- ([I[tektronix]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/15]] ]
- ([I[mule]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/4]] ]
- ([I[deprecated]], [VAR[char]]) where [VAR[char]] is a [[character]]


;; [186] 
Interpretation of these [[tuples][tuple]] are application-specific.

[112] 
A [DFN[character string]] is a [[list]] of zero or more [[characters][character]].

[113] 
An [DFN[empty character string]] is a [[character string]] whose [[length]]
is [N[0]].

[737] 
A [DFN[direct cursor address]]
is a [[tuple]] of
[DFN[[F[line]]]] (non-negative integer)
and
[DFN[[F[column]]]] (non-negative integer).

[98] 
A [DFN[PCD data]]
is a [[tuple]] of
[DFN[[F[picture mode]]]] ([[byte]]),
[DFN[[F[picture identifier]]]] ([[byte]]),
and
[DFN[[F[picture data]]]] ([[byte sequence]]).

@@
[99] 
[DFN[EOF]]



* Character sets

[17] 
A [DFN[character set]] is an [[ordered map]],
where [[keys][key]] are [[byte sequences][byte sequence]] and
[[values][value]] are a [[character]].

;; [575] By definition, there are no duplicate [[keys][key]].

[574] 
A [[character set]] [VAR[set]] [DFN[has 1-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
[VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1.

[576] 
A [[character set]] [VAR[set]] [DFN[has 2-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[2]].

[577] 
A [[character set]] [VAR[set]] [DFN[has 3-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[3]].

[171] 
To [DFN[get a 1-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [172] Let [VAR[set]] be a new [[character set]].
= [173] [[For each]] [VAR[c]] in [ [VAR[start]], [VAR[end]] ]:
== [174] Let [VAR[set]] [ [VAR[c]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[c]]).
= [175] Return [VAR[set]].

]FIG]


[583] 
To [DFN[get a 2-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [584] Let [VAR[set]] be a new [[character set]].
= [585] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [586] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [589] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]].
=== [587] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [588] Return [VAR[set]].

]FIG]


[590] 
To [DFN[get a 3-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [591] Let [VAR[set]] be a new [[character set]].
= [592] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [593] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [594] [[For each]] [VAR[c3]] in [ [VAR[start]], [VAR[end]] ]:
==== [595] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]] followed by [VAR[c3]].
==== [596] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [597] Return [VAR[set]].

]FIG]


[22] 
A [DFN[C0 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[0/0]], [N[1/15]] ].

[176] 
To [DFN[get a C0 set]] [VAR[F]], run these steps:

[FIG(steps)[

= [652] If [VAR[F]] is ''not'' in [ [N[4/0]], [N[7/14]] ]:
== [653] Return the [[unknown C0 set]].
== [654] Abort these steps.
= [177] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[0/0]], [[1/15]], [I[C0]], and [VAR[F]].
= [180] If [VAR[F]] is ''not'' [[7/14]]:
== [178] Set [VAR[set]] [ [[1/11]] ] to [CODE(charname)@en[ESC]].
= [187] If [VAR[F]] is one of:
[[4/1]] ([[ISO-IR]] 1),
[[4/3]] ([[ISO-IR]] 26),
[[4/4]] ([[ISO-IR]] 36),
[[4/6]] ([[ISO-IR]] 74),
[[4/11]] ([[ISO-IR]] 135),
[[4/12]] ([[ISO-IR]] 140),
[[4/5]] ([[ISO-IR]] 106),
[[4/8]] ([[ISO-IR]] 130),
or
[[4/10]] ([[ISO-IR]] 134):
== [188] Set [VAR[set]] [ [[0/14]] ] to [CODE(charname)@en[LS1]].
== [189] Set [VAR[set]] [ [[0/15]] ] to [CODE(charname)@en[LS0]].
= [190] If [VAR[F]] is [[4/4]] ([[ISO-IR]] 36):
== [191] Set [VAR[set]] [ [[1/12]] ] to [CODE(charname)@en[SS2]].
= [192] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 106),
[[4/9]] ([[ISO-IR]] 132),
[[4/10]] ([[ISO-IR]] 134),
or 
[[4/12]] ([[ISO-IR]] 135):
== [193] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
== [193] Set [VAR[set]] [ [[1/14]] ] to [CODE(charname)@en[SS3]].
= [194] If [VAR[F]] is [[4/12]] ([[ISO-IR]] 140):
== [195] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
= [179] Return [VAR[set]].

]FIG]

[19] 
The [DFN[initial C0 set]] is the result of 
[[getting a C0 set][get a C0 set]] [[4/7]].


[37] 
The [DFN[unknown C0 set]] is the result of running these steps:

[FIG(steps)[

= [213] Let [VAR[set]] be a new [[character set]].
= [215] [[For each]] [VAR[c]] in [ [N[0/0]], [N[1/15]] ]:
== [273] Let [VAR[set]] [ [VAR[c]] ] be
[[character]] ([I[unknown-control]], [VAR[c]]).
= [658] Return [VAR[set]].

]FIG]



[23] 
A [DFN[C1 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[8/0]], [N[9/15]] ].

[25] 
To [DFN[get a C1 set]] [VAR[F]], run these steps:

[FIG(steps)[

= [655] If [VAR[F]] is ''not'' in [ [N[4/0]], [N[7/14]] ]:
== [656] Return the [[unknown C1 set]].
== [657] Abort these steps.
= [181] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[C1]], [VAR[F]].
= [196] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 40),
[[4/3]] ([[ISO-IR]] 77),
or
[[4/7]] ([[ISO-IR]] 105):
== [197] Set [VAR[set]] [ [[8/14]] ] to [CODE(charname)@en[SS2]].
== [198] Set [VAR[set]] [ [[8/15]] ] to [CODE(charname)@en[SS3]].
= [182] Return [VAR[set]].

]FIG]

[24] 
The [DFN[empty C1 set]] is the result of 
[[getting a C1 set][get a C1 set]] [[7/14]].

[661] 
The [DFN[unknown C1 set]] is the result of running these steps:

[FIG(steps)[

= [672] Let [VAR[set]] be a new [[character set]].
= [673] [[For each]] [VAR[c]] in [ [N[8/0]], [N[9/15]] ]:
== [675] Let [VAR[set]] [ [VAR[c]] ] be
[[character]] ([I[unknown-control]], [VAR[c]]).
= [676] Return [VAR[set]].

]FIG]


[683] 
The [DFN[VT C1 set]] is the result of running these steps:

[FIG(steps)[

= [684] Let [VAR[set]] be a new [[character set]].
= [199] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [[8/0]], [[9/15]], [I[vt]], [I[C1]].
= [688] Set [VAR[set]] [ [N[8/14]] ] to [CODE(charname)@en[LS1]].
= [689] Set [VAR[set]] [ [N[8/15]] ] to [CODE(charname)@en[LS0]].
= [715] Set [VAR[set]] [ [N[9/0]] ] to [CODE(charname)@en[DCS]].
= [716] Return [VAR[set]].

]FIG]

[200] 
The [DFN[VT52 C1 set]] is the result of running these steps:

[FIG(steps)[

= [201] Let [VAR[set]] be a new [[character set]].
= [41] Let [VAR[set2]] be a [[VT C1 set]].
= [202] [[For each]] [VAR[bc]] in [ [N[8/0]], [N[9/15]] ]:
== [790] Set [VAR[set]] [ [VAR[bc]] ] to [VAR[set2]] [ [VAR[bc]] ].
= [791] Set [VAR[set]] [ [N[8/6]] ] to 
[[character]] ([I[vt52]], [I[C1]], [N[8/6]]).
= [203] Return [VAR[set]].

]FIG]


[45] 
A [DFN[G set]] is 
[[94 set]], [[96 set]],
[[94[SUP[2]] set]], [[96[SUP[2]] set]],
or
[[94[SUP[3]] set]].

[578] 
A [DFN[94 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/1]], [N[7/14]] ].

[579] 
A [DFN[96 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/0]], [N[7/15]] ].

[580] 
A [DFN[94[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/1]], [N[7/14]] ].

[581] 
A [DFN[96[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/0]], [N[7/15]] ].

[582] 
A [DFN[94[SUP[3]] set]] is a [[character set]]
that [[has 3-byte range]] [ [N[2/1]], [N[7/14]] ].


[374] 
To determine whether [DFN[is 96 size]] [VAR[set]], run these steps:

[FIG(steps)[

= [569] If [VAR[set]] is [I[unknown-96]], return [[true]].
= [570] Otherwise, if [VAR[set]] is a [[96 set]], return [[true]].
= [373] Otherwise, if [VAR[set]] is a [[96[SUP[2]] set]], return [[true]].
= [571] Otherwise, return [[false]].

]FIG]

[348] 
To determine [[character set]] [VAR[set]]'s [DFN[byte length]],
run these steps:

[FIG(steps)[

= [350] If [VAR[set]] is a [[94 set]] or [[96 set]]:
== [351] Return [N[1]].
= [352] Otherwise, if [VAR[set]] is a [[94[SUP[2]] set]] or [[96[SUP[2]] set]]:
== [353] Return [N[2]].
= [360] Otherwise, if [VAR[set]] is a [[94[SUP[3]] set]]:
== [361] Return [N[3]].

]FIG]


[46] 
To [DFN[get a graphic set]] with 
[VAR[size]], [VAR[I]], and [VAR[F]], run these steps:

[FIG(steps)[

= [47] If 
[VAR[size]] is [N[94]], [VAR[I]] is [I[marc]], and [VAR[F]] is [N[7/3]];
or [VAR[size]] is [N[94]], [VAR[I]] is [I[vt]], and [VAR[F]] is [N[8/7]]:
== [275] Return the result of
[[getting a graphic set][get a graphic set]] with
[N[94]], [CODE[null]], [[4/2]].
== [276] Abort these steps.
= [64] If [VAR[I]] is a [[bit combination]]:
== [220] If [VAR[I]] is ''not'' [CODE[null]]:
=== [221] Let [VAR[f]] be [VAR[I]] followed by [VAR[F]].
== [222] Otherwise:
=== [219] Let [VAR[f]] be [VAR[F]].
== [696] If [VAR[size]] is [N[94]]:
=== [183] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/1]], [N[7/14]], [N[94]], [VAR[f]].
== [697] Otherwise, if [VAR[size]] is [N[96]]:
=== [698] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/0]], [N[7/15]], [N[96]], [VAR[f]].
== [66] Otherwise:
=== [119] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[I]], [VAR[F]].
= [184] Return [VAR[set]].

]FIG]



[678] 
To [DFN[get a multiple graphic set]] with 
[VAR[size]], [VAR[I]], [VAR[F]],
and
[VAR[is RL]], run these steps:

[FIG(steps)[

= [820] If [VAR[is RL]] is [[true]]:
== [821] If [VAR[size]] is [N[94]]:
=== [822] Return [I[unknown-94]].
=== [826] Abort these steps.
== [823] Otherwise, if [VAR[size]] is [N[96]]:
=== [824] Return [I[unknown-96]].
=== [825] Abort these steps.
= [690] If [VAR[I]] is ''not'' [CODE[null]]:
== [691] Let [VAR[f]] be [VAR[I]] followed by [VAR[F]].
= [692] Otherwise:
== [693] Let [VAR[f]] be [VAR[F]].
= [694] If [VAR[F]] is in [ [N[4/0]], [N[4/15]] ]:
== [699] If [VAR[size]] is [N[94]]:
=== [700] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [[2/1]], [[7/14]], 94[SUP[2]], [VAR[f]].
== [701] Otherwise, if [VAR[size]] is [N[96]]:
=== [702] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [[2/0]], [[7/15]], 96[SUP[2]], [VAR[f]].
= [695] Otherwise, if [VAR[F]] is in [ [N[5/0]], [N[5/15]] ]:
== [704] If [VAR[size]] is [N[94]]:
=== [705] Let [VAR[set]] be the result of [[getting a 3-byte set][get a 3-byte set]] 
with [[2/1]], [[7/14]], 94[SUP[3]], [VAR[f]].
== [706] Otherwise, if [VAR[size]] is [N[96]]:
=== [707] Let [VAR[set]] be [I[unknown-96]].
= [708] Otherwise:
== [709] If [VAR[size]] is [N[94]]:
=== [710] Let [VAR[set]] be [I[unknown-94]].
== [711] Otherwise, if [VAR[size]] is [N[96]]:
=== [712] Let [VAR[set]] be [I[unknown-96]].
= [703] Return [VAR[set]].

]FIG]

[854] To [DFN[get a G set]] with
[VAR[size]],
[VAR[length]],
[VAR[t1]], 
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [855] If [VAR[size]] is [N[94]] and [VAR[length]] is [N[1]]:
== [856] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [697] Otherwise, if [VAR[size]] is [N[96]] and [VAR[length]] is [N[1]]:
== [857] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [858] Otherwise, if [VAR[size]] is [N[94]] and [VAR[length]] is [N[2]]:
== [859] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [860] Otherwise, if [VAR[size]] is [N[96]] and [VAR[length]] is [N[2]]:
== [861] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[2/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [862] Otherwise, if [VAR[size]] is [N[94]] and [VAR[length]] is [N[3]]:
== [863] Let [VAR[set]] be the result of [[getting a 3-byte set][get a 3-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [864] Return [VAR[set]].

]FIG]

[NOTE[

[827] The following combinations of 
[VAR[size]], [VAR[length]], [VAR[t1]], and [VAR[t2]] are used:

- ([VAR[size]], [N[1]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([VAR[size]], [N[1]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [N[4/0]], [N[7/13]] ]
- ([VAR[size]], [N[1]], [CODE[null]], [[7/14]]) where
[VAR[size]] is [N[94]] or [N[96]]
- ([VAR[size]], [N[1]], [[2/0]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [N[3/0]], [N[7/14]] ]
- ([VAR[size]], [N[1]], [VAR[I]], [VAR[F]]) where
[VAR[size]] is [N[94]] or [N[96]], 
[VAR[I]] is in [ [N[2/1]], [N[2/3]] ], and
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([VAR[size]], [N[1]], [VAR[I]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]],
[VAR[I]] is in [ [N[2/1]], [N[2/3]] ], and
[VAR[F]] is in [ [N[4/0]], [N[7/14]] ]
- ([N[94]], [N[1]], [I[marc]], [N[6/2]])
- ([N[94]], [N[1]], [I[marc]], [N[6/7]])
- ([N[94]], [N[1]], [I[marc]], [N[7/0]])
- ([N[94]], [N[1]], [I[marc]], [N[7/3]])
- ([N[94]], [N[1]], [I[vt]], [N[8/6]])
- ([N[94]], [N[1]], [I[vt52]], [N[8/6]])
- ([N[94]], [N[1]], [I[vt]], [N[8/7]])
- ([N[94]], [N[1]], [I[marc]], [VAR[F]]) where [VAR[F]] is in [ [N[3/2]], [N[3/4]] ]
- ([N[94]], [N[1]], [I[arib]], [VAR[F]]) where [VAR[F]] is in [ [N[3/1]], [N[3/8]] ]
- ([N[94]], [N[1]], [I[videotex]], [N[3/3]])
- ([N[94]], [N[1]], [I[mule-94]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/5]] ]
- ([N[94]], [N[1]], [I[vt]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/14]] ]
- ([N[94]], [N[1]], [I[vt]], [N[2/2]] followed by [N[3/1]])
- ([N[94]], [N[1]], [I[vt]], [N[2/2]] followed by [N[3/4]])
- ([N[94]], [N[1]], [I[vt]], [N[2/5]] followed by [VAR[F]]) where 
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([N[96]], [N[1]], [I[videotex]], [VAR[F]]) where [VAR[F]] is in [ [N[3/8]], [N[3/9]] ]
- ([N[96]], [N[1]], [I[mule-96]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/2]] ]
- ([N[94]], [N[2]], [I[94[SUP[2]]]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[2]], [I[dec]], [I[udc1978]])
- ([N[94]], [N[2]], [I[mule-94[SUP[2]]]], [VAR[F]]) where 
[VAR[F]] is in [ [N[3/0]], [N[3/8]] ]
- ([N[94]], [N[2]], [I[arib]], [VAR[F]]) where [VAR[F]] is in [ [N[3/9]], [N[3/11]] ]
- ([N[94]], [N[2]], [I[cns]], [VAR[p]]) where [VAR[p]] is in [ [N[1]], [N[80]] ]
- ([N[94]], [N[2]], [I[cns]], [I[old14]])
- ([N[94]], [N[3]], [I[94[SUP[3]]]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[3]], [I[cns]], [I[euctw2]])
- ([N[94]], [N[3]], [I[marc]], [N[3/1]])
- ([N[96]], [N[2]], [I[mule-96[SUP[2]]]], [VAR[F]]) where 
[VAR[F]] is in [ [N[3/1]], [N[3/4]] ]

]NOTE]

[333] 
To [DFN[modify character sets]] of [[state]] [VAR[state]] for
[[list]] [VAR[features]], run these steps:

[FIG(steps)[

= [342] [[For each]] [VAR[feature]] in [VAR[features]]:
== [739] [[Switch]] by [VAR[feature]]:
[FIG(switch)[

: "fixed" :
[FIG(steps)[

= [741] Set [VAR[state]]'s [F[fixed set]] [ [N[7/15]] ] to [CODE(charname)@en[DEL]].
= [748] Set [VAR[state]]'s [F[fixed set]] [ [N[10/0]] ] to [CODE(charname)@en[MSP]].
= [743] Set [VAR[state]]'s [F[fixed set]] [ [N[15/15]] ] to 
[[character]] ([I[unknown-byte]], [N[15/15]]).
= [54] Set [VAR[state]]'s [F[escape set]] [ [N[6/13]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS3R]]).
= [55] Set [VAR[state]]'s [F[escape set]] [ [N[6/14]] ] to [CODE(charname)@en[LS2]].
= [56] Set [VAR[state]]'s [F[escape set]] [ [N[6/15]] ] to [CODE(charname)@en[LS3]].
= [57] Set [VAR[state]]'s [F[escape set]] [ [N[7/12]] ] to [CODE(charname)@en[LS3R]].
= [60] Set [VAR[state]]'s [F[escape set]] [ [N[7/13]] ] to [CODE(charname)@en[LS2R]].
= [118] Set [VAR[state]]'s [F[escape set]] [ [N[7/14]] ] to [CODE(charname)@en[LS1R]].
= [49] Set [VAR[state]]'s [F[escape set]] [ [N[6/7]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[6/7]]).
= [62] Set [VAR[state]]'s [F[escape set]] [ [N[7/3]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[7/3]]).
= [123] Set [VAR[state]]'s [F[escape set]] [ [N[7/11]] ] to
[[character]] ([I[vt]], [I[esc]], [N[7/11]]).
= [775] Set [VAR[state]]'s [F[escape set]] [ [N[3/5]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/5]]).
= [776] Set [VAR[state]]'s [F[escape set]] [ [N[3/6]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/6]]).
= [777] Set [VAR[state]]'s [F[escape set]] [ [N[3/7]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/7]]).
= [686] Set [VAR[state]]'s [F[escape set]] [ [N[3/12]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/12]]).
= [760] Set [VAR[state]]'s [F[escape set]] [ [N[3/13]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/13]]).
= [761] Set [VAR[state]]'s [F[escape set]] [ [N[3/14]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/14]]).
= [782] Set [VAR[state]]'s [F[escape set]] [ [N[3/15]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/15]]).
= [764] Set [VAR[state]]'s [F[escape set]] [ [N[3/10]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/10]]).
= [765] Set [VAR[state]]'s [F[escape set]] [ [N[3/11]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/11]]).
= [766] Set [VAR[state]]'s [F[escape set]] [ [N[3/0]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/0]]).
= [840] [[For each]] [VAR[bc]] in [ [N[3/0]], [N[7/14]] ]:
== [842] Set [VAR[bytes]] be [VAR[bc]].
== [841] Set [VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [CODE[null]], [VAR[bc]].
== [846] Set [VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [CODE[null]], [VAR[bc]].
== [878] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [879] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
== [880] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [843] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [844] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [845] Set [VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [VAR[ibc]], [VAR[bc]].
=== [847] Set [VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [VAR[ibc]], [VAR[bc]].
=== [881] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
=== [882] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
=== [883] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [274] [[For each]] [VAR[bc]] in [ [N[4/0]], [N[5/15]] ]:
== [865] Set [VAR[bytes]] be [VAR[bc]].
== [866] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [CODE[null]], [VAR[bc]], [[false]].
== [848] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [CODE[null]], [VAR[bc]], [[false]].
== [849] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [850] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [867] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [868] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [CODE[null]], [VAR[bc]], [[false]].
=== [851] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [CODE[null]], [VAR[bc]], [[false]].
=== [852] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [853] [[For each]] [VAR[bc]] in [ [N[6/0]], [N[6/15]] ]:
== [869] Set [VAR[bytes]] be [VAR[bc]].
== [870] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [CODE[null]], [VAR[bc]], [[false]].
== [871] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
== [872] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [873] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [874] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [875] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [CODE[null]], [VAR[bc]], [[false]].
=== [876] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
=== [877] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [915] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/2]] ]:
== [916] Set [VAR[state]]'s [F[96 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[mule-96]], [VAR[F]].
= [917] Set [VAR[state]]'s [F[96 final set]] [ [N[3/8]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[3/8]].
= [918] Set [VAR[state]]'s [F[96 final set]] [ [N[3/9]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[3/9]].
= [919] Set [VAR[state]]'s [F[96 final set]] [ [N[2/2]] followed by [N[3/15]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[3/12]].
= [898] [[For each]] [VAR[F]] in [ [N[4/7]], [N[4/13]] ]:
== [897] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x47]] + 1.
= [888] [[For each]] [VAR[F]] in [N[3/2]], [N[3/4]], and [ [N[3/12]], [N[3/14]] ]:
== [887] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x30]] + 1.
= [886] [[For each]] [VAR[I]] in [ [N[2/1]], [N[2/4]] ]:
== [889] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/15]] ]:
=== [890] Let [VAR[p]] be 
([VAR[I]] - [N[0x20]]) × [N[0x10]] + [VAR[F]] - [N[0x30]] + [N[1]].
=== [891] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[p]].
= [885] [[For each]] [VAR[F]] in [ [N[3/1]], [N[3/4]] ]:
== [884] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [I[mule-96[SUP[2]]]], [VAR[F]].
= [912] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [N[2/2]] followed by [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/0]].
= [913] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] 
[ [N[2/2]] followed by [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[dec]], [I[udc1978]].




]FIG]
: "fallback" :
[FIG(steps)[

= [124] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to 
[[character]] ([I[unknown-byte]], [N[2/0]]).
= [125] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/4]]).
= [126] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/2]]).
= [128] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[7/0]]).
= [210] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/11]]).
= [211] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to 
[[character]] ([I[unknown-control]], [N[1/11]] followed by [N[6/12]]).
= [758] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [759] [[Remove][remove an entry]] [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].
= [778] [[For each]] [VAR[bc]] in [ [N[3/1]], [N[3/4]] ]:
== [779] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[unknown-control]], [VAR[bc]]).
= [780] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to 
[[character]] ([I[unknown-control]], [N[3/8]]).
= [781] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to 
[[character]] ([I[unknown-control]], [N[3/9]]).
= [894] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/3]], [ [N[3/5]], [N[3/11]] ], and [N[3/15]]:
== [896] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [VAR[F]].
= [895] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to [I[unassigned-94]].
= [908] [[For each]] [VAR[F]] in [N[3/1]], [N[3/3]], [ [N[4/0]], [N[4/2]] ]:
== [911] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [VAR[F]] ]
to [I[unassigned-94]].


]FIG]
: "iso2022" :
[FIG(steps)[

= [740] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to [CODE(charname)@en[SP]].
= [29] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to [CODE(charname)@en[CMD]].
= [42] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[esc]], [N[6/2]]).
= [43] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to [CODE(charname)@en[PCD]].

]FIG]
: "cns" :
[FIG(steps)[

= [892] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/1]], [N[3/3]], [ [N[3/5]], [N[3/11]] ], and [N[3/15]]:
== [893] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x30]] + 1.

]FIG]
: "mongolian" :
[FIG(steps)[

= [744] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to [CODE(charname)@en[MSP]].

]FIG]
: "naplps" :
[FIG(steps)[

= [52] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS1R]]).
= [53] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS2R]]).

]FIG]
: "marc" :
[FIG(steps)[

= [44] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[6/2]]).
= [63] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[7/0]]).
= [902] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [I[marc]], [N[4/1]].


]FIG]
: "arib" :
[FIG(steps)[

= [904] [[For each]] [VAR[F]] in [ [N[3/9]], [N[3/11]] ]:
== [903] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[arib]], [VAR[F]].


]FIG]
: "vt" :
[FIG(steps)[

= [120] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to
[[character]] ([I[vt]], [I[esc]], [N[6/4]]).
= [121] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to
[[character]] ([I[vt]], [I[esc]], [N[6/11]]).
= [122] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to
[[character]] ([I[vt]], [I[esc]], [N[6/12]]).
= [229] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/1]]).
= [681] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/2]]).
= [773] Set [VAR[state]]'s [F[escape set]] [ [N[3/3]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/3]]).
= [774] Set [VAR[state]]'s [F[escape set]] [ [N[3/4]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/4]]).
= [771] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/8]]).
= [772] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/9]]).


]FIG]
: "vt105" :
[FIG(steps)[

= [783] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[vt105]], [I[esc]], [N[3/1]]).
= [784] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[vt105]], [I[esc]], [N[3/2]]).

]FIG]
: "tektronix" :
[FIG(steps)[

= [405] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [757] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[tektronix]], [I[esc]], [VAR[bc]]).
= [762] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/8]]).
= [763] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/9]]).

]FIG]
: "notektronix" :
[FIG(steps)[

= [205] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [228] [[Remove][remove an entry]] [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].

]FIG]
: "decea" :
[FIG(steps)[

= [905] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[3/0]].
= [906] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/0]].
= [907] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/3]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]].
= [909] [[For each]] [VAR[F]] in [N[3/1]], [N[3/3]], [N[4/1]], and [N[4/2]]:
== [910] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[3/0]].
= [914] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[dec]], [I[udc1978]].


]FIG]
: "mule" :
[FIG(steps)[

= [767] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/1]]).
= [768] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/2]]).
= [769] Set [VAR[state]]'s [F[escape set]] [ [N[3/3]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/3]]).
= [770] Set [VAR[state]]'s [F[escape set]] [ [N[3/4]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/4]]).
= [900] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/1]], [N[3/3]], and [ [N[3/5]], [N[3/8]] ]:
== [899] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[mule-94[SUP[2]]]], [VAR[F]].

]FIG]
: "ks" :
[FIG(steps)[

= [901] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/3]].


]FIG]


]FIG]

]FIG]

* Definitions

[14] 
This document depends on the [CITE[Infra Standard]].

[15] 
The terms
[DFN[for each][For each]],
[DFN[boolean]],
[DFN[byte]],
[DFN[byte sequence]],
[DFN[[F[length]]]],
[DFN[code point]],
[DFN[tuple]],
[DFN[list]],
[DFN[[F[size]]]],
[DFN[append]],
[DFN[extend]],
[DFN[ordered map]],
[DFN[entry]],
[DFN[key]],
[DFN[value]],
[DFN[exists]],
[DFN[remove an entry]],
and
[DFN[is empty]]
are defined by the [CITE[Infra Standard]].


-*-*-

[572] 
A [DFN[range]] [VAR[range]] is a [[tuple]] of two integers 
([DFN[[F[start]]]], [DFN[[F[end]]]]),
where [VAR[range]]'s [F[start]] ≦ [VAR[range]]'s [F[end]].
It represents a set of all the integers [VAR[i]]
that satisfies [VAR[range]]'s [F[start]] ≦ [VAR[i]] ≦ [VAR[range]]'s [F[end]].

[573] 
A value [VAR[i]] is in a [[range]] [VAR[range]] if 
[VAR[i]] is an item in the set represented by [VAR[range]].

@@ switch

-*-*-


[16] 
A [DFN[bit combination]] is a [[byte]].
A [[bit combination]] is represented as "[VAR[X]]/[VAR[Y]]",
where [VAR[X]] and [VAR[Y]] are integers in [ [N[0]], [N[15]] ],
which represents a [[byte]] [VAR[X]] × [N[16]] + [VAR[Y]].

[89] 
To [DFN[append][append to a byte sequence]] a [[bit combination]] [VAR[bc]]
to a [[byte sequence]] [VAR[bytes]], run these steps:

[FIG(steps)[
= [90] Replace [VAR[bytes]]'s content by [VAR[bytes]] followed by [VAR[bc]].
]FIG]

[91] The [DFN[empty byte sequence]] is a [[byte sequence]] whose [[length]]
is [N[0]].


* Notes

@@macro code,
[[SCI]],
[[OSC]],
[[DCS]],
[[APC]]
