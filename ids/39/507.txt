[SEE[ [[ISO/IEC 2022]] ]]

* ISO/IEC 2022 Decoder


@@
[99] 
The [DFN[ISO/IEC 2022 decoder steps]]:
[VAR[byte getter]] : [[byte getter]];
[VAR[initialization steps]] a [[state initialization steps]],
run these steps:

[FIG(steps)[
= [8] Let [VAR[state]] be a new [[state]].
= [1464] Let [VAR[state]]'s [F[input getter]] be the [[8-bit input getter]].
= [327] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "fixed", "fallback", "iso2022" ».
= [9] Run [VAR[initialization steps]] with [VAR[state]].
= [6] Let [VAR[output stream]] be a new [[output stream]].
= [1468] Let [VAR[next]] be [CODE[null]].
= [1456] [[While]] [VAR[next]] is not [I[end-of-file]]:
== [1457] If [VAR[state]]'s [F[current frame length]] is [N[0]]:
=== [1455] Set [VAR[state]]'s [F[current frame length]] to [CODE[null]].
=== [1458] Set [VAR[next]] to an [[end-of-frame]] ([[false]]).
== [1459] Otherwise:
=== [1460] Set [VAR[next]] to the result of running [VAR[input getter]]
with [VAR[byte getter]].
=== [1461] If [VAR[next]] is [I[end-of-file]]:
==== [1462] If [VAR[state]]'s [F[current frame length]] is ''not'' [CODE[null]]:
===== [1463] Set [VAR[next]] to an [[end-of-frame]] ([[true]]).
==== [1466] Set [VAR[state]]'s [F[input getter]] to the [[empty input getter]].
=== [1469] Otherwise:
==== [1471] If [VAR[state]]'s [F[current frame length]] is ''not'' [CODE[null]]:
===== [1470] Set [VAR[state]]'s [F[current frame length]] to
[VAR[state]]'s [F[current frame length]] - 1.
==== [1761] If [VAR[state]]'s [F[current capturing byte]] is ''not'' [CODE[null]]:
===== [1762] Set 
[VAR[state]]'s [F[macro set]] [ [VAR[state]]'s [F[current capturing byte]] ]
to 
[VAR[state]]'s [F[macro set]] [ [VAR[state]]'s [F[current capturing byte]] ]
followed by [VAR[next]].
===== [1792] 
If [VAR[state]]'s [F[macro set]] [ [VAR[state]]'s [F[current capturing byte]] ]'s
[F[length]] is greater than the 
[[maximum sequence length]]:
====== [1793] [[Error][error]].
====== [1794] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
====== [1795] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].
== [1467] [[Process the next input character][process the next input character]]
with [VAR[state]], [VAR[next]].
= [7] 
Return [VAR[output stream]].
]FIG]


[1] A [DFN[state]] is:

[FIG(list members)[

: [DFN[[F[fixed set]]]] : [[Character set][character set]].
: [DFN[[F[escape set]]]] : [[Character set][character set]].
: [DFN[[F[macro set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94 final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[96 final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94[SUP[[VAR[n]]]] final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[96[SUP[[VAR[n]]]] final set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[94[SUP[[VAR[n]]]] final RL set]]]] : [[Ordered map][ordered map]].
Initially, an [[empty][is empty]] [[ordered map]].
: [DFN[[F[C0 designated]]]] : [[C0 set]].  Initially, the [[initial C0 set]].
: [DFN[[F[C1 designated]]]] : [[C1 set]].  Initially, the [[empty C1 set]].
: [DFN[[F[C1 override designated]]]] : [[C1 set]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[G0 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G1 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G2 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G3 designated]]]] : [[G set]], [I[unknown-94]], or [I[unknown-96]].
Initially, [I[unknown-96]].
: [DFN[[F[G0 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G1 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G2 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[G3 RL designated]]]] : [[94[SUP[2]] set]] or [I[unknown-94]].  
Initially, [I[unknown-94]].
: [DFN[[F[Gj designated]]]] : [[94 set]].  Initially, [I[unknown-94]].
: [DFN[[F[S1 designated]]]] : [[94[SUP[2]] set]].
: [DFN[[F[S2 designated]]]] : [[94[SUP[2]] set]].
: [DFN[[F[left designated]]]] : [[G set]] or [[128 set]].
: [DFN[[F[right designated]]]] : [[128 set]].
: [DFN[[F[opaque designated]]]] : [[256 set]].
: [DFN[[F[CR invoked]]]] : [[C element]].
Initially, [I[C1]].
: [DFN[[F[GL invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GR invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GL mode]]]] : [[GL mode]].
Initially, [I[iso2022]].
: [DFN[[F[right mode]]]] : A [[right mode]].
Initially, [I[iso2022]].
: [DFN[[F[shift plane 2 mode]]]] : [I[normal]] or [I[jisx0213]].
Initially, [I[normal]].
: [DFN[[F[bits]]]] : [I[8-bit]] or [I[7-bit]].
Initially, [I[8-bit]].
: [DFN[[F[VT response flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[ISO 4873 Latin-1 flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[Unicode 1.1 flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[UTF-8 GL flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[data syntax 2 default mode]]]] : [I[serial]] or [I[parallel]].
Initially, [I[serial]].
: [DFN[[F[videotex basic kernel flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[current byte sequence]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[current element]]]] : [[C element]] or [[G element]].
: [DFN[[F[current size]]]] : [N[94]] or [N[96]].
: [DFN[[F[current bytes]]]] : [N[1]], [N[2]], or [N[3]].
: [DFN[[F[current I byte]]]] : [[Byte][byte]].
: [DFN[[F[current J byte]]]] : [[Byte][byte]] or [CODE[null]].
: [DFN[[F[current revision byte]]]] : [[Byte][byte]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[current segment length]]]] : Non-negative integer or [CODE[null]].
: [DFN[[F[current segment data]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[current capturing byte]]]] : [CODE[Byte][byte]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[current macro]]]] : [[Macro][macro]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[current frame length]]]] : Non-negative integer or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[decoder state]]]] : One of [[decoder states][decoder state]].
Initially, [[default state]].
: [DFN[[F[previous state]]]] : [[State][state]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[previous GL mode]]]] : [[GL mode]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[previous left designated]]]] : [[G set]] or [[128 set]].
: [DFN[[F[previous code point]]]] : [[Code point][code point]] or [CODE[null]].
Initially, [CODE[null]]

]FIG]

[223] A [DFN[C element]] is [I[C0]] or [I[C1]].

[100] A [DFN[G element]] is [I[G0]], [I[G1]], [I[G2]], [I[G3]], or [I[Gj]].

[1704] A [DFN[GL mode]] is one of:
[I[iso2022]], [I[captain]], [I[telesoftware]], and [I[single]].  

[1291] A [DFN[right mode]] is one of:
[I[iso2022]], 
[I[iso2022jp]],
[I[utf-1]], [I[utf-8]],
[I[single]],
[I[sjis]], 
[I[big5]],
[I[uhc]], [I[johab]],
[I[gb18030]],
and
[I[x-moe-internal]].


[117] A [DFN[maximum sequence length]] is an implementation-specific integer,
e.g. [N[15]].

[94] A [DFN[maximum chunk length]] is an implementation-specific integer,
e.g. 2[SUP[30]] - 1.


[315] 
To [DFN[get invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [302] If [VAR[element]] is [CODE[null]]:
== [303] Return [I[unknown-96]].
= [304] Otherwise, if [VAR[element]] is [I[G0]]:
== [305] Return [VAR[state]]'s [F[G0 designated]].
= [306] Otherwise, if [VAR[element]] is [I[G1]]:
== [307] Return [VAR[state]]'s [F[G1 designated]].
= [308] Otherwise, if [VAR[element]] is [I[G2]]:
== [309] Return [VAR[state]]'s [F[G2 designated]].
= [310] Otherwise, if [VAR[element]] is [I[G3]]:
== [311] Return [VAR[state]]'s [F[G3 designated]].
]FIG]

[796] 
To [DFN[get RL invoked set]] with 
[[state]] [VAR[state]] and [[G element]] or [CODE[null]] [VAR[element]], 
run these steps:

[FIG(steps)[
= [797] If [VAR[element]] is [CODE[null]]:
== [798] Return [I[unknown-94]].
= [799] Otherwise, if [VAR[element]] is [I[G0]]:
== [800] Return [VAR[state]]'s [F[G0 RL designated]].
= [801] Otherwise, if [VAR[element]] is [I[G1]]:
== [802] Return [VAR[state]]'s [F[G1 RL designated]].
= [803] Otherwise, if [VAR[element]] is [I[G2]]:
== [804] Return [VAR[state]]'s [F[G2 RL designated]].
= [805] Otherwise, if [VAR[element]] is [I[G3]]:
== [806] Return [VAR[state]]'s [F[G3 RL designated]].
]FIG]

** Initialization

[20] A [[state initialization steps]] is a set of zero or more steps
that modifies [VAR[state]].  It can modify [VAR[state]] in these ways:

- [21] It [MAY[MAY]] modify values of [VAR[state]]'s 
[F[C0 designated]],
[F[C1 designated]],
[F[G0 designated]],
[F[G1 designated]],
[F[G2 designated]],
[F[G3 designated]],
[F[right designated]],
[F[G0 RL designated]],
[F[G1 RL designated]],
[F[G2 RL designated]],
[F[G3 RL designated]],
[F[CR invoked]],
[F[GL invoked]],
[F[GR invoked]],
[F[GL mode]],
[F[right mode]],
[F[bits]],
[F[VT response flag]],
[F[ISO 4873 Latin-1 flag]],
[F[Unicode 1.1 flag]],
[F[UTF-8 GL flag]],
[F[data syntax 2 default mode]],
[F[videotex basic kernel flag]],
and/or
[F[input getter]].
- [319] It [MAY[MAY]] invoke the steps to [[modify character sets]]
of [VAR[state]] for some [VAR[features]].
- [1898] It [MAY[MAY]] set the [VAR[state]]'s [F[decoder state]] to
[I[before BOM state]]
if [VAR[state]]'s [F[input getter]] is set to
the [[UCS-2BE input getter]],
the [[UCS-4BE input getter]],
or
the [[UTF-16BE input getter]].
-- 
@@
[1899] or UTF-8
- [807] If [VAR[state]]'s [F[G0 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G0 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]].
- [808] If [VAR[state]]'s [F[G1 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G1 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]].
- [809] If [VAR[state]]'s [F[G2 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G2 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]].
- [810] If [VAR[state]]'s [F[G3 RL designated]] is set to a [[94[SUP[2]] set]],
[VAR[state]]'s [F[G3 designated]] [MUST[MUST]] be set to a [[94[SUP[2]] set]].



** Input stream



@@
input stream:

[1791] 
An [DFN[input item]] is 
a [[byte]], 
a [[character]],
[I[end-of-frame]], or 
[I[end-of-file]].

[1818] 
To [DFN[get a UCS input item]] for [VAR[c]], run these steps:

[FIG(steps)[

= [1819] If [VAR[c]] is in [ [N[0x00]], [N[0xFF]] ]:
== [1820] Return a [[bit combination]] whose value is [VAR[c]].
= [1821] Otherwise, if [VAR[c]] is greater than [N[0x10FFFF]]:
== [1822] Return 
[[character]] ([I[unicode]], [I[1.1]], [VAR[c]]).
= [1823] Otherwise:
== [1825] 
@@
If [VAR[state]]'s [F[Unicode 1.1 flag]] is [[true]] and
[VAR[c]] is in range [ XXX ]:
=== [1826] Return
[[character]] ([I[unicode]], [I[1.1]], [VAR[c]]).
== [1824] Return 
a [[code point]] whose value is [VAR[c]].

]FIG]


[1472] 
An [DFN[end-of-frame]] is a [[tuple]] of 
[DFN[[F[incomplete]]]] ([[boolean]]).

-*-*-

[1574] 
A [DFN[byte getter]] is a steps that returns a [CODE[byte]] or [CODE[null]].
It represents an input byte stream.
Whenever invoked, it is expected to return a [[byte]] from the stream it represents,
in order.  It is expected to return a [CODE[null]] after the end of the stream
is reached.


[1780] 
An [DFN[input getter]] is 
the [[empty input getter]],
the [[8-bit input getter]],
the [[UCS-2BE input getter]],
the [[UCS-2LE input getter]].
the [[UCS-4BE input getter]],
the [[UCS-4LE input getter]],
the [[UTF-16BE input getter]],
and
the [[UTF-16LE input getter]].

[1779] 
The [DFN[empty input getter]] run these steps:

[FIG(steps)[

= [1790] Return [I[end-of-file]].

]FIG]


[1775] 
An [DFN[8-bit input getter]] 
run these steps with 
[VAR[state]]
and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1785] Let [VAR[byte]] be the result of running [VAR[getter]].
= [1786] If [VAR[byte]] is [CODE[null]]:
== [1787] Return [I[end-of-file]].
= [1788] Otherwise:
== [1789] Return [VAR[byte]].

]FIG]

[1069] 
To [DFN[get input bytes]] with 
[[byte getter]] [VAR[byte getter]]
and
integer [VAR[n]],
run these steps:

[FIG(steps)[

= [1070] Let [VAR[bytes]] be an [[empty][is empty]] [[list]].
= [1101] Let [VAR[m]] be [VAR[n]].
= [1827] [[While]] [VAR[m]] is greater than [N[0]]:
== [1828] Let [VAR[byte]] be the result of running
[VAR[byte getter]].
== [1829] If [VAR[byte]] is [CODE[null]]:
=== [1830] Return [N[bytes]].
=== [1832] Abort these steps.
== [1831] Otherwise:
=== [1833] [[Append][append]] [VAR[byte]] to [VAR[bytes]].
= [1834] Return [VAR[bytes]].

]FIG]



[1796] 
The [DFN[UCS-2BE input getter]]
run these steps with
[VAR[state]] and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1835] Let [VAR[bytes]] be the result of running the steps to
[[get input bytes]] with [N[2]] and [VAR[byte getter]].
= [1836] If [VAR[bytes]]'s [F[length]] is [N[2]]:
== [1805] Let [VAR[c]] be [VAR[bytes]] [ 0 ] × [N[0x100]] + [VAR[bytes]] [ 1 ].
== [1806] Return the result of
[[getting a UCS input item][get a UCS input item]] [VAR[c]].
= [1799] Otherwise, if [VAR[bytes]]'s [F[length]] is [N[0]]:
== [1800] Return [I[end-of-file]].
= [1797] Otherwise:
== [1465] Set [VAR[state]]'s [F[input getter]] to the [[empty input getter]].
== [1798] Return [CODE[U+FFFD]].

]FIG]

[1807] 
The [DFN[UCS-2LE input getter]]
run these steps with
[VAR[state]] and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1801] Let [VAR[bytes]] be the result of running the steps to
[[get input bytes]] with [N[2]] and [VAR[byte getter]].
= [1802] If [VAR[bytes]]'s [F[length]] is [N[2]]:
== [1803] Let [VAR[c]] be [VAR[bytes]] [ 1 ] × [N[0x100]] + [VAR[bytes]] [ 0 ].
== [1804] Return the result of
[[getting a UCS input item][get a UCS input item]] [VAR[c]].
= [1808] Otherwise, if [VAR[bytes]]'s [F[length]] is [N[0]]:
== [1809] Return [I[end-of-file]].
= [1810] Otherwise:
== [1811] Set [VAR[state]]'s [F[input getter]] to the [[empty input getter]].
== [1849] Return [CODE[U+FFFD]].

]FIG]

[1812] 
The [DFN[UCS-4BE input getter]]
run these steps with
[VAR[state]] and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1813] Let [VAR[bytes]] be the result of running the steps to
[[get input bytes]] with [N[4]] and [VAR[byte getter]].
= [1814] If [VAR[bytes]]'s [F[length]] is [N[4]]:
== [1815] Let [VAR[c]] be 
[VAR[bytes]] [ 0 ] × [N[0x1000000]] +
[VAR[bytes]] [ 1 ] × [N[0x10000]] +
[VAR[bytes]] [ 2 ] × [N[0x100]] +
[VAR[bytes]] [ 3 ].
== [1816] Return the result of
[[getting a UCS input item][get a UCS input item]] [VAR[c]].
= [1817] Otherwise, if [VAR[bytes]]'s [F[length]] is [N[0]]:
== [1837] Return [I[end-of-file]].
= [1838] Otherwise:
== [1839] Set [VAR[state]]'s [F[input getter]] to the [[empty input getter]].
== [1850] Return [CODE[U+FFFD]].

]FIG]

[1840] 
The [DFN[UCS-4LE input getter]]
run these steps with
[VAR[state]] and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1841] Let [VAR[bytes]] be the result of running the steps to
[[get input bytes]] with [N[4]] and [VAR[byte getter]].
= [1842] If [VAR[bytes]]'s [F[length]] is [N[4]]:
== [1843] Let [VAR[c]] be 
[VAR[bytes]] [ 3 ] × [N[0x1000000]] +
[VAR[bytes]] [ 2 ] × [N[0x10000]] +
[VAR[bytes]] [ 1 ] × [N[0x100]] +
[VAR[bytes]] [ 0 ].
== [1844] Return the result of
[[getting a UCS input item][get a UCS input item]] [VAR[c]].
= [1845] Otherwise, if [VAR[bytes]]'s [F[length]] is [N[0]]:
== [1846] Return [I[end-of-file]].
= [1847] Otherwise:
== [1848] Set [VAR[state]]'s [F[input getter]] to the [[empty input getter]].
== [1851] Return [CODE[U+FFFD]].

]FIG]

[1852] 
The [DFN[UTF-16BE input getter]]
run these steps with
[VAR[state]]
and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1860] If [VAR[state]]'s [F[previous character]] is not [CODE[null]]:
== [1861] Let [VAR[char]] be [VAR[state]]'s [F[previous character]].
= [1862] Otherwise:
== [1853] Let [VAR[char]] be the result of running the
[[UCS-2BE input getter]] with [VAR[state]] and [VAR[byte getter]].
= [1854] 
@@
If [VAR[char]] is in [ XXX ]:
== [1857] Set [VAR[char2]] be the result of running the
[[UCS-2BE input getter]] with [VAR[state]] and [VAR[byte getter]].
== 
@@
If [VAR[char]] is in [ XXX ]:
=== [1876] Set [VAR[state]]'s [F[previous code point]] to [CODE[null]].
=== 
@@
Return XXX.
== [1855] Otherwise:
=== [1856] Set [VAR[state]]'s [F[previous code point]] to [VAR[char]].
=== [1863] Return [VAR[char]].
= [1858] Otherwise:
== [1877] Set [VAR[state]]'s [F[previous code point]] to [CODE[null]].
== [1859] Return [VAR[char]].


]FIG]


[1864] 
The [DFN[UTF-16LE input getter]]
run these steps with
[VAR[state]]
and
[[byte getter]] [VAR[byte getter]]:

[FIG(steps)[

= [1865] If [VAR[state]]'s [F[previous character]] is not [CODE[null]]:
== [1866] Let [VAR[char]] be [VAR[state]] and [VAR[state]]'s [F[previous character]].
= [1867] Otherwise:
== [1868] Let [VAR[char]] be the result of running the
[[UCS-2LE input getter]] with [VAR[byte getter]].
= [1869] 
@@
If [VAR[char]] is in [ XXX ]:
== [1870] Set [VAR[char2]] be the result of running the
[[UCS-2LE input getter]] with [VAR[state]] and [VAR[byte getter]].
== 
@@
If [VAR[char]] is in [ XXX ]:
=== [1878] Set [VAR[state]]'s [F[previous code point]] to [CODE[null]].
=== 
@@
Return XXX.
== [1871] Otherwise:
=== [1872] Set [VAR[state]]'s [F[previous code point]] to [VAR[char]].
=== [1873] Return [VAR[char]].
= [1874] Otherwise:
== [1879] Set [VAR[state]]'s [F[previous code point]] to [CODE[null]].
== [1875] Return [VAR[char]].


]FIG]



-*-*-

[1778] 
To [DFN[process the next input character]]
with [VAR[state]] and [VAR[bc]],
run these steps:

[FIG(steps)[

= [1784] Run [VAR[state]]'s [F[decoder state]]'s [[switch]] by [VAR[bc]],
with [VAR[state]].
= [1766] If the previous step asked to [DFN[reconsume]] [VAR[bc]]:
== [1767] Go to the first step of these steps.


]FIG]

[1783] 
The variable [VAR[state]] in these steps is accessible from
the steps 
to [[get a UCS input item]],
to [[emit a character]], and
to [[process a control character]].

** Macros

[1764] 
A [DFN[macro]] is a [[byte sequence]].

[1765] 
In this document, a [[macro]] might be represented as a [[string]],
which is a [CODE[U+0020]]-separated list of tokens.
A token is either a [[bit combination]] or 
a [VAR[token]] from the following table.
A [[bit combination]] represents itself.
One of [VAR[token]] represents [VAR[bytes]] in the same table row.
The list represents a [[macro]] that is the concatenation
of the [[bit combinations][bit combination]] (including those in [VAR[bytes]]),
in order.

,* [VAR[token]] ,* [VAR[bytes]]
,* [CODE[ESC]] , [N[1/11]]
,* [CODE[LS0]] , [N[0/15]]
,* [CODE[LS1]] , [N[0/14]]
,* [CODE[LS1R]] , [N[1/11]] followed by [N[7/14]]
,* [CODE[LS2R]] , [N[1/11]] followed by [N[7/13]]
,* [CODE[LS3R]] , [N[1/11]] followed by [N[7/12]]

[1429] To [DFN[run a macro]] with [VAR[state]] and [VAR[bytes]], run these steps:

[FIG(steps)[

= [1776] [[For each]] [VAR[bc]] in the [[bit combinations][bit combination]] of
[VAR[bytes]], in order:
== [1777] [[Process the next input character][process the next input character]]
with [VAR[state]], [VAR[bc]].

]FIG]


** Output stream

[97] 
An [DFN[output stream]] is a [[list]].
The variable [VAR[output stream]] of the steps of the 
[[ISO/IEC 2022 decoder steps]] represents the output of the decoder.
It is accessible from the steps 
to [[emit a character]] and
to [[emit the EOF]].


[1768] 
When [[ISO/IEC 2022 decoder steps]] returns,
[VAR[output stream]]
contains
zero or more [[characters][character]]
followed by
an [[EOF]].


[4] 
To [DFN[emit a character]] with [[character]] [VAR[char]], 
with [VAR[state]] of the steps to [[process the next input character]],
run these steps:

[FIG(steps)[
=
[115] If [VAR[char]] is
[[character]] ([I[videotex]], [I[96]], [I[7/0]], [VAR[bc]])
where [VAR[bc]] is a [[bit combination]]:
== [116] If [VAR[state]]'s [F[macro set]] [ [VAR[bc]] ] [[exists]]:
=== [1782] [[Run a macro][run a macro]] 
with [VAR[state]],
[VAR[state]]'s [F[macro set]] [ [VAR[bc]] ].
= [1781] Otherwise:
== [5] 
[[Append][append]]
[VAR[char]]
to 
[VAR[output stream]].
]FIG]

[1769] 
To [DFN[emit the EOF]], run these steps:

[FIG(steps)[

= [1770] 
[[Append][append]]
an [[EOF]]
to 
[VAR[output stream]].

]FIG]

[1774] 
Although the steps of the [[ISO/IEC 2022 decoder steps]] is written in the form 
of the steps to return an [VAR[output stream]], 
any [[character]] or [[EOF]] in [VAR[output stream]]
[MAY[MAY]] be made accessible from the application
as soon as it is [[appended][append]] to [VAR[output stream]].
The steps of the [[ISO/IEC 2022 decoder steps]] never modify or rearrange
[[appended][append]] [[characters][character]].

[355] 
When [DFN[error]], run these steps:

[FIG(steps)[
= [356] An error [MAY[may]] be reported to a [[developer console]].
= [153] [[Emit a character][emit a character]] [CODE[U+FFFD]].
]FIG]

;; [386] There is an illegal sequence.

[58] 
When [DFN[deprecated]], run these steps:

[FIG(steps)[
= [59] A warning [MAY[may]] be reported to a [[developer console]].
]FIG]

;; [385] There is a sequence that is discouraged by a relevant specification,
or that is an extension to the ISO/IEC 2022 standard.



** Decoder states

[27] 
The decoder has several [DFN[decoder states]] for processing input 
[[bit combinations][bit combination]].

[719] 
To [DFN[process a control [[character]]]] [VAR[char]], 
with [VAR[state]] of the steps to [[process the next input character]],
[[switch]] by [VAR[char]]:

[FIG(switch)[

:[CODE(charname)@en[ESC]]:
[FIG(steps)[

= [30] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].

]FIG]
:[CODE(charname)@en[LS0]]:
[FIG(steps)[

= [209] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].

]FIG]
:[CODE(charname)@en[LS1]]:
[FIG(steps)[

= [1280] If [VAR[state]]'s [F[GL invoked]] is [I[Gj]]:
== [1281] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].
= [1282] Otherwise:
== [212] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].

]FIG]
:[CODE(charname)@en[LS2]]:
[FIG(steps)[

= [750] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].

]FIG]
:[CODE(charname)@en[LS3]]:
[FIG(steps)[

= [752] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].

]FIG]
:[CODE(charname)@en[LS1R]]:
[FIG(steps)[

= [61] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [101] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [102] Otherwise:
== [127] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
:[CODE(charname)@en[LS2R]]:
[FIG(steps)[

= [129] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [130] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [131] Otherwise:
== [132] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
:[CODE(charname)@en[LS3R]]:
[FIG(steps)[

= [754] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [133] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [134] Otherwise:
== [135] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
:[CODE(charname)@en[SS2]]:
[FIG(steps)[

= [226] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [214] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].

]FIG]
:[CODE(charname)@en[SS3]]:
[FIG(steps)[

= [227] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [216] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].

]FIG]
: [CODE(charname)@en[EXT1]] :
[FIG(steps)[

= [1718] Set [VAR[state]]'s [F[decoder state]] to [I[EXT1 state]].

]FIG]
:([I[marc]], [I[esc]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]:
[FIG(steps)[

= [103] [[Deprecated][deprecated]].
= [31] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [N[1/11]] followed by [VAR[bc]] ]. 
= [968] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].

]FIG]
:([I[vt]], [I[C1]], [VAR[bc]]) where [VAR[bc]] is [N[8/6]] or [N[8/7]]:
[FIG(steps)[

= [789] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bc]] ]. 
= [969] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].

]FIG]
:([I[vt]], [I[esc]], [N[3/12]]):
[FIG(steps)[

= [785] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "vt" ».
= [786] [[Emit][emit a character]] [VAR[char]].

]FIG]
:([I[tektronix]], [I[esc]], [N[0/3]]):
[FIG(steps)[

= [718] Set [VAR[state]]'s [F[C1 designated]] to the result of 
[[getting a C set][get a C set]] with [I[C1]], [I[vt]], [I[C1]].
= [677] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "noescc0", "vt" ».
= [738] [[Emit][emit a character]] [VAR[char]].

]FIG]
:([I[vt]], [I[esc]], [N[7/11]]):
[FIG(steps)[

= [679] Set [VAR[state]]'s [F[decoder state]] to [I[file state]].

]FIG]
:([I[C0]], [VAR[bytes]], [N[1/15]]) where [VAR[bytes]] is in [ [N[4/9]], [N[4/11]] ]:
[FIG(steps)[

= [182] Set [VAR[state]]'s [F[current I byte]] to [VAR[bytes]].
= [199] Set [VAR[state]]'s [F[decoder state]] to [I[US state]].

]FIG]
:([I[videotex]], [I[sound-control]], [VAR[bytes]]) where [VAR[bytes]] is one of [N[8/0]], [N[8/1]], [N[8/2]], [N[8/8]], [N[8/9]], [N[8/12]], [N[9/0]], and [N[9/12]]:
[FIG(steps)[

= [1497] [[Emit][emit a character]] [VAR[char]].
= [1483] Set [VAR[state]]'s [F[decoder state]] to [I[sound control parameter state]].

]FIG]
:([I[videotex]], [I[sound-control]], [VAR[bytes]]) where [VAR[bytes]] is [N[8/10]] or [N[8/11]]:
[FIG(steps)[

= [1498] [[Emit][emit a character]] [VAR[char]].
= [1484] Set [VAR[state]]'s [F[decoder state]] to [I[sound control state]].

]FIG]
: ([I[vt52]], [I[esc]], [N[6/2]]), ([I[vt52]], [I[esc]], [N[6/3]]), ([I[C0]], [N[4/9]], [N[1/4]]), ([I[C1]], [N[4/4]], [VAR[bc]]) where [VAR[bc]] is [N[8/11]], [N[9/0]], [N[9/1]], or [N[9/2]], ([I[C0]], [N[4/10]], [N[1/2]]), ([I[dtvcc]], [I[C0]], [VAR[bc]]) where [VAR[bc]] is in [ [N[1/0]], [N[1/7]] ], ([I[dtvcc]], [I[C1]], [VAR[bc]]) where [VAR[bc]] is in [ [N[8/8]], [N[8/13]] ], ([I[dtvcc]], [I[C2]], [VAR[bc]]) where [VAR[bc]] is in [ [N[0/8]], [N[0/15]] ] :
[FIG(steps)[

= [210] [[Emit][emit a character]] [VAR[char]].
= [211] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1742] Set [VAR[state]]'s [F[current segment length]] to [N[1]].

]FIG]
: ([I[vt52]], [I[C1]], [N[9/9]]), ([I[C0]], [I[C0]], [N[1/12]]), ([I[dtvcc]], [I[C0]], [VAR[bc]]) where [VAR[bc]] in [ [N[1/8]], [N[1/15]] ], ([I[dtvcc]], [I[C1]], [VAR[bc]]) where [VAR[bc]] is [N[9/0]] or [N[9/2]], ([I[dtvcc]], [I[C2]], [VAR[bc]]) where [VAR[bc]] is in [ [N[1/0]], [N[1/7]] ] :
[FIG(steps)[

= [1499] [[Emit][emit a character]] [VAR[char]].
= [722] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1743] Set [VAR[state]]'s [F[current segment length]] to [N[2]].

]FIG]
: ([I[dtvcc]], [I[C1]], [N[9/1]]), ([I[dtvcc]], [I[C2]], [VAR[bc]]) where [VAR[bc]] is in [ [N[1/8]], [N[1/15]] ] :
[FIG(steps)[

= [229] [[Emit][emit a character]] [VAR[char]].
= [681] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1744] Set [VAR[state]]'s [F[current segment length]] to [N[3]].

]FIG]
: ([I[dtvcc]], [I[C1]], [N[9/7]]), ([I[dtvcc]], [I[C3]], [VAR[bc]]) where [VAR[bc]] is in [ [N[8/0]], [N[8/7]] ] :
[FIG(steps)[

= [724] [[Emit][emit a character]] [VAR[char]].
= [732] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1745] Set [VAR[state]]'s [F[current segment length]] to [N[4]].

]FIG]
: ([I[dtvcc]], [I[C3]], [VAR[bc]]) where [VAR[bc]] is in [ [N[8/8]], [N[8/15]] ] :
[FIG(steps)[

= [735] [[Emit][emit a character]] [VAR[char]].
= [736] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1746] Set [VAR[state]]'s [F[current segment length]] to [N[5]].

]FIG]
: ([I[dtvcc]], [I[C1]], [VAR[bc]]) where [VAR[bc]] is in [ [N[9/8]], [N[9/15]] ] :
[FIG(steps)[

= [737] [[Emit][emit a character]] [VAR[char]].
= [771] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1747] Set [VAR[state]]'s [F[current segment length]] to [N[6]].

]FIG]
: ([I[dtvcc]], [I[C3]], [VAR[bc]]) where [VAR[bc]] is in [ [N[9/0]], [N[9/15]] ] :
[FIG(steps)[


= [772] [[Emit][emit a character]] 
[[character]] ([I[dtvcc]], [[C3]], [VAR[bc]] & [N[0b11100000]]).
= [771] Set [VAR[state]]'s [F[decoder state]] to [I[control parameter state]].
= [1747] Set [VAR[state]]'s [F[current segment length]] to [VAR[bc]] & [N[0b00011111]].

]FIG]
: ([I[dtvcc]], [I[C2]], [VAR[bc]]) where [VAR[bc]] in [ [N[0/8]], [N[0/15]] :
:([I[C1]], [N[4/0]], [VAR[bc]]) where [VAR[bc]] is in [ [N[8/0]], [N[8/7]] ]:
[FIG(steps)[

= [1538] [[Emit][emit a character]] [VAR[char]].
= [1539] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].

]FIG]
:([I[C1]], [N[4/0]], [VAR[bc]]) where [VAR[bc]] is in [ [N[9/0]], [N[9/7]] ]:
[FIG(steps)[

= [1536] [[Emit][emit a character]] [VAR[char]].
= [1537] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
= [1112] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[videotex]], [I[l]].


]FIG]
: [CODE(charname)@en[P-MACRO]] :
[FIG(steps)[

= [1166] Set [VAR[state]]'s [F[decoder state]] to [I[macro state]].

]FIG]
:[CODE(charname)@en[SOS]]:
[FIG(steps)[

= [1705] Set [VAR[state]]'s [F[previous GL mode]] to [VAR[state]]'s [F[GL mode]].
= [1713] Set [VAR[state]]'s [F[previous left designated]]
to [VAR[state]]'s [F[left designated]].
= [1706] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1707] [[Emit][emit a character]] [VAR[char]].

]FIG]
:[CODE(charname)@en[ST]]:
[FIG(steps)[

= [1709] If [VAR[state]]'s [F[previous GL mode]] is ''not'' [CODE[null]]:
== [1708] Set [VAR[state]]'s [F[GL mode]] to [VAR[state]]'s [F[previous GL mode]].
== [1714] Set [VAR[state]]'s [F[left designated]] to
[VAR[state]]'s [F[previous left designated]].
== [1710] Set [VAR[state]]'s [F[previous GL mode]] to [CODE[null]].
= [1711] [[Emit][emit a character]] [VAR[char]].

]FIG]
:[CODE(charname)@en[PCD]]:
[FIG(steps)[

= [729] [[Emit][emit a character]] [VAR[char]].
= [65] Set [VAR[state]]'s [F[decoder state]] to [I[PCD state]].

]FIG]
:[CODE(charname)@en[CMD]]:
[FIG(steps)[

= [730] [[Emit][emit a character]] [VAR[char]].
= [1272] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
= [48] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].

]FIG]
:([I[unknown-control]], [CODE[null]], [VAR[bytes]]) where [VAR[bytes]] is a [[byte sequence]]:
[FIG(steps)[

= [660] [[Emit][emit a character]] [VAR[char]].
= [1273] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
= [659] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].

]FIG]
:([I[deprecated]], [VAR[c]]) where [VAR[c]] is a [[character]]:
[FIG(steps)[

= [756] [[Deprecated][deprecated]].
= [755] [[Process][process a control character]] [VAR[c]].

]FIG]
:Otherwise:
[FIG(steps)[

= [13] [[Emit][emit a character]] [VAR[char]].

]FIG]


]FIG]


[1451] 
To [DFN[initialize by DI]] [VAR[state]], run these steps:

[FIG(steps)[

= [1452] If [VAR[state]]'s [F[current I byte]] is [N[2/0]]:
== [932] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1437] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1422] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/1 4/9 ESC 2/2 4/4 ESC 2/6 4/0 ESC 2/4 4/2 ESC 2/9 4/10 ESC 2/14 3/8 ESC 2/11 2/0 4/1 LS0 LS2R".
= [1424] Otherwise, if [VAR[state]]'s [F[current I byte]] is [N[4/1]]:
== [1475] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1476] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1477] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/1 4/9 LS0".
== [1478] Set [VAR[state]]'s [F[C1 designated]] to the result of
[[getting a C set][get a C set]] with
[I[C1]], [I[videotex]], [I[sound-control]].
== [1479] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[videotex]], [I[sound-tone]].
= [1425] Otherwise, if [VAR[state]]'s [F[current I byte]] is [N[4/0]]:
== [1482] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1481] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1480] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/1 4/9 ESC 2/2 4/4 ESC 2/8 4/9 ESC 2/6 4/0 ESC 2/4 2/9 4/2 ESC 2/10 4/10 LS0 LS2R".
= [1426] Otherwise:
== [1445] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[captain]], [VAR[state]]'s [F[current I byte]].
== [1454] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].

]FIG]

[1527] 
To [DFN[initialize data syntax 2]] with 
[VAR[state]] 
and
[I[serial]], [I[parallel]], or [CODE[null]] [VAR[mode]],
run these steps:

[FIG(steps)[

= [1651] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "videotex" ».
= [1543] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1528] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/1 4/10 ESC 2/8 4/0 ESC 2/9 6/3 ESC 2/10 6/2 ESC 2/11 6/4 LS0 LS2R".
= [1529] If [VAR[mode]] is [I[serial]]:
== [1530] [[Run a macro][run a macro]] with
[VAR[state]], "ESC 2/2 4/0".
= [1531] Otherwise, if [VAR[mode]] is [I[parallel]]:
== [1532] [[Run a macro][run a macro]] with
[VAR[state]], "ESC 2/2 4/1".
= [1533] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]



-*-*-

[2] 
Each [[decoder state]] has its [[switch]].
There are the following [[decoder states][decoder state]]:

*** Default state

[3] The [DFN[default state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[1/15]] ] :
[FIG(steps)[

= [11] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
= [717] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [1420] If [VAR[state]]'s [F[GL mode]] is [I[captain]]:
== [1427] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
== [1428] Set [VAR[state]]'s [F[decoder state]] to [I[CAPTAIN DI state]].
= [1613] Otherwise, if [VAR[state]]'s [F[GL mode]] is [I[telesoftware]]:
== [1577] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[telesoftware-ci]], [VAR[bc]]).
== [1612] If [VAR[state]]'s [F[videotex basic kernel flag]] is [[false]]:
=== [1578] Set [VAR[state]]'s [F[decoder state]] to [I[TELESOFTWARE CI state]].
= [1712] Otherwise:
== [1109] If [VAR[state]]'s [F[GL mode]] is [I[single]]:
=== [1079] Let [VAR[set]] be [VAR[state]]'s [F[left designated]].
== [1080] Otherwise, if [VAR[state]]'s [F[GL mode]] is [I[iso2022]]:
=== [314] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
== [1288] If [VAR[state]]'s [F[right mode]] is [I[iso2022jp]] and 
[VAR[bc]] is [N[7/15]]:
=== [1289] Set [VAR[state]]'s [F[decoder state]] to [I[foreign right state]].
=== [1290] [[Reconsume][reconsume]] [VAR[bc]].
== [507] Otherwise, if [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
=== [318] [[Emit a character][emit a character]] 
[VAR[state]]'s [F[fixed set]] [ [VAR[bc]] ].
== [422] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
=== [440] Set [VAR[state]]'s [F[decoder state]] to [I[left unassigned state]].
=== [441] [[Reconsume][reconsume]] [VAR[bc]].
== [424] Otherwise:
=== [448] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
=== [449] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
==== [185] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bc]] ].
=== [450] Otherwise:
==== [451] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
==== [487] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
==== [452] Set [VAR[state]]'s [F[decoder bytes]] to [I[left leading byte state]].

]FIG]
: [ [N[8/0]], [N[9/15]] ] :
[FIG(steps)[

= [1081] If [VAR[state]]'s [F[right mode]] is ''not'' [I[iso2022]]:
== [1082] Set [VAR[state]]'s [F[decoder state]] to [I[foreign right state]].
== [1083] [[Reconsume][reconsume]] [VAR[bc]].
= [834] Otherwise, if [VAR[state]]'s [F[CR invoked]] is [I[C1]]:
== [1559] If [VAR[state]]'s [F[C1 override designated]] is [CODE[null]]:
=== [26] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
== [1560] Otherwise:
=== [1561] Let [VAR[set]] be [VAR[state]]'s [F[C1 override designated]].
== [28] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] ].
= [835] Otherwise, if [VAR[state]]'s [F[CR invoked]] is [I[C0]]:
== [836] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
== [837] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [334] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [1084] If [VAR[state]]'s [F[right mode]] is ''not'' [I[iso2022]]:
== [1085] Set [VAR[state]]'s [F[decoder state]] to [I[foreign right state]].
== [1086] [[Reconsume][reconsume]] [VAR[bc]].
= [312] Otherwise, if [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [317] [[Emit a character][emit a character]] 
[VAR[state]]'s [F[fixed set]] [ [VAR[bc]] ].
= [313] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [423] Set [VAR[state]]'s [F[decoder state]] to [I[right unassigned state]].
== [430] [[Reconsume][reconsume]] [VAR[bc]].
= [431] Otherwise:
== [432] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [471] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [473] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
== [474] Otherwise:
=== [475] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [490] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [476] Set [VAR[state]]'s [F[decoder bytes]] to [I[right leading byte state]].

]FIG]
: [[end-of-frame]] :
[FIG(steps)[

= [1473] If [VAR[bc]]'s [F[incomplete]] is [[true]]:
== [1474] [[Error][error]].
= [1423] Set [VAR[state]]'s [F[GL mode]] to [I[captain]].
= [1421] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [I[end-of-file]] :
[FIG(steps)[

= [1772] [[Emit the EOF][emit the EOF]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1773] [[Emit a character][emit a character]] [VAR[bc]].

]FIG]


]FIG]


*** SS state

[217] The [DFN[SS state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[2/0]], [[7/15]] ], [ [[10/0]], [[15/15]] ]:
[FIG(steps)[

= [344] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [343] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [345] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [346] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [528] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [349] [[Error][error]].
== [354] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [364] [[Reconsume][reconsume]] [VAR[bc]].
= [444] Otherwise, if [VAR[set]] is [I[unknown-94]] or [I[unknown-96]]:
== [271] [[Error][error]].
== [438] Set [VAR[state]]'s [F[decoder state]] to [I[SS unassigned state]].
== [442] [[Reconsume][reconsume]] [VAR[bc]].
= [447] Otherwise:
== [272] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [316] If [VAR[state]]'s [F[current bytes]] is [N[1]]:
=== [326] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
=== [443] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [329] Otherwise:
=== [332] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]] & [N[0b01111111]].
=== [341] Set [VAR[state]]'s [F[current J byte]] to [CODE[null]].
=== [347] Set [VAR[state]]'s [F[decoder bytes]] to [I[SS leading byte state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [357] [[Error][error]].
= [359] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [358] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** EXT1 state

[1719] The [DFN[EXT1 state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[1/15]] ]:
[FIG(steps)[

= [1720] Let [VAR[set]] be the result of 
[[getting a C set][get a C set]]
[I[C0]], [I[dtvcc]], [I[C2]].
= [1722] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [1721] Let [VAR[set]] be the result of 
[[getting a G set][get a G set]]
[N[96]], [N[1]], [I[dtvcc]], [I[G2]].
= [1722] [[Emit][emit a character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[8/0]], [N[9/15]] ]:
[FIG(steps)[

= [1723] Let [VAR[set]] be the result of 
[[getting a C set][get a C set]]
[I[C1]], [I[dtvcc]], [I[C3]].
= [1724] [[Process a control character][process a control character]] 
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [1725] Let [VAR[set]] be the result of 
[[getting a G set][get a G set]]
[N[96]], [N[1]], [I[dtvcc]], [I[G3]].
= [1726] [[Emit][emit a character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:Otherwise:
[FIG(steps)[

= [1727] [[Error][error]].
= [1728] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1729] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Left leading byte state

[482] The [DFN[left leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [495] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [320] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [323] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
== [324] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [325] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current J byte]]).
== [328] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [330] [[Reconsume][reconsume]] [VAR[bc]].
= [321] Otherwise:
== [496] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [449] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [331] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
=== [498] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [336] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [499] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [502] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [503] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
=== [504] Otherwise:
==== [335] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]].
==== [501] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [337] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [492] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
= [493] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [494] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current J byte]]).
= [483] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [485] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Right leading byte state

[338] The [DFN[right leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/1]], [N[7/14]] ]:
[FIG(steps)[

= [648] Let [VAR[set]] be the result of
[[getting RL invoked set][get RL invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [649] If [VAR[set]] is [I[unassigned-94]]:
== [792] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
== [793] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [794] [[Reconsume][reconsume]] [VAR[bc]].
= [795] Otherwise:
== [650] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]].
== [651] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
== [687] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [339] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [340] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [421] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
== [426] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [427] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current J byte]]).
== [428] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [429] [[Reconsume][reconsume]] [VAR[bc]].
= [433] Otherwise:
== [434] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [436] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [437] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [453] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [454] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [455] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [456] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [457] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [458] Otherwise:
==== [459] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [461] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [462] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [464] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
= [465] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [466] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current J byte]]).
= [467] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [468] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** SS leading byte state

[469] The [DFN[SS leading byte state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ], [ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [470] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [525] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [526] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [527] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [477] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]], [N[7/15]], [N[10/0]], or [N[15/15]]:
== [478] [[Error][error]].
== [479] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
== [480] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
=== [481] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current J byte]]).
== [486] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [488] [[Reconsume][reconsume]] [VAR[bc]].
= [489] Otherwise:
== [491] Set [VAR[state]]'s [F[current bytes]] to [VAR[set]]'s [[byte length]].
== [505] If [VAR[state]]'s [F[current bytes]] is [N[2]]:
=== [506] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by [VAR[bc]] & [N[0b01111111]].
=== [509] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [510] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [511] Otherwise, if [VAR[state]]'s [F[current bytes]] is [N[3]]:
=== [512] If [VAR[state]]'s [F[current J byte]] is [CODE[null]]:
==== [513] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]] & [N[0b01111111]].
=== [514] Otherwise:
==== [515] Let [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]] followed by
[VAR[state]]'s [F[current J byte]] followed by [VAR[bc]] & [N[0b01111111]].
==== [517] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
==== [518] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [519] [[Error][error]].
= [520] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
= [521] If [VAR[state]]'s [F[current J byte]] is ''not'' [CODE[null]]:
== [522] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current J byte]]).
= [523] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [524] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Left unassigned state

[446] The [DFN[left unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [536] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [532] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [533] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [534] [[Reconsume][reconsume]] [VAR[bc]].
= [535] Otherwise:
== [531] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [529] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [530] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Right unassigned state

[537] The [DFN[right unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [538] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [539] If [[is 96 size]] [VAR[set]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [540] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [541] [[Reconsume][reconsume]] [VAR[bc]].
= [542] Otherwise:
== [543] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]] & [N[0b01111111]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [544] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [545] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** SS unassigned state

[546] The [DFN[SS unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [547] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [548] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [549] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [550] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [551] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [552] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[2/0]] or [N[7/15]]:
== [553] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [554] [[Reconsume][reconsume]] [VAR[bc]].
= [555] Otherwise:
== [556] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:[ [N[10/0]], [N[15/15]] ]:
[FIG(steps)[

= [559] Let [VAR[set1]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [560] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [561] Let [VAR[set2]] be [VAR[state]]'s [F[G2 designated]].
= [562] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [563] Let [VAR[set2]] be [VAR[state]]'s [F[G3 designated]].
= [564] If [[is 96 size]] [VAR[set1]] is [[false]] and
[[is 96 size]] [VAR[set2]] is [[false]] and
[VAR[bc]] is [N[10/0]] or [N[15/15]]:
== [565] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [566] [[Reconsume][reconsume]] [VAR[bc]].
= [567] Otherwise:
== [568] [[Emit][emit a character]]
a [[character]] ([I[unassinged]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [557] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [558] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape state

[32] The [DFN[escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[


:[ [N[0/0]], [N[1/15]] ]:
[FIG(steps)[

= [204] If [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] [[exists]]:
== [720] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [225] [[Process a control character][process a control character]]
[VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].
= [206] Otherwise:
== [207] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
== [208] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
== [224] [[Reconsume][reconsume]] [VAR[bc]].



]FIG]
: [N[2/0]] :
[FIG(steps)[

= [136] Set [VAR[state]]'s [F[decoder state]] to [I[escape announce state]].

]FIG]
: [N[2/1]] :
[FIG(steps)[

= [218] Set [VAR[state]]'s [F[current element]] to [I[C0]].
= [157] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/2]] :
[FIG(steps)[

= [230] Set [VAR[state]]'s [F[current element]] to [I[C1]].
= [158] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [N[2/3]] :
[FIG(steps)[

= [388] Set [VAR[state]]'s [F[decoder state]] to [I[escape 3 state]].

]FIG]
: [N[2/4]] :
[FIG(steps)[

= [598] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple state]].

]FIG]
: [[2/5]] :
[FIG(steps)[

= [999] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system state]].

]FIG]
: [[2/6]] :
[FIG(steps)[

= [978] Set [VAR[state]]'s [F[decoder state]] to [I[escape revision state]].

]FIG]
: [[2/8]] :
[FIG(steps)[

= [104] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [294] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [105] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/9]] :
[FIG(steps)[

= [111] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [168] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [170] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/10]] :
[FIG(steps)[

= [169] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [235] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [295] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/11]] :
[FIG(steps)[

= [234] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [296] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [297] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/12]] :
[FIG(steps)[

= [279] [[Deprecated][deprecated]].
= [277] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [278] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [281] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/13]] :
[FIG(steps)[

= [280] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [283] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [285] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/14]] :
[FIG(steps)[

= [282] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [298] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [299] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/15]] :
[FIG(steps)[

= [284] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [300] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [301] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
:[ [N[3/0]], [N[3/15]] ], [ [N[6/0]], [N[7/14]] ]:
[FIG(steps)[

= [40] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [35] [[Process a control character][process a control character]]
[VAR[char]] be [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].

]FIG]
:[ [N[4/0]], [N[5/15]] ]:
[FIG(steps)[

= [36] If [VAR[state]]'s [F[C1 override designated]] is [CODE[null]]:
== [1562] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [1563] Otherwise:
== [1564] Let [VAR[set]] be [VAR[state]]'s [F[C1 override designated]].
= [39] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [38] [[Process a control character][process a control character]]
[VAR[set]] [ [VAR[bc]] + [N[0x40]] ].


]FIG]
:Otherwise:
[FIG(steps)[

= [33] Set [VAR[state]]'s [F[current byte sequence]] to an [[empty byte sequence]].
= [34] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [156] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape announce state

[137] The [DFN[escape announce state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/5]] ], [ [N[3/8]], [N[3/15]] ]:
[FIG(steps)[

= [828] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [829] [[Process][process a control character]]
[[character]] ([I[unknown-control]], [CODE[null]], 
[N[1/11]] followed by [N[2/0]] followed by [VAR[bc]]).

]FIG]
: [N[3/6]] :
[FIG(steps)[

= [387] [[Deprecated][deprecated]].
= [833] Set [VAR[state]]'s [F[CR invoked]] to [I[C0]].
= [381] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[3/7]] :
[FIG(steps)[

= [830] [[Deprecated][deprecated]].
= [832] Set [VAR[state]]'s [F[CR invoked]] to [I[C1]].
= [831] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[4/1]], [N[7/14]] ]:
[FIG(steps)[

= [138] Let [VAR[announce]] be [VAR[bc]] - 0x40.
= [139] If [VAR[announce]] is one of:
[N[1]],
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [140] Set [VAR[state]]'s [F[GL invoked]] be [I[G0]].
= [141] If [VAR[announce]] is [N[1]] or [N[2]]:
== [142] Set [VAR[state]]'s [F[GR invoked]] be [CODE[null]].
= [143] If [VAR[announce]] is one of:
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [144] Set [VAR[state]]'s [F[GR invoked]] be [I[G1]].
= [145] If [VAR[announce]] is one of:
[N[12]],
[N[13]],
or
[N[14]]:
== [146] Set [VAR[state]]'s [F[2/0 designated]] be [CODE(charname)@en[SP]].
== [147] Set [VAR[state]]'s [F[7/14 designated]] be [CODE(charname)@en[DEL]].
== [838] If [VAR[state]]'s [F[ISO 4873 Latin-1 flag]] is [[true]]:
=== [839] 
[[Run a macro][run a macro]]
with
[VAR[state]],
"[CODE(charname)@en[ESC]] [N[2/8]] [N[4/2]] [CODE(charname)@en[ESC]] [N[2/13]] [N[4/1]]".
= [148] If [VAR[announce]] is one of:
[N[11]],
[N[12]],
[N[13]],
or
[N[14]]:
== [149] Set [VAR[state]]'s [F[bits]] be [I[8-bit]].
= [150] If [VAR[announce]] is [N[10]]:
== [151] Set [VAR[state]]'s [F[bits]] be [I[7-bit]].
= [380] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [152] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/0]].
= [155] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [154] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape 3 state

[389] The [DFN[escape 3 state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/15]] ]:
[FIG(steps)[

= [397] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [398] Set [VAR[state]]'s [F[decoder state]] to [I[escape ctext version state]].

]FIG]
:[ [N[3/0]], [N[3/9]] ]:
[FIG(steps)[

= [396] [[Emit][emit a character]]
[[character]] ([I[vt]], [N[2/3]], [VAR[bc]]).
= [390] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[3/10]], [N[3/15]] ]:
[FIG(steps)[

= [749] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [747] [[Process][process a control character]]
[[character]] ([I[unknown-control]], [CODE[null]], 
[N[1/11]] followed by [N[2/3]] followed by [VAR[bc]]).

]FIG]
: Otherwise :
[FIG(steps)[

= [392] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/3]].
= [394] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [395] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape ctext version state

[399] The [DFN[escape ctext version state]] switches by the [[bit combination]] 
[VAR[bc]]:

[FIG(switch)[

: [N[3/0]] :
[FIG(steps)[

= [401] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[3/1]] :
[FIG(steps)[

= [400] [[Error][error]].
= [403] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[3/2]], [N[3/15]] ]:
[FIG(steps)[

= [751] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [753] [[Process][process a control character]]
[[character]] ([I[unknown-control]], [CODE[null]], 
[N[1/11]] followed by [N[2/3]] followed by [VAR[state]]'s [F[current I byte]]
followed by [VAR[bc]]).

]FIG]
:[ [N[4/0]], [N[5/15]] ]:
[FIG(steps)[

= [1363] If [VAR[state]]'s [F[current I byte]] is [N[2/0]] or [N[2/1]]:
== [1369] Let [VAR[set]] be the result of
[[getting a C set][get a C set]] with
[I[C1]], [I[videotex]], [VAR[state]]'s [F[current I byte]].
== [1370] [[Emit a character][emit a character]] [ [VAR[bc]] + [N[0x40]] ].
== [1371] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1364] Otherwise:
== [1365] [[Error][error]].
== [1366] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
== [1367] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].
== [1368] [[Reconsume][reconsume]] [VAR[bc]].


]FIG]
:Otherwise:
[FIG(steps)[

= [404] [[Error][error]].
= [1274] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
= [407] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].
= [408] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape revision state

[979] The [DFN[escape revision state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[4/0]], [N[7/14]] ]:
[FIG(steps)[

= [980] Set [VAR[state]]'s [F[current revision byte]] to [VAR[bc]].
= [984] Set [VAR[state]]'s [F[decoder state]] to [I[IRR state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [981] Set [VAR[state]]'s [F[current byte sequence]] to [N[2/6]].
= [982] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [983] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** IRR state

[985] The [DFN[IRR state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[1/11]] :
[FIG(steps)[

= [986] Set [VAR[state]]'s [F[decoder state]] to [I[IRR escape state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [989] [[Error][error]].
= [987] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [988] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** IRR escape state

[990] The [DFN[IRR state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/1]], [N[2/2]], [N[2/4]], [ [N[2/8]], [N[2/15]] ] :
[FIG(steps)[

= [991] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].
= [992] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
: Otherwise :
[FIG(steps)[

= [993] [[Error][error]].
= [996] Set [VAR[state]]'s [F[current revision byte]] to [CODE[null]].
= [994] Set [VAR[state]]'s [F[decoder state]] to [I[escape state]].
= [995] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape control state

[159] The [DFN[escape control state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [1373] If [VAR[state]]'s [F[current revision byte]] is [CODE[null]]:
== [1374] Let [VAR[bytes]] be [VAR[bc]].
= [1375] Otherwise:
== [1372] Let [VAR[bytes]] be 
[VAR[bc]] followed by [VAR[state]]'s [F[current revision byte]].
= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [164] Set [VAR[state]]'s [F[C0 designated]] to the result of 
[[getting a C set][get a C set]] with [I[C0]], [I[C0]], [I[bytes]].
= [232] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [1534] If [VAR[bytes]] is [N[4/0]] or [N[4/1]]:
=== [1535] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[protocol]], [VAR[bytes]]).
=== [1540] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [233] Set [VAR[state]]'s [F[C1 designated]] to the result of 
[[getting a C set][get a C set]] with [I[C1]], [I[C1]], [VAR[bytes]].
== [1570] Set [VAR[state]]'s [F[C1 override designated]] to [CODE[null]].
= [382] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [787] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [713] Set [VAR[state]]'s [F[C0 designated]] to the [[empty C0 set]].
= [167] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [714] Set [VAR[state]]'s [F[C1 designated]] to the [[empty C1 set]].
== [1571] Set [VAR[state]]'s [F[C1 override designated]] to [CODE[null]].
= [162] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape graphic state

[236] The [DFN[escape graphic state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/5]] ]:
[FIG(steps)[

= [254] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [255] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [1298] If [VAR[state]]'s [F[current revision byte]] is [CODE[null]]:
== [1301] Set [VAR[bytes]] be [VAR[bc]].
= [1300] Otherwise:
== [1299] Set [VAR[bytes]] be 
[VAR[bc]] followed by [VAR[state]]'s [F[current revision byte]].
= [237] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [402] If 
[VAR[state]]'s [F[VT response flag]] is [[true]],
[VAR[state]]'s [F[current size]] is [N[94]], and 
[VAR[bc]] is [N[3/1]]:
=== [410] [[Emit a character][emit a character]]
([I[vt]], [N[2/8]], [VAR[bc]]).
== [411] Otherwise:
=== [41] If [VAR[state]]'s [F[current size]] is [N[94]]:
==== [238] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
=== [46] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
==== [47] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
=== [964] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [239] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [412] If 
[VAR[state]]'s [F[VT response flag]] is [[true]],
[VAR[state]]'s [F[current size]] is [N[94]], and 
[VAR[bc]] is [N[3/1]]:
=== [413] [[Emit a character][emit a character]]
([I[vt]], [N[2/9]], [VAR[bc]]).
== [414] Otherwise:
=== [64] If [VAR[state]]'s [F[current size]] is [N[94]]:
==== [66] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
=== [119] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
==== [183] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
=== [965] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [286] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [184] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [200] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
== [201] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [202] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
== [966] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [288] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [417] If 
[VAR[state]]'s [F[VT response flag]] is [[true]] and
[VAR[state]]'s [F[current size]] is [N[96]]:
=== [418] [[Emit a character][emit a character]]
([I[vt]], [N[2/15]], [VAR[bc]]).
== [419] Otherwise:
=== [203] If [VAR[state]]'s [F[current size]] is [N[94]]:
==== [219] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
=== [220] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
==== [221] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
=== [967] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [383] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [166] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [241] Let [VAR[set]] be [I[unknown-94]].
= [415] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [416] Let [VAR[set]] be [I[unknown-96]].
= [242] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [243] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [960] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [244] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [160] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [961] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [246] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [161] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [962] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [248] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [165] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [963] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [251] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [252] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape graphic I state

[253] The [DFN[escape graphic I state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [1302] If [VAR[state]]'s [F[current revision byte]] is [CODE[null]]:
== [1303] Set [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]]
followed by [VAR[bc]] 
followed by [VAR[state]]'s [F[current revision byte]].
= [1304] Otherwise:
== [1305] Set [VAR[bytes]] be
[VAR[state]]'s [F[current I byte]]
followed by [VAR[bc]].
= [257] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [222] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [240] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
== [256] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [275] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
= [258] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [259] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [276] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
== [287] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [289] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
= [290] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [291] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [293] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
== [678] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [690] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
= [292] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [691] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [692] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ].
== [693] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [694] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ].
= [384] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].


]FIG]
: Otherwise :
[FIG(steps)[

= [247] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [260] Let [VAR[set]] be [I[unknown-94]].
= [250] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [249] Let [VAR[set]] be [I[unknown-96]].
= [261] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [262] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [956] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [263] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [264] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [957] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [265] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [266] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [958] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [267] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [268] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [959] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [269] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [270] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape multiple state

[599] The [DFN[escape multiple state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/8]] :
[FIG(steps)[

= [606] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [607] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [608] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/9]] :
[FIG(steps)[

= [609] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [610] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [611] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/10]] :
[FIG(steps)[

= [612] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [613] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [614] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/11]] :
[FIG(steps)[

= [618] [[Deprecated][deprecated]].
= [619] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [620] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [621] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/12]] :
[FIG(steps)[

= [622] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [623] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [624] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/13]] :
[FIG(steps)[

= [625] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [626] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [627] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/14]] :
[FIG(steps)[

= [628] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [629] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [630] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [631] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [615] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [616] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic state]].

]FIG]
: [N[3/0]], [ [N[3/2]], [N[4/4]] ], [ [N[4/8]], [N[4/14]] ], [ [N[5/2]], [N[7/14]] ]:
[FIG(steps)[

= [1310] If [VAR[state]]'s [F[current revision byte]] is [CODE[null]]:
== [1311] Set [VAR[bytes]] be [VAR[bc]].
= [1312] Otherwise:
== [1313] Set [VAR[bytes]] be [VAR[bc]] followed by
[VAR[state]]'s [F[current revision byte]].
= [605] If [VAR[bc]] is ''not'' [N[4/0]], [N[4/1]], or [N[4/2]]:
== [788] [[Deprecated][deprecated]].
= [695] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
= [637] Set [VAR[state]]'s [F[G0 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
= [1286] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[3/1]] :
[FIG(steps)[

= [902] Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [I[marc]], [N[3/1]].
= [1715] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].

]FIG]
:[ [N[4/5]], [N[4/6]], [N[4/7]], [N[4/15]], [N[5/0]], [N[5/1]] ]:
[FIG(steps)[

= [1314] If [VAR[state]]'s [F[current revision byte]] is ''not'' [CODE[null]]:
== [1315] [[Error][error]].
= [1283] [[Deprecated][deprecated]].
= [1284] Set [VAR[state]]'s [F[Gj designated]] to
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[jphone]], [VAR[bc]].
= [1285] Set [VAR[state]]'s [F[GL invoked]] to [I[Gj]].
= [1287] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1316] If [VAR[state]]'s [F[current revision byte]] is ''not'' [CODE[null]]:
== [1317] [[Error][error]].
= [601] Set [VAR[state]]'s [F[current byte sequence]] be [N[2/4]].
= [603] Set [VAR[state]]'s [F[decoder state]] to [I[escape unassigned state]].
= [604] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape multiple graphic state

[617] The [DFN[escape multiple graphic state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/5]] ]:
[FIG(steps)[

= [632] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [633] Set [VAR[state]]'s [F[decoder state]] to [I[escape multiple graphic I state]].

]FIG]
:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [1306] If [VAR[state]]'s [F[current revision byte]] is [CODE[null]]:
== [1307] Set [VAR[bytes]] be [VAR[bc]].
= [1308] Otherwise:
== [1309] Set [VAR[bytes]] be [VAR[bc]] followed by
[VAR[state]]'s [F[current revision byte]].
= [634] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [635] If [VAR[state]]'s [F[current size]] is [N[94]] and 
[VAR[bc]] is [N[4/0]], [N[4/1]], or [N[4/2]]:
=== [636] [[Deprecated][deprecated]].
== [696] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [698] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [699] Set [VAR[state]]'s [F[G0 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [700] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [701] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [702] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [639] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [638] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [640] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [703] Set [VAR[state]]'s [F[G1 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [704] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [705] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [706] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [641] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [642] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [707] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [708] Set [VAR[state]]'s [F[G2 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [709] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [710] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [711] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [643] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [644] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [712] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [790] Set [VAR[state]]'s [F[G3 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [791] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [811] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [812] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [645] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [245] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [362] Let [VAR[set]] be [I[unknown-94]].
= [363] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [322] Let [VAR[set]] be [I[unknown-96]].
= [365] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [366] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [952] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [367] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [368] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [953] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [369] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [370] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [954] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [371] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [372] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [955] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [375] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [376] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape multiple graphic I state

[662] The [DFN[escape multiple graphic I state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [1318] If [VAR[state]]'s [F[current revision byte]] is [CODE[null]]:
== [1319] Set [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by
[VAR[bc]].
= [1320] Otherwise:
== [1321] Set [VAR[bytes]] be 
[VAR[state]]'s [F[current I byte]] followed by
[VAR[bc]] followed by
[VAR[state]]'s [F[current revision byte]].
= [663] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [664] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [813] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [814] Set [VAR[state]]'s [F[G0 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [815] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [816] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [820] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [665] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [666] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [817] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [821] Set [VAR[state]]'s [F[G1 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [822] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [823] Set [VAR[state]]'s [F[G1 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [824] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [667] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [668] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [818] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [825] Set [VAR[state]]'s [F[G2 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [826] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [938] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [943] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [669] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [670] If [VAR[state]]'s [F[current size]] is [N[94]]:
=== [819] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [944] Set [VAR[state]]'s [F[G3 RL designated]] to 
[VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ].
== [945] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
=== [946] Set [VAR[state]]'s [F[G3 designated]] to 
[VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ].
=== [947] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [671] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [377] If [VAR[state]]'s [F[current size]] is [N[94]]:
== [378] Let [VAR[set]] be [I[unknown-94]].
= [379] Otherwise, if [VAR[state]]'s [F[current size]] is [N[96]]:
== [391] Let [VAR[set]] be [I[unknown-96]].
= [393] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [406] Set [VAR[state]]'s [F[G0 designated]] to [VAR[set]].
== [948] Set [VAR[state]]'s [F[G0 RL designated]] to [I[unassigned-94]].
= [409] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [420] Set [VAR[state]]'s [F[G1 designated]] to [VAR[set]].
== [949] Set [VAR[state]]'s [F[G1 RL designated]] to [I[unassigned-94]].
= [425] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [435] Set [VAR[state]]'s [F[G2 designated]] to [VAR[set]].
== [950] Set [VAR[state]]'s [F[G2 RL designated]] to [I[unassigned-94]].
= [439] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [445] Set [VAR[state]]'s [F[G3 designated]] to [VAR[set]].
== [951] Set [VAR[state]]'s [F[G3 RL designated]] to [I[unassigned-94]].
= [460] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].
= [463] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape coding system state

[1000] The [DFN[escape coding system state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/0]] :
[FIG(steps)[

= [1004] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system 0 state]].

]FIG]
: [N[2/1]] :
[FIG(steps)[

= [1005] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system moe state]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [1006] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system wo state]].

]FIG]
: [N[3/0]], [N[4/0]] :
[FIG(steps)[

= [1121] [[Emit][emit a character]]
[[character]] ([I[protocol]], [N[4/0]]).
= [1691] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022" ».
= [1040] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1035] Set [VAR[state]]'s [F[right mode]] to [I[iso2022]].
= [1507] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[3/4]], [N[4/1]] :
[FIG(steps)[

= [1024] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "videotex" ».
= [1118] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/1 4/11 ESC 2/2 4/6 ESC 2/8 4/2 ESC 2/9 5/7 ESC 2/10 7/12 ESC 2/15 5/7 LS0 LS1R".
= [1703] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[3/8]] :
[FIG(steps)[

= [1119] [[Emit][emit a character]]
[[character]] ([I[protocol]], [VAR[bc]]).
= [1037] If [VAR[state]]'s [F[UTF-8 GL flag]] is [[true]]:
== [1072] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1073] Otherwise:
== [1074] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
== [1078] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [1036] Set [VAR[state]]'s [F[right mode]] to [I[utf-8]].
= [1508] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[3/13]] :
[FIG(steps)[

= [1120] [[Emit][emit a character]]
[[character]] ([I[protocol]], [VAR[bc]]).
= [1509] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/2]] :
[FIG(steps)[

= [1039] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
== [1110] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [1038] Set [VAR[state]]'s [F[right mode]] to [I[utf-1]].
= [1510] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/3]] :
[FIG(steps)[

= [1687] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "videotex" ».
= [1419] Set [VAR[state]]'s [F[GL mode]] to [I[captain]].
= [1418] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/4]] :
[FIG(steps)[

= [1506] Set [VAR[state]]'s [F[decoder state]] to [I[data syntax 2 state]].

]FIG]
: [N[4/5]], [N[4/6]], [N[4/8]] :
[FIG(steps)[

= [1688] [[Modify character sets][modify character sets]]
of [VAR[state]] for
« "iso2022", "videotex" ».
= [1690] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1689] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/7]] :
[FIG(steps)[

= [1075] If [VAR[state]]'s [F[UTF-8 GL flag]] is [[true]]:
== [1076] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1077] Otherwise:
== [1012] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
== [1111] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [1041] Set [VAR[state]]'s [F[right mode]] to [I[utf-8]].
= [1511] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[5/0]], [N[5/15]] ]:
[FIG(steps)[

= [975] Set [VAR[state]]'s [F[G1 designated]] to the result of 
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[videotex]], [I[t100alphageometric]].
= [1362] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1001] Set [VAR[state]]'s [F[decoder state]] to 
[I[escape coding system unassigned state]].
= [1002] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Escape coding system 0 state

[1007] The [DFN[escape coding system 0 state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[3/0]] :
[FIG(steps)[

= [1011] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
= [1105] Set [VAR[state]]'s [F[right mode]] to [I[single]].
= [1108] Set [VAR[state]]'s [F[left designated]] to  
the result of 
[[getting a 128 set][get a 128 set]] with
[I[single]], [I[barcode]].
= [1107] Set [VAR[state]]'s [F[right designated]] to
[VAR[state]]'s [F[left designated]].
= [1106] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1008] Set [VAR[state]]'s [F[decoder state]] to 
[I[escape coding system unassigned state]].
= [1003] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape coding system moe state

[1013] The [DFN[escape coding system moe state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[2/0]], [N[2/15]] ] :
[FIG(steps)[

= [1022] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [1014] Set [VAR[state]]'s [F[decoder state]] to [I[escape coding system moe I state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1015] Set [VAR[state]]'s [F[decoder state]] to 
[I[escape coding system unassigned state]].
= [1009] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Escape coding system moe I state

[1018] The [DFN[escape coding system moe I state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/15]] ]:
[FIG(steps)[

= [1023] Let [VAR[n]] be 
([F[state]]'s [F[current I byte]] - [N[0x20]]) × [N[16]] + [VAR[bc]] - [N[0x30]].
= [1043] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1045] If [VAR[n]] is in [N[1]]:
== [1047] Set [VAR[state]]'s [F[right mode]] to [I[single]].
== [1048] Set [VAR[state]]'s [F[right designated]] 
to the result of 
[[getting a 128 set][get a 128 set]] with
[I[ct]], [I[koi8-r]].
= [1170] Otherwise, if [VAR[n]] is in [N[2]]:
== [1171] Set [VAR[state]]'s [F[right mode]] to [I[single]].
== [1172] Set [VAR[state]]'s [F[right designated]] 
to the result of 
[[getting a 128 set][get a 128 set]] with
[I[ct]], [I[koi8-u]].
= [1173] If [VAR[n]] is in [ [N[3]], [N[11]] ]:
== [1174] Set [VAR[state]]'s [F[right mode]] to [I[single]].
== [1175] Set [VAR[state]]'s [F[right designated]] 
to the result of 
[[getting a G set][get a G set]] with
[N[128]], [N[1]], [I[cp]], [N[1250]] + [VAR[n]] - 3.
= [1049] Otherwise, if [VAR[n]] is [N[12]]:
== [1050] Set [VAR[state]]'s [F[right mode]] to [I[sjis]].
== [1292] Set [VAR[state]]'s [F[S1 designated]] to the result of
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[94[SUP[2]]]], [N[4/2]] followed by [N[4/0]].
== [1294] Set [VAR[state]]'s [F[S2 designated]] to the result of
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[sjis2]], [I[ms]].
== [1297] Set [VAR[state]]'s [F[shift plane 2 mode]] to [I[normal]].
= [1046] Otherwise, if [VAR[n]] is [N[13]]:
== [1051] Set [VAR[state]]'s [F[right mode]] to [I[sjis]].
== [1295] Set [VAR[state]]'s [F[S1 designated]] to the result of
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[94[SUP[2]]]], [N[4/15]].
== [1293] Set [VAR[state]]'s [F[S2 designated]] to the result of
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[94[SUP[2]]]], [N[5/0]].
== [1296] Set [VAR[state]]'s [F[shift plane 2 mode]] to [I[jisx0213]].
= [1052] Otherwise, if [VAR[n]] is [N[14]]:
== [1053] Set [VAR[state]]'s [F[right mode]] to [I[big5]].
= [1054] Otherwise, if [VAR[n]] is [N[15]]:
== [1055] Set [VAR[state]]'s [F[right mode]] to [I[johab]].
= [1056] Otherwise, if [VAR[n]] is [N[16]]:
== [1057] Set [VAR[state]]'s [F[right mode]] to [I[uhc]].
= [1058] Otherwise, if [VAR[n]] is [N[17]]:
== [1059] Set [VAR[state]]'s [F[right mode]] to [I[iso2022]].
== [1060] Set [VAR[state]]'s [F[G1 designated]] 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [I[cns]], [N[1]].
== [1061] Set [VAR[state]]'s [F[G2 designated]] 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [I[euctw2]].
= [1062] Otherwise, if [VAR[n]] is [N[18]]:
== [1063] Set [VAR[state]]'s [F[right mode]] to [I[iso2022]].
== [1064] Set [VAR[state]]'s [F[G1 designated]] to 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/15]].
== [1065] Set [VAR[state]]'s [F[G2 designated]] to 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/9]].
== [1066] Set [VAR[state]]'s [F[G3 designated]] to 
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[jis]], [I[jisx0212jisx0213]].
= [1067] Otherwise, if [VAR[n]] is [N[19]] or [N[20]]:
== [1068] Set [VAR[state]]'s [F[right mode]] to [I[gb18030]].
= [1042] Otherwise:
== [1044] Set [VAR[state]]'s [F[right mode]] to [I[x-moe-internal]].
= [1071] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].



]FIG]
: Otherwise :
[FIG(steps)[

= [1019] Set [VAR[state]]'s [F[decoder state]] to 
[I[escape coding system unassigned state]].
= [1010] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape coding system wo state

[1021] The [DFN[escape coding system wo state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/15]] ]:
[FIG(steps)[

= [1025] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [1139] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment state]].

]FIG]
: [N[4/0]], [N[4/3]], [N[4/5]] :
[FIG(steps)[

= [1880] Set [VAR[state]]'s [F[input getter]] to the [[UCS-2BE input getter]].
= [1881] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/1]], [N[4/4]], [N[4/6]] :
[FIG(steps)[

= [1882] Set [VAR[state]]'s [F[input getter]] to the [[UCS-4BE input getter]].
= [1883] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/10]], [N[4/11]], [N[4/12]] :
[FIG(steps)[

= [1884] Set [VAR[state]]'s [F[input getter]] to the [[UTF-16BE input getter]].
= [1886] Set [VAR[state]]'s [F[previous code point]] to [CODE[null]].
= [1885] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[4/2]] :
[FIG(steps)[

= [1279] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
with
[I[vts]], [I[opaque]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1027] Set [VAR[state]]'s [F[decoder state]] to 
[I[escape coding system unassigned state]].
= [1028] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape coding system unassigned state

[1033] The [DFN[escape coding system unassigned state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[2/15]] ]:
[FIG(steps)[

= [1030] Do nothing.

]FIG]
:[ [N[3/0]], [N[3/15]] ]:
[FIG(steps)[

= [1034] [[Error][error]].
= [1275] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
= [1025] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].

]FIG]
: Otherwise :
[FIG(steps)[

= [1029] [[Error][error]].
= [1031] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1032] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Escape unassigned state

[106] The [DFN[escape unassigned state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [107] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [110] If [VAR[state]]'s [F[current byte sequence]]'s [F[length]]
is equal to the [[maximum sequence length]]:
== [500] [[Error][error]].
== [508] Set [VAR[state]]'s [F[decoder state]] to [I[escape trailer state]].

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [108] Set [VAR[state]]'s [F[current byte sequence]] to 
[VAR[state]]'s [F[current byte sequence]] followed by [VAR[bc]].
= [114] [[Emit][emit a character]] 
a [[character]] ([I[esc]], [VAR[state]]'s [F[current byte sequence]]).
= [109] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [472] [[Error][error]].
= [484] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [497] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Escape trailer state

[516] The [DFN[escape trailer state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [600] Do nothing.

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [602] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [647] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [646] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Foreign right state

[1087] The [DFN[foreign right state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[7/15]], [N[15/15]] ]:
[FIG(steps)[

= [1090] If [VAR[state]]'s [F[right mode]] is [I[single]]:
== [1091] Let [VAR[set]] be [VAR[state]]'s [F[right designated]].
== [1092] [[Emit a character][emit a character]]
[VAR[set]] [ [VAR[bc]] & 0b01111111 ].
[NOTE[
[1117] Control characters are not interpreted.
]NOTE]
== [1094] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1097] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[iso2022jp]]:
== [1335] If [VAR[state]]'s [F[current I byte]] is 
in [ [N[10/1]], [N[14/15]] ], [N[15/13]], [N[15/14]]:
=== [1336] Let [VAR[set]] be [VAR[state]]'s [F[94 final set]] [ [N[4/9]] ].
=== [1337] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
=== [1341] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1340] Otherwise:
=== [1324] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
=== [1325] Set [VAR[state]]'s [F[decoder state]] to [I[foreign right first state]].
= [1093] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[utf-1]]:
==
@@
= [1104] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[utf-8]]:
==
@@ [[get a UCS input item]]
= [1096] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[sjis]]:
== [1342] If [VAR[state]]'s [F[current I byte]] is 
in [ [N[10/1]], [N[13/15]] ]:
=== [1343] Let [VAR[set]] be [VAR[state]]'s [F[94 final set]] [ [N[4/9]] ].
=== [1344] [[Emit a character][emit a character]] 
[VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
=== [1345] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1346] Otherwise:
===
@@
= [1098] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[big5]]:
==
@@
= [1099] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[uhc]]:
==
@@
= [1100] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[johab]]:
==
@@
= [1102] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[gb18030]]:
==
@@ [[get a UCS input item]]
= [1103] Otherwise, if [VAR[state]]'s [F[right mode]] is [I[x-moe-internal]]:
==
@@

]FIG]
:Otherwise:
[FIG(steps)[

= [1088] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1089] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]



*** Foreign right first state

[1326] The [DFN[foreign right first state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1327] If [VAR[state]]'s [F[right mode]] is [I[iso2022jp]]:
== [1322] If [VAR[state]]'s [F[current I byte]] is in [ [N[7/15]], [N[9/8]] ] and
[VAR[bc]] is in [ [N[2/1]], [N[7/14]] ]:
=== [1323] Let [VAR[first]] be [VAR[state]]'s [F[current I byte]] - [N[0x7F]].
=== [1332] Let [VAR[bytes]] be [VAR[first]] followed by [VAR[bc]].
=== [1334] Let [VAR[set]] be [VAR[state]]'s [F[S2 designated]].
=== [1333] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [1347] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1348] Otherwise, if [VAR[state]]'s [F[current I byte]] is 
in [ [N[15/0]], [N[15/12]] ] and
[VAR[bc]] is 
@@
...:
=== [1349] Let [VAR[set]] be the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[sjis2]], [I[docomo]].
=== [1339] Let [VAR[bytes]] be 
@@
...
=== [1350] [[Emit a character][emit a character]] [VAR[set]] [ [VAR[bytes]] ].
=== [1351] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1352] Otherwise:
=== [1338] If [VAR[state]]'s [F[current I byte]] is in [ [N[7/15]], [N[9/15]] ]:
==== [1353] [[Emit][emit a character]] a [[code point]] whose value is 
[VAR[state]]'s [F[current I byte]].
=== [1354] Otherwise:
==== [1355] [[Emit][emit a character]] 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
=== [1357] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
=== [1356] [[Reconsume][reconsume]] [VAR[bc]].
= [1329] Otherwise:
==
@@


]FIG]
:Otherwise:
[FIG(steps)[

= [1328] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[state]]'s [F[current I byte]]).
= [1330] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1331] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]



*** Extended segment state

[1140] The [DFN[extended segment state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[8/0]], [N[15/15]] ]:
[FIG(steps)[

= [1144] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
= [1145] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment length state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1141] [[Error][error]].
= [1142] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1143] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Extended segment length state

[1146] The [DFN[extended segment length state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[8/0]], [N[15/15]] ]:
[FIG(steps)[

= [1147] Set [VAR[state]]'s [F[current segment length]] to
(([VAR[state]]'s [F[current J byte]] - [N[128]]) × [N[128]]) + ([VAR[bc]] - [N[128]]).
= [1148] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1149] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1151] [[Error][error]].
== [1152] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1150] Otherwise:
== [1145] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment data state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1153] [[Error][error]].
= [1154] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1155] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Extended segment data state

[1156] The [DFN[extended segment data state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[0/0]], [N[0/1]], [ [N[0/3]], [N[15/15]] ]:
[FIG(steps)[

= [1158] Set [VAR[state]]'s [F[current segment data]] to
[VAR[state]]'s [F[current segment data]] followed by [VAR[bc]].
= [1159] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [1160] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [92] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-f]], [VAR[state]]'s [F[current I byte]]).
== [93] [[For each]] [VAR[bc]] in 
the [[bit combinations][bit combination]] in
[VAR[state]]'s [F[current segment data]], in order:
=== [95] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-data]], [VAR[bc]]).
== [1161] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[0/2]] :
[FIG(steps)[

= [1217] Let [VAR[set]] be the result of
[[getting a CT character set][get a CT character set]]
with
[VAR[state]]'s [F[current I byte]] and 
[VAR[state]]'s [F[current segment data]].
= [1212] Set [VAR[state]]'s [F[current segment data]] to
[VAR[state]]'s [F[current segment data]] followed by [VAR[bc]].
= [1213] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [1218] If [VAR[set]] is ''not'' [CODE[null]]:
== [1224] Set [VAR[state]]'s [F[current CT set]] to [VAR[set]].
== [1228] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
== [1225] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment text state]].
== [1219] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
=== [1220] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1221] Otherwise:
== [773] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-f]], [VAR[state]]'s [F[current I byte]]).
== [774] [[For each]] [VAR[bc]] in 
the [[bit combinations][bit combination]] in
[VAR[state]]'s [F[current segment data]], in order:
=== [1157] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-data]], [VAR[bc]]).
== [1164] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-data]], [VAR[bc]]).
== [1214] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
=== [1216] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1215] Otherwise:
=== [1572] Set [VAR[state]]'s [F[current CT set]] to the result of
[[getting a 256 set][get a 256 set]] with
[I[ct]], [I[extended-segment-data]].
=== [1505] Set [VAR[state]]'s [F[decoder state]] to [I[extended segment text state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [98] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-f]], [VAR[state]]'s [F[current I byte]]).
= [731] [[For each]] [VAR[bc]] in 
the [[bit combinations][bit combination]] in
[VAR[state]]'s [F[current segment data]], in order:
== [733] [[Emit][emit a character]]
[[character]] ([I[ct]], [I[extended-segment-data]], [VAR[bc]]).
= [734] [[Error][error]].
= [1162] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]


*** Extended segment text state

[1222] The [DFN[extended segment text state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1223] Let [VAR[set]] be [VAR[state]]'s [F[current CT set]].
= [1226] Set [VAR[state]]'s [F[current segment data]] to
[VAR[state]]'s [F[current segment data]] followed by [VAR[bc]].
= [1227] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [1229] If [VAR[set]] is a [[94 set]], [[96 set]], or [[128 set]]:
== [1242] Let [VAR[bytes]] be [VAR[bc]] & [N[0b01111111]].
== [1230] If [VAR[set]] [ [VAR[bytes]] ] [[exists]]:
=== [1232] Let [VAR[char]] be [VAR[set]] [ [VAR[bytes]] ].
== [1233] Otherwise:
=== [1234] Let [VAR[char]] be 
[[character]] ([I[unknown-byte]], [CODE[null]], [VAR[bc]]).
== [1244] [[Emit][emit a character]] [VAR[char]].
== [1235] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1573] Otherwise, if [VAR[set]] is a [[256 set]]:
== [1581] [[Emit][emit a character]] [VAR[set]] [ [VAR[bc]] ].
== [1583] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1231] Otherwise, if [VAR[set]] is a [[94[SUP[2]] set]] or [[256[SUP[2]] set]]:
== [1237] If [VAR[state]]'s [F[current segment data]]'s [F[length]] is [N[2]]:
=== [1251] If [VAR[set]] is a [[94[SUP[2]] set]]:
==== [1238] Let [VAR[bytes]] be 
[VAR[state]]'s [F[current segment data]]'s first byte & [N[0b01111111]]
followed by 
[VAR[state]]'s [F[current segment data]]'s second byte & [N[0b01111111]].
=== [1252] Otherwise, if [VAR[set]] is a [[256[SUP[2]] set]]:
==== [1253] Let [VAR[bytes]] be [VAR[state]]'s [F[current segment data]].
=== [1243] If [VAR[set]] [ [VAR[bytes]] ] [[exists]]:
==== [1241] Let [VAR[char]] be [VAR[set]] [ [VAR[bytes]] ].
==== [1246] [[Emit][emit a character]] [VAR[char]].
=== [1247] Otherwise:
==== [1248] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], [CODE[null]],
[VAR[state]]'s [F[current segment data]]'s first byte).
==== [1249] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], [CODE[null]],
[VAR[state]]'s [F[current segment data]]'s second byte).
=== [1245] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
== [1262] Otherwise, if [VAR[state]]'s [F[current I byte]] is [N[3/0]]:
=== [1264] If [VAR[state]]'s [F[current segment data]] is in [ [N[0/0]], [N[7/15]] ]:
==== [1265] Let [VAR[char]] be a [[code point]] whose value is [VAR[bc]].
==== [1267] [[Emit][emit a character]] [VAR[char]].
==== [1266] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [1236] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1239] If [VAR[state]]'s [F[current segment data]]'s [F[length]] is ''not'' [N[0]]:
=== [1240] [[Error][error]].
== [1254] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1256] If [VAR[state]]'s [F[current segment data]]'s [F[length]] is ''not'' [N[0]]:
== [1257] [[Emit][emit a character]]
[[character]] ([I[unknown-byte]], [CODE[null]], 
[VAR[state]]'s [F[current segment data]]).
= [1255] [[Error][error]].
= [1259] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1260] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Macro state

[1576] The [DFN[macro state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[4/0]], [N[4/1]] :
[FIG(steps)[

= [1759] If [VAR[state]]'s [F[current capturing byte]] is ''not' [CODE[null]]:
== [1760] [[Error][error]].
= [1614] Set [VAR[state]]'s [F[decoder state]] to [I[macro start state]].
= [1615] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].

]FIG]
:[ [N[4/2]], [N[4/14]] ]:
[FIG(steps)[

= [1597] [[Emit][emit a character]]
[[character]] ([I[param]], [VAR[bc]]).

]FIG]
: [N[4/15]] :
[FIG(steps)[

= [1616] Set [VAR[state]]'s [F[current capturing byte]] to [CODE[null]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1604] [[Error][error]].
= [1607] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1609] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Macro start state

[1732] The [DFN[macro start state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[2/0]], [N[7/15]] ]:
[FIG(steps)[

= [1733] Set [VAR[state]]'s [F[current capturing byte]] to [VAR[bc]].
= [1758] Set 
[VAR[state]]'s [F[macro set]] [ [VAR[state]]'s [F[current capturing byte]] ]
to the [[empty byte sequence]].
= [1734] If [VAR[state]]'s [F[current I byte]] is [N[4/0]]:
== [1735] Set [VAR[state]]'s [F[decoder state]] to [I[macro data state]].
= [1736] Otherwise, if [VAR[state]]'s [F[current I byte]] is [N[4/1]]:
== [1737] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1738] [[Error][error]].
= [1739] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1740] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Macro data state

[1741] The [DFN[macro data state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[9/4]] ], [ [N[9/6]], [N[15/15]] ]:
[FIG(steps)[

= [1748] Do nothing.

]FIG]
: [N[9/5]] :
[FIG(steps)[

= [1752] Set [VAR[state]]'s [F[decoder state]] to [I[macro data macro state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1749] [[Error][error]].
= [1750] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1751] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Macro data macro state

[1753] The [DFN[macro data macro state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[4/15]] :
[FIG(steps)[

= [1754] Set [VAR[state]]'s [F[decoder state]] to [I[macro state]].
= [1755] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1756] Set [VAR[state]]'s [F[decoder state]] to [I[macro data state]].
= [1757] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Before BOM state

[1887] The [DFN[before BOM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [CODE[U+FEFF]] :
[FIG(steps)[

= [1890] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [CODE[U+FFFE]] :
[FIG(steps)[

= [1892] If [VAR[state]]'s [F[current input getter]] is the [[UCS-2BE getter]]:
== [1893] Set [VAR[state]]'s [F[current input getter]] tp the [[UCS-2LE getter]].
= [1894] Otherwise, if [VAR[state]]'s [F[current input getter]] is the [[UCS-4BE getter]]:
== [1895] Set [VAR[state]]'s [F[current input getter]] tp the [[UCS-4LE getter]].
= [1896] Otherwise, if [VAR[state]]'s [F[current input getter]] is the [[UTF-16BE getter]]:
== [1897] Set [VAR[state]]'s [F[current input getter]] tp the [[UTF-16LE getter]].
= [1891] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

@@ UTF-8 BOM

= [1888] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1889] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** Data syntax 2 state

[1512] The [DFN[data syntax 2 state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[4/0]] :
[FIG(steps)[

= [1521] Let [VAR[mode]] be [VAR[state]]'s [F[data syntax 2 default mode]].
= [1520] If [VAR[state]]'s [F[current I byte]] is [N[6/3]] or [N[6/4]]:
== [1522] Set [VAR[mode]] to [I[parallel]].
= [1523] Run the steps to [[initialize data syntax 2]] with 
[VAR[state]] and [VAR[mode]].

]FIG]
:[ [N[4/1]], [N[7/14]] ]:
[FIG(steps)[

= [1513] If [VAR[bc]] is in [ [N[6/0]], [N[6/4]] ]:
== [1514] Set [VAR[state]]'s [F[bits]] to [I[7-bit]].
= [1515] If [VAR[bc]] is in [ [N[6/1]], [N[6/4]] ]:
== [1516] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [1517] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[profile]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [1518] Let [VAR[mode]] be [VAR[state]]'s [F[data syntax 2 default mode]].
= [1519] If [VAR[state]]'s [F[current I byte]] is [N[6/3]] or [N[6/4]]:
== [1524] Set [VAR[mode]] to [I[parallel]].
= [1525] Run the steps to [[initialize data syntax 2]] with 
[VAR[state]] and [VAR[mode]].
= [1526] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** US state

[213] The [DFN[US state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[2/0]], [N[2/1]] :
[FIG(steps)[

= [1403] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[us]], [VAR[bc]]).
= [1580] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
= [1404] Set [VAR[state]]'s [F[decoder state]] to [I[US terminal state]].

]FIG]
:[ [N[2/2]], [N[2/14]] ], [N[3/0]], [N[3/11]], [N[3/12]], [N[3/13]] :
[FIG(steps)[

= [655] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1550] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
== [1552] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[1/15]] followed by [VAR[bc]].
== [1567] Set [VAR[state]]'s [F[C1 override designated]] to [CODE[null]].
== [1553] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [656] Otherwise:
== [657] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1401] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [658] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
: [N[2/15]] :
[FIG(steps)[

= [672] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1660] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1640] Set [VAR[state]]'s [F[decoder state]] to [I[US reset state]].
= [673] Otherwise:
== [675] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1400] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [676] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
: [N[3/1]], [N[3/2]] :
[FIG(steps)[

= [683] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1541] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
== [1542] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[1/15]] followed by [VAR[bc]].
== [1565] Set [VAR[state]]'s [F[C1 override designated]] to the result of
[[getting a C set][get a C set]] with
[I[C1]], [I[videotex]], [I[geometric-c1]].
== [1544] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [684] Otherwise:
== [997] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1399] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [998] [[Reconsume][reconsume]] [VAR[bc]].


]FIG]
: [N[3/4]], [N[3/5]] :
[FIG(steps)[

= [1376] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1545] Set [VAR[state]]'s [F[GL mode]] to [I[single]].
== [1546] Set [VAR[state]]'s [F[left designated]] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[1/15]] followed by [VAR[bc]].
== [1547] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1377] Otherwise:
== [1378] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1398] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1379] [[Reconsume][reconsume]] [VAR[bc]].


]FIG]
: [N[3/14]] :
[FIG(steps)[

= [1380] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1579] Set [VAR[state]]'s [F[GL mode]] to [I[telesoftware]].
== [1575] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1381] Otherwise:
== [1382] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1397] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1383] [[Reconsume][reconsume]] [VAR[bc]].


]FIG]
: [N[3/15]] :
[FIG(steps)[

= [1384] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1628] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1617] Set [VAR[state]]'s [F[decoder state]] to [I[TRANSPARENT state]].
= [1385] Otherwise:
== [1386] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1396] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1387] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
:[ [N[4/0]], [N[7/15]] ]:
[FIG(steps)[

= [1388] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1548] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[protocol]], [N[1/15]] followed by [VAR[bc]]).
== [1549] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1568] Set [VAR[state]]'s [F[C1 override designated]] to [CODE[null]].
== [1551] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1389] Otherwise:
== [1390] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
== [1395] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
== [1391] [[Reconsume][reconsume]] [VAR[bc]].


]FIG]
:Otherwise:
[FIG(steps)[

= [1392] If [VAR[state]]'s [F[current I byte]] is [N[4/10]]:
== [1393] [[Error][error]].
== [1566] Set [VAR[state]]'s [F[GL mode]] to [I[iso2022]].
== [1569] Set [VAR[state]]'s [F[C1 override designated]] to [CODE[null]].
= [654] Otherwise:
== [1394] [[Emit][emit a character]]
[[character]] ([I[C0]], [VAR[state]]'s [F[current I byte]], [N[1/15]]).
= [215] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [273] [[Reconsume][reconsume]] [VAR[bc]].


]FIG]

]FIG]

*** US terminal state

[1402] The [DFN[US terminal state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[4/0]] :
[FIG(steps)[

= [1405] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[us]], [VAR[bc]]).
= [1406] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[4/1]], [N[7/14]] ]:
[FIG(steps)[

= [1407] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[us]], [VAR[bc]]).

]FIG]
: [N[7/15]] :
[FIG(steps)[

= [1408] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[us]], [VAR[bc]]).
= [1409] Set [VAR[state]]'s [F[decoder state]] to [I[US terminal delete state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1411] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1410] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** US terminal delete state

[1412] The [DFN[US terminal delete state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[4/0]], [N[5/15]] ]:
[FIG(steps)[

= [1413] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[us]], [VAR[bc]]).
= [1414] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:[ [N[6/0]], [N[7/15]] ]:
[FIG(steps)[

= [1415] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[us]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [1416] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1417] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** US reset state

[1641] The [DFN[US reset state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[4/0]], [N[4/5]] :
[FIG(steps)[

= [1655] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [1656] Set [VAR[state]]'s [F[decoder state]] to [I[US reset row state]].

]FIG]
:[ [N[4/1]], [N[4/4]] ]:
[FIG(steps)[

= [1643] If [VAR[bc]] is [N[4/1]] or [N[4/3]]:
== [1644] Let [VAR[mode]] be [I[serial]].
= [1645] Otherwise, if [VAR[bc]] is [N[4/2]] or [N[4/4]]:
== [1646] Let [VAR[mode] be [I[parallel]].
= [1642] Run the steps to [[initialize data syntax 2]] 
with [VAR[state]] and [VAR[mode]].
= [1647] If [VAR[bc]] is [N[4/1]] or [N[4/2]]:
== [1648] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[reset]], [VAR[bc]]).

]FIG]
: [N[4/15]] :
[FIG(steps)[

= [1671] If [VAR[state]]'s [F[previous state]] is ''not'' [CODE[null]]:
== [1672] Set [VAR[state]]'s [F[G0 designated]] to 
[VAR[state]]'s [F[previous state]]'s [F[G0 designated]].
== [1673] Set [VAR[state]]'s [F[G2 designated]] to 
[VAR[state]]'s [F[previous state]]'s [F[G2 designated]].
== [1674] Set [VAR[state]]'s [F[GL invoked]] to 
[VAR[state]]'s [F[previous state]]'s [F[GL invoked]].
== [1675] Set [VAR[state]]'s [F[GR invoked]] to 
[VAR[state]]'s [F[previous state]]'s [F[GR invoked]].
== [1677] Set [VAR[state]]'s [F[C1 designated]] to 
[VAR[state]]'s [F[previous state]]'s [F[C1 designated]].
== [1678] If [VAR[state]]'s [F[C1 designated]] is equal to the result of 
[[getting a C set][get a C set]] with
[I[C1]], [I[C1]], [N[4/0]]:
=== [1676] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/2 4/0".
== [1679] Otherwise, if [VAR[state]]'s [F[C1 designated]] is equal to the result of
[[getting a C set][get a C set]] with
[I[C1]], [I[C1]], [N[4/1]].
= [1680] [[Emit][emit a character]]
[[character] ([I[videotex]], [I[reset]], [VAR[bc]]).

]FIG]
:Otherwise:
[FIG(steps)[

= [1657] [[Error][error]].
= [1658] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1659] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** US reset row state

[1661] The [DFN[US reset row state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[4/0]], [N[7/15]] ]:
[FIG(steps)[

= [1649] Set [VAR[state]]'s [F[previous state]] to a copy of [VAR[decode]].
= [1650] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[94]], [N[4/0]].
= [1652] Set [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[94]], [N[6/2]].
= [1653] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].
= [1654] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].
= [1662] If [VAR[state]]'s [F[current I byte]] is [N[4/0]]:
== [1664] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/2 4/0".
= [1663] Otherwise, if [VAR[state]]'s [F[current I byte]] is [N[4/5]]:
== [1665] [[Run a macro][run a macro]] with
[VAR[state]],
"ESC 2/2 4/1".
= [1668] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[resetrow]], [VAR[bc]]).
= [1666] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1667] [[Error][error]].
= [1669] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1670] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Sound control state

[1485] The [DFN[sound control state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/9]] ]:
[FIG(steps)[

= [1488] [[Emit][emit a character]] [[character]] ([I[param]], [VAR[bc]]).

]FIG]
: [N[3/11]] :
[FIG(steps)[

= [1489] [[Emit][emit a character]] [[character]] ([I[param]], [VAR[bc]]).
= [1490] Set [VAR[state]]'s [F[decoder state]] to [I[sound control parameter state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1486] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1487] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Sound control parameter state

[1491] The [DFN[sound control parameter state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[3/9]] ]:
[FIG(steps)[

= [1492] [[Emit][emit a character]] [[character]] ([I[param]], [VAR[bc]]).

]FIG]
: [N[3/11]] :
[FIG(steps)[

= [1493] [[Emit][emit a character]] [[character]] ([I[param]], [VAR[bc]]).
= [1494] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1495] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1496] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Control parameter state

[1500] The [DFN[control parameter state]] switches 
by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1501] [[Emit][emit a character]] [[character]] ([I[param]], [VAR[bc]]).
= [723] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - [N[1]].
= [725] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1502] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [726] [[Error][error]].
= [1503] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1504] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** File state

[680] The [DFN[file state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[3/0]], [N[7/14]] ]:
[FIG(steps)[

= [685] [[Emit][emit a character]]
[[character]] ([I[vt]], [I[file]], [VAR[bc]]).
= [721] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [742] [[Error][error]].
= [745] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [746] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** CAPTAIN DI state

[1430] The [DFN[CAPTAIN DI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/14]] ]:
[FIG(steps)[

= [1431] Set [VAR[state]]'s [F[current frame length]] to [VAR[bc]].
= [1450] Run the steps to [[initialize by DI]] [VAR[state]].

]FIG]
: [N[15/15]] :
[FIG(steps)[

= [1432] Set [VAR[state]]'s [F[decoder state]] to [I[CAPTAIN DI first state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1433] [[Error][error]].
= [1438] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1434] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** CAPTAIN DI first state

[1435] The [DFN[CAPTAIN DI first state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1436] Set [VAR[state]]'s [F[current J byte]] to [VAR[bc]].
= [1439] Set [VAR[state]]'s [F[decoder state]] to [I[CAPTAIN DI second state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1440] [[Error][error]].
= [1441] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1442] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** CAPTAIN DI second state

[1443] The [DFN[CAPTAIN DI second state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1444] Set [VAR[state]]'s [F[current frame length]] to 
[VAR[state]]'s [F[current J byte]] * 0x100 + [VAR[bc]].
= [1449] Run the steps to [[initialize by DI]] [VAR[state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1446] [[Error][error]].
= [1447] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1448] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** TELESOFTWARE CI state

[1582] The [DFN[TELESOFTWARE CI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/14]] ]:
[FIG(steps)[

= [1584] Set [VAR[state]]'s [F[current segment length]] to [VAR[bc]].
= [1585] Set [VAR[state]]'s [F[decoder state]] to [I[TELESOFTWARE parameter state]].

]FIG]
: [N[15/15]] :
[FIG(steps)[

= [1586] Set [VAR[state]]'s [F[decoder state]] to [I[TELESOFTWARE LI state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1587] [[Error][error]].
= [1588] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1589] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** TELESOFTWARE LI state

[1590] The [DFN[TELESOFTWARE LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1592] Set [VAR[state]]'s [F[current segment length]] to [VAR[bc]].
= [1591] Set [VAR[state]]'s [F[decoder state]] to [I[TELESOFTWARE LI first state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1593] [[Error][error]].
= [1594] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1595] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** TELESOFTWARE LI first state

[1596] The [DFN[TELESOFTWARE LI first state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[15/15]] ]:
[FIG(steps)[

= [1598] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] * [N[0x100]] + [VAR[bc]].
= [1599] Set [VAR[state]]'s [F[decoder state]] to [I[TELESOFTWARE parameter state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1600] [[Error][error]].
= [1601] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1602] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** TELESOFTWARE parameter state

[1603] The [DFN[TELESOFTWARE parameter state]] switches by 
the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [727] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[videosoftware-data]], [VAR[bc]]).
= [1605] Set [VAR[state]]'s [F[current segment length]] to 
[VAR[state]]'s [F[current segment length]] - 1.
= [1606] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1608] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [728] [[Error][error]].
= [1610] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1611] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** TRANSPARENT state

[1618] The [DFN[TRANSPARENT state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [N[0/0]] :
[FIG(steps)[

= [1624] Set [VAR[state]]'s [F[current segment length]] to [CODE[null]].
= [1619] Set [VAR[state]]'s [F[decoder state]] to [I[TRANSPARENT data state]].

]FIG]
:[ [N[0/1]], [N[15/14]] ]:
[FIG(steps)[

= [1623] Set [VAR[state]]'s [F[current segment length]] to [VAR[bc]].
= [1622] Set [VAR[state]]'s [F[decoder state]] to [I[TRANSPARENT data state]].

]FIG]
: [N[15/15]] :
[FIG(steps)[

= [1621] [[Deprecated][deprecated]].
= [1620] Set [VAR[state]]'s [F[decoder state]] to [I[TRANSPARENT data state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1625] [[Error][error]].
= [1627] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1626] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]


*** TRANSPARENT data state

[1629] The [DFN[TRANSPARENT data state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [N[0/0]], [N[1/14]] ], [ [N[2/0]], [N[15/15]] ]:
[FIG(steps)[

= [1634] If [VAR[state]]'s [F[current segment length]] is ''not'' [CODE[null]]:
== [1635] Set [VAR[state]]'s [F[current segment length]] to
[VAR[state]]'s [F[current segment length]] - 1.
= [1636] [[Emit][emit a character]]
[[character]] ([I[videotex]], [I[transparent]], [VAR[bc]]).
= [1637] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [1638] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
: [N[1/15]] :
[FIG(steps)[

= [1639] [[Error][error]].
= [1631] Set [VAR[state]]'s [F[current I byte]] to [N[4/10]].
= [1632] Set [VAR[state]]'s [F[decoder state]] to [I[US state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1630] [[Error][error]].
= [1633] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]

]FIG]




*** PCD state

[67] The [DFN[PCD state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [68] [[Emit][emit a character]]
[[character]] ([I[param]], [VAR[bc]]).
= [69] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PM state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1123] [[Error][error]].
= [1122] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1128] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** PCD PM state

[70] The [DFN[PCD PM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [71] [[Emit][emit a character]]
[[character]] ([I[param]], [VAR[bc]]).
= [73] Set [VAR[state]]'s [F[current segment length]] to [N[0]].
= [72] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PI state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1124] [[Error][error]].
= [1125] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1129] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD PI state

[74] The [DFN[PCD PI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[10/0]], [[11/1]] ]:
[FIG(steps)[

= [75] Set [VAR[state]]'s [F[current segment length]] to 
([VAR[state]]'s [F[current segment length]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [77] If [VAR[state]]'s [F[current segment length]] is greater than the
[[maximum chunk length]]:
== [1131] [[Error][error]].
== [1276] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
== [1132] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].

]FIG]
:[ [[8/13]], [[9/14]] ]:
[FIG(steps)[

= [78] Set [VAR[state]]'s [F[current segment length]] to 
([VAR[state]]'s [F[current segment length]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [79] If [VAR[state]]'s [F[current segment length]] is greater than the
[[maximum chunk length]]:
== [1133] [[Error][error]].
== [1277] Set [VAR[state]]'s [F[opaque designated]] to the result of
[[getting a 256 set][get a 256 set]]
[I[unknown-byte]], [CODE[null]].
== [1134] Set [VAR[state]]'s [F[decoder state]] to [I[opaque state]].
= [87] Set [VAR[state]]'s [F[current segment data]] to the [[empty byte sequence]].
= [82] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [83] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [84] Otherwise:
== [80] Set [VAR[state]]'s [F[decoder state]] to [I[PCD LI state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1126] [[Error][error]].
= [1127] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1130] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD LI state

[81] The [DFN[PCD LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [88] [[Emit][emit a character]]
([I[pcd]], [VAR[bc]]).
= [76] Set [VAR[state]]'s [F[current segment length]] to 
[VAR[state]]'s [F[current segment length]] - 1.
= [85] If [VAR[state]]'s [F[current segment length]] is [N[0]]:
== [86] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].

]FIG]
:Otherwise:
[FIG(steps)[

= [1135] [[Error][error]].
= [1136] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [1137] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]


]FIG]

*** Opaque state

[50] The [DFN[opaque state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [1278] Let [VAR[set]] be [VAR[state]]'s [F[opaque designated]].
= [51] [[Emit][emit a character]]
[VAR[set]] [ [VAR[bc]] ].

]FIG]
:Otherwise:
[FIG(steps)[

= [674] Set [VAR[state]]'s [F[decoder state]] to [I[default state]].
= [682] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

* Characters

[18] 
A [DFN[character]] is one of followings:

- [CODE(charname)@en[ESC]]
- [CODE(charname)@en[SP]]
- [CODE(charname)@en[MSP]]
- [CODE(charname)@en[DEL]]
- [CODE(charname)@en[LS0]]
- [CODE(charname)@en[LS1]]
- [CODE(charname)@en[LS2]]
- [CODE(charname)@en[LS3]]
- [CODE(charname)@en[LS1R]]
- [CODE(charname)@en[LS2R]]
- [CODE(charname)@en[LS3R]]
- [CODE(charname)@en[SS2]]
- [CODE(charname)@en[SS3]]
- [CODE(charname)@en[EXT1]]
- [CODE(charname)@en[DCS]]
- [CODE(charname)@en[CMD]]
- [CODE(charname)@en[PCD]]
- [CODE(charname)@en[SOS]]
- [CODE(charname)@en[ST]]
- [CODE(charname)@en[P-MACRO]]
- any other [[code point]]
- ([I[esc]], [VAR[bytes]]) where [VAR[bytes]] is a [[byte sequence]]
- ([I[param]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[pcd]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[protocol]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- ([VAR[t1]], [VAR[t2]], [VAR[bytes]])
where [VAR[t1]] and [VAR[t2]] are valid [VAR[t1]] and [VAR[t2]] pairs 
of a [[character set identifier]]
and [VAR[bytes]] is a [[byte sequence]]
- ([I[marc]], [VAR[bc]], [VAR[bytes]]) 
where [VAR[bc]] is a [[bit combination]] and
[VAR[bytes]] is a [[byte sequence]]
- ([I[vt]], [N[8/6]], [VAR[bytes]])
where [VAR[bytes]] is a [[byte sequence]]
- ([I[vt52]], [N[8/6]], [VAR[bytes]])
where [VAR[bytes]] is a [[byte sequence]]
- ([I[vt]], [N[2/3]], [VAR[bc]]) where [VAR[bc]] is in [ [N[3/0]], [N[3/9]] ]
- ([I[vt]], [N[2/8]], [N[3/1]])
- ([I[vt]], [N[2/9]], [N[3/1]])
- ([I[vt]], [N[2/15]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt]], [I[file]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt52]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[7/14]] ]
- ([I[vt105]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/1]], [N[3/2]] ]
- ([I[tektronix]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[0/0]], [N[1/15]] ]
- ([I[tektronix]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/15]] ]
- ([I[videotex]], [I[protocol]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([I[videotex]], [I[us]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[videotex]], [I[profile]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[videotex]], [I[reset]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[videotex]], [I[resetrow]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[videotex]], [I[telesoftware-ci]], [VAR[bc]]) 
where [VAR[bc]] is a [[bit combination]]
- ([I[videotex]], [I[telesoftware-data]], [VAR[bc]]) 
where [VAR[bc]] is a [[bit combination]]
- ([I[mule]], [I[esc]], [VAR[bc]]), where [VAR[bc]] is in [ [N[3/0]], [N[3/4]] ]
- ([I[vt]], [I[extended-segment-f]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[deprecated]], [VAR[char]]) where [VAR[char]] is a [[character]]


;; [186] 
Interpretation of these [[tuples][tuple]] are application-specific.

[112] 
A [DFN[character string]] is a [[list]] of zero or more [[characters][character]].

[113] 
An [DFN[empty character string]] is a [[character string]] whose [F[length]]
is [N[0]].

[1771] 
An [DFN[EOF]] is a [[tuple]] with no [[item]].


* Character sets

[17] 
A [DFN[character set]] is an [[ordered map]],
where [[keys][key]] are [[byte sequences][byte sequence]] and
[[values][value]] are a [[character]].

;; [575] By definition, there are no duplicate [[keys][key]].


[1730] 
A [DFN[character set identifier]] is a pair of two values [VAR[t1]] and [VAR[t2]].
It is an opaque identifier and uniquely identifies a [[character set]] within 
this document.
A [[character set identifier]] is valid as [VAR[t1]] and [VAR[t2]] arguments
for exactly one of 
the steps to 
[[get a C set]],
[[get a G set]],
[[get a 128 set]],
[[get a 256 set]], or
[[get a 256[SUP[2]] set]].


[574] 
A [[character set]] [VAR[set]] [DFN[has 1-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
[VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1.

[576] 
A [[character set]] [VAR[set]] [DFN[has 2-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[2]].

[577] 
A [[character set]] [VAR[set]] [DFN[has 3-byte [[range]]]] [VAR[range]] if
any [[key]] in [VAR[set]] is a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] 
followed by a [[bit combination]] in [VAR[range]] and 
[VAR[set]]'s [F[size]] is equal to 
([VAR[range]]'s [F[end]] - [VAR[range]]'s [F[start]] + 1)[SUP[3]].

[171] 
To [DFN[get a 1-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [172] Let [VAR[set]] be a new [[character set]].
= [173] [[For each]] [VAR[c]] in [ [VAR[start]], [VAR[end]] ]:
== [174] Let [VAR[set]] [ [VAR[c]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[c]]).
= [175] Return [VAR[set]].

]FIG]


[583] 
To [DFN[get a 2-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [584] Let [VAR[set]] be a new [[character set]].
= [585] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [586] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [589] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]].
=== [587] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [588] Return [VAR[set]].

]FIG]


[590] 
To [DFN[get a 3-byte set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [591] Let [VAR[set]] be a new [[character set]].
= [592] [[For each]] [VAR[c1]] in [ [VAR[start]], [VAR[end]] ]:
== [593] [[For each]] [VAR[c2]] in [ [VAR[start]], [VAR[end]] ]:
=== [594] [[For each]] [VAR[c3]] in [ [VAR[start]], [VAR[end]] ]:
==== [595] Let [VAR[cc]] be [VAR[c1]] followed by [VAR[c2]] followed by [VAR[c3]].
==== [596] Let [VAR[set]] [ [VAR[cc]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[cc]]).
= [597] Return [VAR[set]].

]FIG]

-*-*-

[22] 
A [DFN[C0 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[0/0]], [N[1/15]] ].

[23] 
A [DFN[C1 set]] is a [[character set]] that 
[[has 1-byte range]] [ [N[8/0]], [N[9/15]] ].

[176] 
To [DFN[get a C set]] with 
[VAR[type]], [VAR[t1]], and [VAR[t2]],
run these steps:

[FIG(steps)[

= [652] If [VAR[type]] is [I[C0]]:
== [177] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [N[0/0]], [N[1/15]], [VAR[t1]], [VAR[t2]].
= [653] Otherwise, if [VAR[type]] is [I[C1]]:
== [181] Let [VAR[set]] be the result of 
[[getting a 1-byte set][get a 1-byte set]] 
with [N[8/0]], [N[9/15]], [VAR[t1]], [VAR[t2]].
= [180] If [VAR[t1]] is [I[C0]] and [VAR[t2]] is ''not'' [N[7/14]]:
== [178] Set [VAR[set]] [ [N[1/11]] ] to [CODE(charname)@en[ESC]].
= [187] If [VAR[t1]] is [I[C0]] and [VAR[t2]] is one of:
[N[4/1]] ([[ISO-IR]] 1),
[N[4/3]] ([[ISO-IR]] 26),
[N[4/4]] ([[ISO-IR]] 36),
[N[4/6]] ([[ISO-IR]] 74),
[N[4/11]] ([[ISO-IR]] 135),
[N[4/12]] ([[ISO-IR]] 140),
[N[4/5]] ([[ISO-IR]] 106),
[N[4/8]] ([[ISO-IR]] 130),
or
[N[4/10]] ([[ISO-IR]] 134):
== [188] Set [VAR[set]] [ [N[0/14]] ] to [CODE(charname)@en[LS1]].
== [189] Set [VAR[set]] [ [N[0/15]] ] to [CODE(charname)@en[LS0]].
= [190] If [VAR[t1]] is [I[C0]] and [VAR[t2]] is [N[4/4]] ([[ISO-IR]] 36):
== [191] Set [VAR[set]] [ [N[1/12]] ] to [CODE(charname)@en[SS2]].
= [192] If [VAR[t1]] is [I[C0]] and [VAR[t2]] is one of:
[N[4/5]] ([[ISO-IR]] 106),
[N[4/9]] ([[ISO-IR]] 132),
[N[4/10]] ([[ISO-IR]] 134),
or 
[N[4/12]] ([[ISO-IR]] 135):
== [193] Set [VAR[set]] [ [N[1/9]] ] to [CODE(charname)@en[SS2]].
== [193] Set [VAR[set]] [ [N[1/14]] ] to [CODE(charname)@en[SS3]].
= [194] If [VAR[t1]] is [I[C0]] and [VAR[t2]] is [N[4/12]] ([[ISO-IR]] 140):
== [195] Set [VAR[set]] [ [N[1/9]] ] to [CODE(charname)@en[SS2]].
= [1716] If [VAR[t1]] is [I[dtvcc]] and [VAR[t2]] is [I[C0]]:
== [1717] Set [VAR[set]] [ [N[1/0]] ] to [CODE(charname)@en[EXT1]].
= [196] If [VAR[t1]] is [I[C1]] and [VAR[t2]] is one of:
[N[4/5]] ([[ISO-IR]] 40),
[N[4/3]] ([[ISO-IR]] 77),
[N[4/3]] followed by [N[4/0]],
or
[N[4/7]] ([[ISO-IR]] 105):
== [197] Set [VAR[set]] [ [N[8/14]] ] to [CODE(charname)@en[SS2]].
== [198] Set [VAR[set]] [ [N[8/15]] ] to [CODE(charname)@en[SS3]].
= [1138] If [VAR[t1]] is [I[C1]] and [VAR[t2]] is [N[4/4]]:
== [1165] Set [VAR[set]] [ [N[9/5]] ] to [CODE(charname)@en[P-MACRO]].
= [25] If [VAR[t1]] is [I[vt]] and [VAR[t2]] is [I[C1]]:
== [688] Set [VAR[set]] [ [N[8/14]] ] to [CODE(charname)@en[LS1]].
== [689] Set [VAR[set]] [ [N[8/15]] ] to [CODE(charname)@en[LS0]].
== [715] Set [VAR[set]] [ [N[9/0]] ] to [CODE(charname)@en[DCS]].
= [1554] If [VAR[t1]] is [I[videotex]] and [VAR[t2]] is [I[geometric-c1]]:
== [1555] Set [VAR[set]] [ [N[9/8]] ] to [CODE(charname)@en[SOS]].
== [1556] Set [VAR[set]] [ [N[9/12]] ] to [CODE(charname)@en[ST]].
= [1016] If [VAR[t1]] is [I[marc]] and [VAR[t2]] is [I[C1]]:
== [1017] Set [VAR[set]] [ [N[8/8]] ] to [CODE(charname)@en[SOS]].
== [1020] Set [VAR[set]] [ [N[8/9]] ] to [CODE(charname)@en[ST]].
= [1557] If [VAR[t1]] is [I[C1]] and [VAR[t2]] is one of:
[N[4/3]] ([[ISO-IR]] 77)
or
[N[4/3]] followed by [N[4/0]]:
== [1558] Set [VAR[set]] [ [N[9/12]] ] to [CODE(charname)@en[ST]].
= [716] Return [VAR[set]].

]FIG]

[NOTE[

[179] The following combinations of 
[VAR[type]], [VAR[t1]], and [VAR[t2]] are used:

- ([I[C0]], [I[C0]], [VAR[bytes]]) where [VAR[bytes]] is a [[byte sequence]]
- ([I[C0]], [I[unknown-control]], [CODE[null]])
- ([I[C0]], [I[dtvcc]], [I[C0]])
- ([I[C1]], [I[C1]], [VAR[bytes]]) where [VAR[bytes]] is a [[byte sequence]]
- ([I[C1]], [I[vt]], [I[C1]])
- ([I[C1]], [I[videotex]], [N[2/0]])
- ([I[C1]], [I[videotex]], [N[2/1]])
- ([I[C1]], [I[videotex]], [I[sound-control]])
- ([I[C1]], [I[videotex]], [I[geometric-c1]])
- ([I[C1]], [I[marc]], [I[C1]])
- ([I[C1]], [I[unknown-control]], [CODE[null]])
- ([I[C1]], [I[dtvcc]], [I[C1]])
- ([I[C0]], [I[dtvcc]], [I[C2]])
- ([I[C1]], [I[dtvcc]], [I[C3]])

]NOTE]

[19] 
The [DFN[initial C0 set]] is the result of 
[[getting a C set][get a C set]] with [I[C0]], [I[C0]], [N[4/7]].

[37] 
The [DFN[unknown C0 set]] is the result of 
[[getting a C set][get a C set]] with [I[C0]], [I[unknown-control]], [CODE[null]].

[24] 
The [DFN[empty C1 set]] is the result of 
[[getting a C set][get a C set]] with [I[C1]], [I[C1]], [N[7/14]].

[661] 
The [DFN[unknown C1 set]] is the result of 
[[getting a C set][get a C set]] with [I[C1]], [I[unknown-control]], [CODE[null]].

-*-*-

[45] 
A [DFN[G set]] is 
[[94 set]], [[96 set]],
[[94[SUP[2]] set]], [[96[SUP[2]] set]],
or
[[94[SUP[3]] set]].

[578] 
A [DFN[94 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/1]], [N[7/14]] ].

[579] 
A [DFN[96 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[2/0]], [N[7/15]] ].

[580] 
A [DFN[94[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/1]], [N[7/14]] ].

[581] 
A [DFN[96[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[2/0]], [N[7/15]] ].

[582] 
A [DFN[94[SUP[3]] set]] is a [[character set]]
that [[has 3-byte range]] [ [N[2/1]], [N[7/14]] ].


[374] 
To determine whether [DFN[is 96 size]] [VAR[set]], run these steps:

[FIG(steps)[

= [569] If [VAR[set]] is [I[unknown-96]], return [[true]].
= [570] Otherwise, if [VAR[set]] is a [[96 set]], return [[true]].
= [373] Otherwise, if [VAR[set]] is a [[96[SUP[2]] set]], return [[true]].
= [571] Otherwise, return [[false]].

]FIG]

[348] 
To determine [[character set]] [VAR[set]]'s [DFN[byte length]],
run these steps:

[FIG(steps)[

= [350] If [VAR[set]] is a [[94 set]] or [[96 set]]:
== [351] Return [N[1]].
= [352] Otherwise, if [VAR[set]] is a [[94[SUP[2]] set]] or [[96[SUP[2]] set]]:
== [353] Return [N[2]].
= [360] Otherwise, if [VAR[set]] is a [[94[SUP[3]] set]]:
== [361] Return [N[3]].

]FIG]





[854] To [DFN[get a G set]] with
[VAR[size]],
[VAR[length]],
[VAR[t1]], 
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [855] If [VAR[size]] is [N[94]] and [VAR[length]] is [N[1]]:
== [856] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [697] Otherwise, if [VAR[size]] is [N[96]] and [VAR[length]] is [N[1]]:
== [857] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[2/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [858] Otherwise, if [VAR[size]] is [N[94]] and [VAR[length]] is [N[2]]:
== [859] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [860] Otherwise, if [VAR[size]] is [N[96]] and [VAR[length]] is [N[2]]:
== [861] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[2/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [862] Otherwise, if [VAR[size]] is [N[94]] and [VAR[length]] is [N[3]]:
== [863] Let [VAR[set]] be the result of [[getting a 3-byte set][get a 3-byte set]] 
with [N[2/1]], [N[7/14]], [VAR[t1]], [VAR[t2]].
= [864] Return [VAR[set]].

]FIG]

[NOTE[

[827] The following combinations of 
[VAR[size]], [VAR[length]], [VAR[t1]], and [VAR[t2]] are used:

- ([VAR[size]], [N[1]], [VAR[bytes]]) where 
[VAR[size]] is [N[94]] or [N[96]] and [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[1]], [I[marc]], [N[6/2]])
- ([N[94]], [N[1]], [I[marc]], [N[6/7]])
- ([N[94]], [N[1]], [I[marc]], [N[7/0]])
- ([N[94]], [N[1]], [I[marc]], [N[7/3]])
- ([N[94]], [N[1]], [I[vt]], [N[8/6]])
- ([N[94]], [N[1]], [I[vt52]], [N[8/6]])
- ([N[94]], [N[1]], [I[vt]], [N[8/7]])
- ([N[94]], [N[1]], [I[marc]], [VAR[F]]) where [VAR[F]] is in [ [N[3/2]], [N[3/4]] ]
- ([N[94]], [N[1]], [I[arib]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/8]] ]
- ([N[94]], [N[1]], [I[mule-94]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/5]] ]
- ([N[94]], [N[1]], [I[vt]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/14]] ]
- ([N[94]], [N[1]], [I[vt]], [N[4/11]])
- ([N[94]], [N[1]], [I[vt]], [N[5/5]])
- ([N[94]], [N[1]], [I[vt]], [N[2/2]] followed by [N[3/1]])
- ([N[94]], [N[1]], [I[vt]], [N[2/2]] followed by [N[3/4]])
- ([N[94]], [N[1]], [I[vt]], [N[2/5]] followed by [VAR[F]]) where 
[VAR[F]] is in [ [N[3/0]], [N[3/15]] ]
- ([N[94]], [N[1]], [I[jphone]], [VAR[F]]) where [VAR[F]] is in [ [N[4/3]], [N[5/1]] ]
- ([N[96]], [N[1]], [I[videotex]], [I[t100alphageometric]])
- ([N[96]], [N[1]], [I[videotex]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[96]], [N[1]], [I[videotex]], [I[l]])
- ([N[96]], [N[1]], [I[mule-96]], [VAR[F]]) where [VAR[F]] is in [ [N[3/0]], [N[3/2]] ]
- ([N[96]], [N[1]], [I[dtvcc]], [I[G0]])
- ([N[96]], [N[1]], [I[dtvcc]], [I[G1]])
- ([N[96]], [N[1]], [I[dtvcc]], [I[G2]])
- ([N[96]], [N[1]], [I[dtvcc]], [I[G3]])
- ([N[94]], [N[2]], [I[94[SUP[2]]]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[2]], [I[jisx0208]], [I[ms]])
- ([N[94]], [N[2]], [I[jisx0208]], [I[opennec]])
- ([N[94]], [N[2]], [I[dec]], [I[udc1978]])
- ([N[94]], [N[2]], [I[jef]], [CODE[null]])
- ([N[94]], [N[2]], [I[jisx0212]], [I[openibm]])
- ([N[94]], [N[2]], [I[jis]], [I[jisx0212jisx0213]])
- ([N[94]], [N[2]], [I[sjis2]], [I[ms]])
- ([N[94]], [N[2]], [I[sjis2]], [I[docomo]])
- ([N[94]], [N[2]], [I[mule-94[SUP[2]]]], [VAR[F]]) where 
[VAR[F]] is in [ [N[3/0]], [N[3/8]] ]
- ([N[94]], [N[2]], [I[arib]], [VAR[F]]) where [VAR[F]] is in [ [N[3/9]], [N[3/11]] ]
- ([N[94]], [N[2]], [I[cns]], [VAR[p]]) where [VAR[p]] is in [ [N[1]], [N[80]] ]
- ([N[94]], [N[2]], [I[cns]], [I[old14]])
- ([N[96]], [N[2]], [I[mule-96[SUP[2]]]], [VAR[F]]) where 
[VAR[F]] is in [ [N[3/1]], [N[3/4]] ]
- ([N[96]], [N[2]], [I[videotex]], [I[sound-tone]])
- ([N[94]], [N[3]], [I[94[SUP[3]]]], [VAR[bytes]]) 
where [VAR[bytes]] is a [[byte sequence]]
- ([N[94]], [N[3]], [I[cns]], [I[euctw2]])
- ([N[94]], [N[3]], [I[marc]], [N[3/1]])

]NOTE]

-*-*-

[1095] 
A [DFN[128 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[0/0]], [N[7/15]] ].

[1183] 
A [DFN[256 set]] is a [[character set]]
that [[has 1-byte range]] [ [N[0/0]], [N[15/15]] ].

[1176] 
A [DFN[256[SUP[2]] set]] is a [[character set]]
that [[has 2-byte range]] [ [N[0/0]], [N[15/15]] ].

[1184] 
To [DFN[get a 128 set]]
with [VAR[t1]] and [VAR[t2]],
run these steps:

[FIG(steps)[

= [1113] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[0/0]], [N[7/15]], [VAR[t1]], [VAR[t2]].
= [1115] If [VAR[t1]] is [I[single]] and [VAR[t2]] is [I[barcode]]:
== [1116] Set [VAR[set]] [ [N[1/11]] ] to [CODE(charname)@en[ESC]].
= [1114] Return [VAR[set]].

]FIG]

[NOTE[

[1186] The following combinations of 
[VAR[t1]] and [VAR[t2]] are used:

- ([I[cp]], [VAR[i]]) where [VAR[i]] is in [ [N[1250]], [N[1258]] ]
- ([I[ct]], [VAR[n]]) where [VAR[n]] is a [[CT right encoding name]]
- ([I[single]], [I[barcode]])

]NOTE]


[1268] 
To [DFN[get a 256 set]]
with [VAR[t1]] and [VAR[t2]],
run these steps:

[FIG(steps)[

= [1269] Let [VAR[set]] be the result of [[getting a 1-byte set][get a 1-byte set]] 
with [N[0/0]], [N[15/15]], [VAR[t1]], [VAR[t2]].
= [1270] Return [VAR[set]].

]FIG]

[NOTE[

[1271] The following combinations of 
[VAR[t1]] and [VAR[t2]] are used:

- ([I[unknown-byte]], [CODE[null]])
- ([I[vts]], [I[transparent]])
- ([I[captain]], [VAR[bc]]) where [VAR[bc]] is a [[bit combination]]
- ([I[videotex]], [I[transparent]])
- ([I[ct]], [I[extended-segment-data]])

]NOTE]

[1185] 
To [DFN[get a 256[SUP[2]] set]]
with [VAR[t1]] and [VAR[t2]],
run these steps:

[FIG(steps)[

= [1182] Let [VAR[set]] be the result of [[getting a 2-byte set][get a 2-byte set]] 
with [N[0/0]], [N[15/15]], [VAR[t1]], [VAR[t2]].
= [1181] Return [VAR[set]].

]FIG]

[NOTE[

[1187] The following combinations of 
[VAR[t1]] and [VAR[t2]] are used:

- ([I[sjis]], [CODE[null]])
- ([I[sjis]], [I[2000]])
- ([I[gbk]], [CODE[null]])
- ([I[big5]], [CODE[null]])
- ([I[big5]], [I[hp]])
- ([I[big5]], [I[hkscs]])
- ([I[uhc]], [CODE[null]])
- ([I[johab]], [CODE[null]])
- ([I[unicode]], [I[1.1]])

]NOTE]


[1167] A [DFN[CT right encoding name]] is one of the followings:

- [CODE[omron_UDC]]
- [CODE[omron_UDC_ja]]
- [CODE[omron_UDC_zh]]
- [CODE[omron_UDC_tw]]
- [CODE[iso8859-14]]
- [CODE[iso8859-15]]
- [CODE[armscii-8]]
- [CODE[georgian-academy]]
- [CODE[georgian-ps]]
- [CODE[ibm-cp1133]]
- [CODE[iscii-dev]]
- [CODE[isiri-3342]]
- [CODE[iso8859-9e]]
- [CODE[koi8-c]]
- [CODE[koi8-r]]
- [CODE[koi8-u]]
- [CODE[microsoft-cp1251]]
- [CODE[microsoft-cp1255]]
- [CODE[microsoft-cp1256]]
- [CODE[mulelao-1]]
- [CODE[nokhchi-1]]
- [CODE[tatar-cyr]]
- [CODE[tscii-0]]
- [CODE[tcvn-5712]]
- [CODE[viscii1.1-1]]

[1168] A [DFN[CT 2-byte encoding name]] is one of the followings:

- [CODE[fujitsu.u90x03]]
- [CODE[DEC.CNS11643.1986-2]]
- [CODE[DEC.DTSCS.1990-2]]
- [CODE[big5-0]]
- [CODE[big5hkscs-0]]
- [CODE[gbk-0]]
- [CODE[BIG5-0]]
- [CODE[HP-BIG5]]

[1177] 
To [DFN[get a CT character set]] with [VAR[F]] and [VAR[encoding name]],
run these steps:

[FIG(steps)[

= [1178] If [VAR[F]] is [N[3/1]] and [VAR[encoding name]] is 
a [[CT right encoding name]]:
== [1188] If [VAR[encoding name]] is [CODE[iso8859-14]]:
=== [1189] Return the result of 
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[96]], [N[5/15]].
== [1190] Otherwise, if [VAR[encoding name]] is [CODE[iso8859-15]]:
=== [1191] Return the result of 
[[getting a G set][get a G set]] with
[I[96]], [I[1]], [I[96]], [N[6/2]].
== [1194] Otherwise, if [VAR[encoding name]] is [CODE[mulelao-1]]:
=== [1195] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[mule-94]], [N[3/1]].
== [1196] Otherwise, if [VAR[encoding name]] is [CODE[iscii-dev]]:
=== [1197] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[mule-94]], [N[3/5]].
== [1199] Otherwise, if [VAR[encoding name]] is 
[CODE[omron_UDC_zh]] or [CODE[omron_UDC_tw]]:
=== [1200] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[1]], [I[mule-94]], [N[3/0]].
== [1192] Otherwise:
=== [1193] Return the result of
[[getting a 128 set][get a 128 set]] with
[I[ct]], [VAR[enoding name]].
= [1179] Otherwise, if [VAR[F]] is [N[3/2]] and [VAR[encoding name]] is
a [[CT 2-byte encoding name]]:
== [1198] If [VAR[encoding name]] is [CODE[fujitsu.u90x03]]:
=== [1201] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[jef]], [CODE[null]].
== [1202] Otherwise, if [VAR[encoding name]] is [CODE[DEC.CNS11643.1986-2]]:
=== [1203] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[cns]], [N[2]].
== [1204] Otherwise, if [VAR[encoding name]] is [CODE[DEC.DTSCS.1990-2]]:
=== [1205] Return the result of 
[[getting a G set][get a G set]] with
[I[94]], [I[2]], [I[cns]], [I[old14]].
== [1206] Otherwise, if [VAR[encoding name]] is [CODE[big5-0]] or [CODE[BIG5-0]]:
=== [1207] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[big5]], [CODE[null]].
== [1208] Otherwise, if [VAR[encoding name]] is [CODE[big5hkscs-0]]:
=== [1209] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[big5]], [I[hkscs]].
== [1210] Otherwise, if [VAR[encoding name]] is [CODE[gbk-0]]:
=== [1211] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[gbk]], [CODE[null]].
= [1261] If [VAR[F]] is [N[3/0]] and [VAR[encoding name]] is [CODE[HP-BIG5]]:
== [1263] Return the result of 
[[getting a 256[SUP[2]] set][get a 256[SUP[2]] set]] with
[I[big5]], [I[hp]].
= [1169] Otherwise:
== [1180] Return [CODE[null]].


]FIG]

-*-*-

[333] 
To [DFN[modify character sets]] of [[state]] [VAR[state]] for
[[list]] [VAR[features]], run these steps:

[FIG(steps)[

= [342] [[For each]] [VAR[feature]] in [VAR[features]]:
== [739] [[Switch]] by [VAR[feature]]:
[FIG(switch)[

: "fixed" :
[FIG(steps)[

= [741] Set [VAR[state]]'s [F[fixed set]] [ [N[7/15]] ] to [CODE(charname)@en[DEL]].
= [748] Set [VAR[state]]'s [F[fixed set]] [ [N[10/0]] ] to [CODE(charname)@en[MSP]].
= [743] Set [VAR[state]]'s [F[fixed set]] [ [N[15/15]] ] to 
[[character]] ([I[unknown-byte]], [CODE[null]], [N[15/15]]).
= [54] Set [VAR[state]]'s [F[escape set]] [ [N[6/13]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS3R]]).
= [55] Set [VAR[state]]'s [F[escape set]] [ [N[6/14]] ] to [CODE(charname)@en[LS2]].
= [56] Set [VAR[state]]'s [F[escape set]] [ [N[6/15]] ] to [CODE(charname)@en[LS3]].
= [57] Set [VAR[state]]'s [F[escape set]] [ [N[7/12]] ] to [CODE(charname)@en[LS3R]].
= [60] Set [VAR[state]]'s [F[escape set]] [ [N[7/13]] ] to [CODE(charname)@en[LS2R]].
= [118] Set [VAR[state]]'s [F[escape set]] [ [N[7/14]] ] to [CODE(charname)@en[LS1R]].
= [49] Set [VAR[state]]'s [F[escape set]] [ [N[6/7]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[6/7]]).
= [62] Set [VAR[state]]'s [F[escape set]] [ [N[7/3]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[7/3]]).
= [123] Set [VAR[state]]'s [F[escape set]] [ [N[7/11]] ] to
[[character]] ([I[vt]], [I[esc]], [N[7/11]]).
= [775] Set [VAR[state]]'s [F[escape set]] [ [N[3/5]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/5]]).
= [776] Set [VAR[state]]'s [F[escape set]] [ [N[3/6]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/6]]).
= [777] Set [VAR[state]]'s [F[escape set]] [ [N[3/7]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/7]]).
= [686] Set [VAR[state]]'s [F[escape set]] [ [N[3/12]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/12]]).
= [760] Set [VAR[state]]'s [F[escape set]] [ [N[3/13]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/13]]).
= [761] Set [VAR[state]]'s [F[escape set]] [ [N[3/14]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/14]]).
= [782] Set [VAR[state]]'s [F[escape set]] [ [N[3/15]] ] to
[[character]] ([I[vt]], [I[esc]], [N[3/15]]).
= [764] Set [VAR[state]]'s [F[escape set]] [ [N[3/10]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/10]]).
= [765] Set [VAR[state]]'s [F[escape set]] [ [N[3/11]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/11]]).
= [766] Set [VAR[state]]'s [F[escape set]] [ [N[3/0]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/0]]).
= [840] [[For each]] [VAR[bc]] in [ [N[3/0]], [N[7/14]] ]:
== [842] Set [VAR[bytes]] be [VAR[bc]].
== [841] Set [VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [CODE[null]], [VAR[bc]].
== [846] Set [VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [CODE[null]], [VAR[bc]].
== [878] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [879] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
== [880] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [843] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [844] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [845] Set [VAR[state]]'s [F[94 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [VAR[ibc]], [VAR[bc]].
=== [847] Set [VAR[state]]'s [F[96 final set]] [ [VAR[bytes]] ] to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [VAR[ibc]], [VAR[bc]].
=== [881] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
=== [882] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
=== [883] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [274] [[For each]] [VAR[bc]] in [ [N[4/0]], [N[5/15]] ]:
== [865] Set [VAR[bytes]] be [VAR[bc]].
== [866] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [CODE[null]], [VAR[bc]].
== [848] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [CODE[null]], [VAR[bc]].
== [849] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [850] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [867] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [868] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [CODE[null]], [VAR[bc]].
=== [851] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [CODE[null]], [VAR[bc]].
=== [852] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [853] [[For each]] [VAR[bc]] in [ [N[6/0]], [N[6/15]] ]:
== [869] Set [VAR[bytes]] be [VAR[bc]].
== [870] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [CODE[null]], [VAR[bc]].
== [871] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
== [872] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
== [873] [[For each]] [VAR[ibc]] in [ [N[2/0]], [N[2/5]] ]:
=== [874] Set [VAR[bytes]] be [VAR[ibc]] followed by [VAR[bc]].
=== [875] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[3]], [CODE[null]], [VAR[bc]].
=== [876] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[bytes]] ]
to [I[unassigned-96]].
=== [877] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final RL set]] [ [VAR[bytes]] ]
to [I[unassigned-94]].
= [920] [[For each]] [VAR[F]] in 
[N[3/9]], 
[ [N[3/12]], [N[3/14]] ],
[N[2/2]] followed by [N[3/1]],
[N[2/2]] followed by [N[3/4]],
[N[2/5]] followed by [N[3/0]],
[N[2/5]] followed by [N[3/2]],
[N[2/5]] followed by [N[3/4]],
[N[2/5]] followed by [N[3/5]],
[N[2/5]] followed by [N[3/6]],
[N[2/5]] followed by [N[3/13]], and
[N[2/5]] followed by [N[3/15]]:
== [921] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [VAR[F]].
= [915] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/2]] ]:
== [916] Set [VAR[state]]'s [F[96 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[mule-96]], [VAR[F]].
= [917] Set [VAR[state]]'s [F[96 final set]] [ [N[3/8]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[3/8]].
= [918] Set [VAR[state]]'s [F[96 final set]] [ [N[3/9]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[videotex]], [N[3/9]].
= [919] Set [VAR[state]]'s [F[96 final set]] [ [N[2/2]] followed by [N[3/15]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[3/12]].
= [898] [[For each]] [VAR[F]] in [ [N[4/7]], [N[4/13]] ]:
== [897] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x47]] + 1.
= [888] [[For each]] [VAR[F]] in [N[3/2]], [N[3/4]], and [ [N[3/12]], [N[3/14]] ]:
== [887] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x30]] + 1.
= [886] [[For each]] [VAR[I]] in [ [N[2/1]], [N[2/4]] ]:
== [889] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/15]] ]:
=== [890] Let [VAR[p]] be 
([VAR[I]] - [N[0x20]]) × [N[0x10]] + [VAR[F]] - [N[0x30]] + [N[1]].
=== [891] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[p]].
= [885] [[For each]] [VAR[F]] in [ [N[3/1]], [N[3/4]] ]:
== [884] Set [VAR[state]]'s [F[96[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of
[[getting a G set][get a G set]] with
[N[96]], [N[2]], [I[mule-96[SUP[2]]]], [VAR[F]].
= [912] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [N[2/2]] followed by [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/0]].
= [913] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] 
[ [N[2/2]] followed by [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[dec]], [I[udc1978]].
= [936] [[For each]] [VAR[F]] in [N[6/2]], [N[6/7]], and [N[7/0]]:
== [935] Set [VAR[state]]'s [F[94 final set]] [ [N[1/11]] followed by [VAR[F]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[marc]], [VAR[F]].
= [937] Set [VAR[state]]'s [F[94 final set]] [ [N[1/11]] followed by [N[7/3]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [939] Set [VAR[state]]'s [F[94 final set]] [ [N[8/7]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/2]].
= [1763] Set [VAR[state]]'s [F[macro set]] [ [VAR[bc]] ] to [VAR[macro]]
by each row of the following tables:
,*[VAR[bc]],*[VAR[macro]]
,[N[6/0]],[[macro]] "ESC 2/4 4/2 ESC 2/9 4/10 ESC 2/10 3/0 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/1]],[[macro]] "ESC 2/4 4/2 ESC 2/9 3/1 ESC 2/10 3/0 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/2]],[[macro]] "ESC 2/4 4/2 ESC 2/9 2/0 4/1 ESC 2/10 3/0 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/3]],[[macro]] "ESC 2/8 3/2 ESC 2/9 3/4 ESC 2/10 3/5 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/4]],[[macro]] "ESC 2/8 3/2 ESC 2/9 3/3 ESC 2/10 3/5 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/5]],[[macro]] "ESC 2/8 3/2 ESC 2/9 2/0 4/1 ESC 2/10 3/5 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/6]],[[macro]] "ESC 2/8 2/0 4/1 ESC 2/9 2/0 4/2 ESC 2/10 2/0 4/3 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/7]],[[macro]] "ESC 2/8 2/0 4/4 ESC 2/9 2/0 4/5 ESC 2/10 2/0 4/6 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/8]],[[macro]] "ESC 2/8 2/0 4/7 ESC 2/9 2/0 4/8 ESC 2/10 2/0 4/9 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/9]],[[macro]] "ESC 2/8 2/0 4/10 ESC 2/9 2/0 4/11 ESC 2/10 2/0 4/12 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/10]],[[macro]] "ESC 2/8 2/0 4/13 ESC 2/9 2/0 4/14 ESC 2/10 2/0 4/15 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/11]],[[macro]] "ESC 2/4 4/2 ESC 2/9 2/0 4/2 ESC 2/10 3/0 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/12]],[[macro]] "ESC 2/4 4/2 ESC 2/9 2/0 4/3 ESC 2/10 3/0 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/13]],[[macro]] "ESC 2/4 4/2 ESC 2/9 2/0 4/4 ESC 2/10 3/0 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/14]],[[macro]] "ESC 2/8 3/1 ESC 2/9 3/0 ESC 2/10 4/10 ESC 2/11 2/0 7/0 LS0 ESC 7/13"
,[N[6/15]],[[macro]] "ESC 2/8 4/10 ESC 2/9 3/2 ESC 2/10 2/0 4/1 ESC 2/11 2/0 7/0 LS0 ESC 7/13"

]FIG]
: "fallback" :
[FIG(steps)[

= [740] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to [CODE(charname)@en[SP]].
= [1731] [[For each]] [VAR[bc]] in
[N[6/2]], [N[6/3]], [N[6/4]], [N[6/11]], [N[6/12]], [N[6/15]],
[N[7/0]], [N[7/2]]:
== [125] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[unknown-control]], [CODE[null]], [N[1/11]] followed by [VAR[bc]]).
= [758] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [759] [[Remove][remove an entry]] [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].
= [778] [[For each]] [VAR[bc]] in [ [N[3/1]], [N[3/4]] ]:
== [779] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[unknown-control]], [CODE[null]], [VAR[bc]]).
= [780] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to 
[[character]] ([I[unknown-control]], [CODE[null]], [N[3/8]]).
= [781] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to 
[[character]] ([I[unknown-control]], [CODE[null]], [N[3/9]]).
= [922] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/8]] ], [N[4/0]],
[N[4/3]], [N[4/5]], [N[4/8]], [N[4/11]], [N[5/1]], [N[5/5]],
[N[7/0]], [N[7/10]], [N[7/11]], [N[7/13]],
[N[2/0]] followed by [N[7/10]], [N[2/0]] followed by [N[7/11]]:
== [923] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [VAR[F]].
= [1701] [[For each]] [VAR[F]] in 
[N[7/10]], [N[7/11]]:
== [1702] Set [VAR[state]]'s [F[96 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [VAR[F]].
= [894] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/3]], [ [N[3/5]], [N[3/11]] ], and [N[3/15]]:
== [896] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [VAR[F]].
= [895] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to [I[unassigned-94]].
= [908] [[For each]] [VAR[F]] in [N[3/1]], [N[3/3]], [ [N[4/0]], [N[4/2]] ]:
== [911] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [VAR[F]] ]
to [I[unassigned-94]].
= [940] Set [VAR[state]]'s [F[94 final set]] [ [N[8/6]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[8/6]].
= [1683] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[4/2]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]].
= [1684] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [I[4/2]] followed by [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]] followed by [N[4/0]].


]FIG]
: "iso2022" :
[FIG(steps)[

= [29] Set [VAR[state]]'s [F[escape set]] [ [N[6/4]] ] to [CODE(charname)@en[CMD]].
= [42] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[esc]], [N[6/2]]).
= [1681] [[For each]] [VAR[F]] in 
[N[4/0]], [N[4/3]], [N[4/5]], [N[4/8]], [N[4/11]], [N[5/1]], [N[5/5]],
[N[7/0]], [N[7/10]], [N[7/11]], [N[7/13]],
[N[2/0]] followed by [N[7/10]], [N[2/0]] followed by [N[7/11]]:
== [1682] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [VAR[F]].
= [1699] [[For each]] [VAR[F]] in 
[N[7/10]], [N[7/11]]:
== [1700] Set [VAR[state]]'s [F[96 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [VAR[F]].
= [1685] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[4/2]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]].
= [1686] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [I[4/2]] followed by [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]] followed by [N[4/0]].

]FIG]
: "cns" :
[FIG(steps)[

= [892] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/1]], [N[3/3]], [ [N[3/5]], [N[3/11]] ], and [N[3/15]]:
== [893] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[cns]], [VAR[F]] - [N[0x30]] + 1.

]FIG]
: "mongolian" :
[FIG(steps)[

= [744] Set [VAR[state]]'s [F[fixed set]] [ [N[2/0]] ] to [CODE(charname)@en[MSP]].

]FIG]
: "jisold" :
[FIG(steps)[

= [977] Set [VAR[state]]'s [F[94 final set]] [ [N[4/8]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[4/10]].

]FIG]
: "jisms" :
[FIG(steps)[

= [1358] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/15]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[sjis2]], [I[ms]].
= [1359] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[jisx0208]], [I[ms]].
= [1360] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[4/2]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[jisx0208]], [I[ms]].
= [1361] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [N[4/2]] followed by [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[jisx0208]], [I[ms]].

]FIG]
: "ks" :
[FIG(steps)[

= [901] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/3]].

]FIG]
: "videotex" :
[FIG(steps)[

= [52] Set [VAR[state]]'s [F[escape set]] [ [N[6/11]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS1R]]).
= [53] Set [VAR[state]]'s [F[escape set]] [ [N[6/12]] ] to 
[[character]] ([I[deprecated]], [CODE(charname)@en[LS2R]]).
= [43] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to [CODE(charname)@en[PCD]].
= [974] Set [VAR[state]]'s [F[94 final set]] [ [N[4/0]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[videotex]], [N[4/0]].
= [928] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/8]] ], [N[7/0]]:
== [929] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[arib]], [VAR[F]].
= [904] [[For each]] [VAR[F]] in [ [N[3/9]], [N[3/11]] ], [N[4/2]]:
== [903] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[arib]], [VAR[F]].
= [1453] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] 
[ [N[4/2]] followed by [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[arib]], [N[4/2]].
= [1026] Set [VAR[state]]'s [F[96 final set]] [ [N[7/10]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[2/0]] followed by [N[7/10]].
= [1692] Set [VAR[state]]'s [F[96 final set]] [ [N[7/11]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[2/0]] followed by [N[7/11]].
= [1693] Set [VAR[state]]'s [F[94 final set]] [ [N[7/10]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[2/0]] followed by [N[7/10]].
= [1694] Set [VAR[state]]'s [F[94 final set]] [ [N[7/11]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[2/0]] followed by [N[7/11]].
= [1695] Set [VAR[state]]'s [F[94 final set]] [ [N[2/0]] followed by [N[7/10]] ] 
to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[2/0]] followed by [N[7/10]].
= [1696] Set [VAR[state]]'s [F[94 final set]] [ [N[2/0]] followed by [N[7/11]] ] 
to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[2/0]] followed by [N[7/11]].
= [1697] Set [VAR[state]]'s [F[94 final set]] [ [N[5/7]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[5/7]].
= [1698] Set [VAR[state]]'s [F[94 final set]] [ [N[7/13]] ] to the result of 
[[getting a G set][get a G set]] with
[N[96]], [N[1]], [I[96]], [N[7/13]].


]FIG]
: "marc" :
[FIG(steps)[

= [44] Set [VAR[state]]'s [F[escape set]] [ [N[6/2]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[6/2]]).
= [63] Set [VAR[state]]'s [F[escape set]] [ [N[7/0]] ] to 
[[character]] ([I[marc]], [I[esc]], [N[7/0]]).
= [930] [[For each]] [VAR[F]] in [ [N[3/2]], [N[3/4]] ]:
== [931] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[marc]], [VAR[F]].


]FIG]
: "vt" :
[FIG(steps)[

= [126] [[For each]] [VAR[bc]] in 
[ [N[3/1]], [N[3/4]] ],
[N[3/8]], [N[3/9]], 
[N[6/4]], [N[6/11]], [N[6/12]]:
== [120] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to
[[character]] ([I[vt]], [I[esc]], [VAR[bc]]).
= [924] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/8]] ]:
== [925] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [VAR[F]].
= [970] Set [VAR[state]]'s [F[94 final set]] [ [N[4/3]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/5]].
= [971] Set [VAR[state]]'s [F[94 final set]] [ [N[4/5]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/6]].
= [972] Set [VAR[state]]'s [F[94 final set]] [ [N[4/8]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/7]].
= [973] Set [VAR[state]]'s [F[94 final set]] [ [N[5/1]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[94]], [N[3/9]].
= [124] Set [VAR[state]]'s [F[94 final set]] [ [N[4/11]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[4/11]].
= [976] Set [VAR[state]]'s [F[94 final set]] [ [N[5/5]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[5/5]].




]FIG]
: "vt52" :
[FIG(steps)[

= [122] [[For each]] [VAR[bc]] in 
[N[6/2]], [N[6/3]], [N[6/4]], [N[6/11]], [N[6/12]], [N[6/15]],
[N[7/0]], [N[7/2]]:
== [121] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to
[[character]] ([I[vt52]], [I[esc]], [VAR[bc]]).
= [942] Set [VAR[state]]'s [F[94 final set]] [ [N[8/6]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt52]], [N[8/6]].

]FIG]
: "vt100" :
[FIG(steps)[

= [941] Set [VAR[state]]'s [F[94 final set]] [ [N[8/6]] ]
to the result of
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[vt]], [N[8/6]].

]FIG]
: "vt105" :
[FIG(steps)[

= [783] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[vt105]], [I[esc]], [N[3/1]]).
= [784] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[vt105]], [I[esc]], [N[3/2]]).

]FIG]
: "tektronix" :
[FIG(steps)[

= [405] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [757] Set [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ] to 
[[character]] ([I[tektronix]], [I[esc]], [VAR[bc]]).
= [762] Set [VAR[state]]'s [F[escape set]] [ [N[3/8]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/8]]).
= [763] Set [VAR[state]]'s [F[escape set]] [ [N[3/9]] ] to
[[character]] ([I[tektronix]], [I[esc]], [N[3/9]]).

]FIG]
: "escshift" :
[FIG(steps)[

= [933] Set [VAR[state]]'s [F[escape set]] [ [N[0/14]] ] to
[[character]] ([I[deprecated]], [CODE(charname)@en[LS1]]).
= [934] Set [VAR[state]]'s [F[escape set]] [ [N[0/15]] ] to
[[character]] ([I[deprecated]], [CODE(charname)@en[LS0]]).


]FIG]
: "noesccl" :
[FIG(steps)[

= [205] [[For each]] [VAR[bc]] in [ [N[0/0]], [N[1/15]] ]:
== [228] [[Remove][remove an entry]] [VAR[state]]'s [F[escape set]] [ [VAR[bc]] ].

]FIG]
: "decea" :
[FIG(steps)[

= [905] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[3/0]].
= [906] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/1]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/0]].
= [907] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [N[3/3]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[4/2]].
= [909] [[For each]] [VAR[F]] in [N[3/1]], [N[3/3]], [N[4/1]], and [N[4/2]]:
== [910] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[94[SUP[2]]]], [N[3/0]].
= [914] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] RL final set]] [ [N[4/0]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[dec]], [I[udc1978]].


]FIG]
: "mule" :
[FIG(steps)[

= [767] Set [VAR[state]]'s [F[escape set]] [ [N[3/1]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/1]]).
= [768] Set [VAR[state]]'s [F[escape set]] [ [N[3/2]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/2]]).
= [769] Set [VAR[state]]'s [F[escape set]] [ [N[3/3]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/3]]).
= [770] Set [VAR[state]]'s [F[escape set]] [ [N[3/4]] ] to
[[character]] ([I[mule]], [I[esc]], [N[3/4]]).
= [926] [[For each]] [VAR[F]] in [ [N[3/0]], [N[3/5]] ]:
== [927] Set [VAR[state]]'s [F[94 final set]] [ [VAR[F]] ] to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[1]], [I[mule-94]], [VAR[F]].
= [900] [[For each]] [VAR[F]] in 
[N[3/0]], [N[3/1]], [N[3/3]], and [ [N[3/5]], [N[3/8]] ]:
== [899] Set [VAR[state]]'s [F[94[SUP[[VAR[n]]]] final set]] [ [VAR[F]] ]
to the result of 
[[getting a G set][get a G set]] with
[N[94]], [N[2]], [I[mule-94[SUP[2]]]], [VAR[F]].

]FIG]


]FIG]

]FIG]

* Definitions

[14] 
This document depends on the [CITE[Infra Standard]].

[15] 
The terms
[DFN[for each][For each]],
[DFN[while][While]],
[DFN[boolean]],
[DFN[byte]],
[DFN[byte sequence]],
[DFN[[F[length]]]],
[DFN[code point]],
[DFN[item]],
[DFN[tuple]],
[DFN[list]],
[DFN[[F[size]]]],
[DFN[append]],
[DFN[extend]],
[DFN[ordered map]],
[DFN[entry]],
[DFN[key]],
[DFN[value]],
[DFN[exists]],
[DFN[remove an entry]],
and
[DFN[is empty]]
are defined by the [CITE[Infra Standard]].


-*-*-

[572] 
A [DFN[range]] [VAR[range]] is a [[tuple]] of two integers 
([DFN[[F[start]]]], [DFN[[F[end]]]]),
where [VAR[range]]'s [F[start]] ≦ [VAR[range]]'s [F[end]].
It represents a set of all the integers [VAR[i]]
that satisfies [VAR[range]]'s [F[start]] ≦ [VAR[i]] ≦ [VAR[range]]'s [F[end]].

[573] 
A value [VAR[i]] is in a [[range]] [VAR[range]] if 
[VAR[i]] is an item in the set represented by [VAR[range]].

@@ switch

-*-*-


[16] 
A [DFN[bit combination]] is a [[byte]].
A [[bit combination]] is represented as "[VAR[X]]/[VAR[Y]]",
where [VAR[X]] and [VAR[Y]] are integers in [ [N[0]], [N[15]] ],
which represents a [[byte]] [VAR[X]] × [N[16]] + [VAR[Y]].

[89] 
To [DFN[append][append to a byte sequence]] a [[bit combination]] [VAR[bc]]
to a [[byte sequence]] [VAR[bytes]], run these steps:

[FIG(steps)[
= [90] Replace [VAR[bytes]]'s content by [VAR[bytes]] followed by [VAR[bc]].
]FIG]

[91] The [DFN[empty byte sequence]] is a [[byte sequence]] whose [F[length]]
is [N[0]].


* Notes

@@
[[SCI]],
[[OSC]],
[[DCS]],
[[APC]],
[[CSI]]
