[SEE[ [[ISO/IEC 2022]] ]]

* ISO/IEC 2022 Decoder

[1] A [DFN[state]] is:

[FIG(list members)[

: [F[C0 designated]] : [[C0 set]].
Initially, the [[initial C0 set]].
: [F[2/0 designated]] : [CODE(charname)@en[SP]] or [CODE(charname)@en[MSP]].
Initially, [CODE(charname)@en[SP]].
: [F[7/15 designated]] : [CODE(charname)@en[DEL]].
: [F[C1 designated]] : [[C1 set]].
Initially. the [[empty C1 set]].
: [F[10/0 designated]] : [CODE(charname)@en[MSP]] or ([I[unassigned]], [[10/0]]).
Initially, ([I[unassigned]], [[10/0]]).
: [F[15/15 designated]] : ([I[unassigned]], [[15/15]]).
: [DFN[[F[G0 designated]]]] : [[G set]].
Initially, the [[empty 94 set]].
: [DFN[[F[G1 designated]]]] : [[G set]].
Initially, the [[empty 94 set]].
: [DFN[[F[G2 designated]]]] : [[G set]].
Initially, the [[empty 94 set]].
: [DFN[[F[G3 designated]]]] : [[G set]].
Initially, the [[empty 94 set]].
: [DFN[[F[bits]]]] : [I[8-bit]] or [I[7-bit]].
Initially, [I[8-bit]].
: [DFN[[F[MARC-8 flag]]]] : [[Boolean][boolean]].
Initially, [[false]].
: [DFN[[F[GL invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[GR invoked]]]] : [[G element]] or [CODE[null]].
Initially, [CODE[null]].
: [DFN[[F[current sequence]]]] : [[Character string][character string]].
: [DFN[[F[current element]]]] : [[C element]] or [[G element]].
: [DFN[[F[current size]]]] : [N[94]] or [N[96]].
: [DFN[[F[current I byte]]]] : [[Byte][byte]].
: [DFN[[F[PCD PM]]]] : [[Byte][byte]].
: [DFN[[F[PCD PI]]]] : [[Byte][byte]].
: [DFN[[F[PCD LI]]]] : Non-negative integer.
: [DFN[[F[PCD data]]]] : [[Byte sequence][byte sequence]].
: [DFN[[F[decoder state]]]] : One of [[decoder states][decoder state]].
Initially, [[initial state]].

]FIG]

[223] A [DFN[C element]] is [I[C0]] or [I[C1]].

[100] A [DFN[G element]] is [I[G0]], [I[G1]], [I[G2]], or [I[G3]].

[117] A [DFN[maximum sequence length]] is an implementation-specific integer,
e.g. [N[15]].

[94] A [DFN[maximum chunk length]] is an implementation-specific integer,
e.g. 2[SUP[30]] - 1.


[315] 
To [DFN[get invoked set]] with [VAR[state]] and [VAR[element]], run these steps:

[FIG(steps)[
= [302] If [VAR[element]] is [CODE[null]]:
== [303] Return the [[empty 94 set]].
= [304] Otherwise, if [VAR[element]] is [I[G0]]:
== [305] Return [VAR[state]]'s [F[G0 designated]].
= [306] Otherwise, if [VAR[element]] is [I[G1]]:
== [307] Return [VAR[state]]'s [F[G1 designated]].
= [308] Otherwise, if [VAR[element]] is [I[G2]]:
== [309] Return [VAR[state]]'s [F[G2 designated]].
= [310] Otherwise, if [VAR[element]] is [I[G3]]:
== [311] Return [VAR[state]]'s [F[G3 designated]].
]FIG]

** Input stream

@@

[20] A [[state initialization steps]] is a set of zero or more steps
that modifies [VAR[state]].  It [MAY[MAY]] modify [VAR[state]] in these ways:

- [21] Modify values of [VAR[state]]'s 
[F[C0 designated]],
[F[2/0 designated]],
[F[7/15 designated]],
[F[C1 designated]],
[F[10/0 designated]],
[F[15/15 designated]],
[F[G0 designated]],
[F[G1 designated]],
[F[G2 designated]],
[F[G3 designated]],
[F[bits]],
and/or
[F[MARC-8 flag]].


@@
[VAR[input stream]],
[VAR[initialization steps]] a [[state initialization steps]],
run these steps:

[FIG(steps)[
= [8] Let [VAR[state]] be a new [[state]].
= [9] Run [VAR[initialization steps]] with [VAR[state]].
= [6] 
Let [VAR[output stream]] be a [[list]].
[NOTE[
[97] [VAR[output stream]] might contain
[[characters][character]],
[[PCD data]],
and
[[EOF]].
]NOTE]
= [10] 
@@
Process the input stream,
a sequence of zero or more [[bit combinations][bit combination]]
= [7] 
Return [VAR[output stream]].
]FIG]


** Output stream

@@

[4] 
To [DFN[emit a character]] with [[character]] [VAR[char]], run these steps:

[FIG(steps)[
= 
[5] 
[[Append][append]]
[VAR[char]]
to 
[VAR[output stream]].
]FIG]

[115] 
To [DFN[emit a sequence]]  with [[character string]] [VAR[seq]], run these steps:

[FIG(steps)[
=
[116] 
[[Extend][extend]]
[VAR[output stream]]
with 
[VAR[seq]].
]FIG]

[95] 
To [DFN[emit a PCD data]] with [[byte]] [VAR[PM]], [[byte]] [VAR[PI]], 
[[byte sequence]] [VAR[data]], run these steps:

[FIG(steps)[
=
[96] 
[[Append][append]]
a new [[PCD data]]
to 
[VAR[output stream]]:
[FIG(list members)[
:[F[picture mode]]: [VAR[PM]]
:[F[picture identifier]]: [VAR[PI]]
:[F[picture data entity]]: [VAR[data]]
]FIG]

]FIG]


[355] 
When [DFN[error]], run these steps:

[FIG(steps)[
= [356] An error [MAY[may]] be reported to a [[developer console]].
]FIG]

[58] 
When [DFN[deprecated]], run these steps:

[FIG(steps)[
= [59] A warning [MAY[may]] be reported to a [[developer console]].
]FIG]


@@[DFN[reconsume]]

@@

** Decoder states

[2] There are the following [DFN[decoder states][decoder state]]:

*** Initial state

[3] The [DFN[initial state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[1/15]] ] :
[FIG(steps)[

= [11] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
= [12] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [29] If [VAR[char]] is [CODE(charname)@en[ESC]]:
== [30] Set [VAR[state]]'s [F[decoder state]] to [[escape state]].
= [209] Otherwise, if [VAR[char]] is [CODE(charname)@en[LS0]]:
== [210] Set [VAR[state]]'s [F[GL invoked]] to [I[G0]].
= [211] Otherwise, if [VAR[char]] is [CODE(charname)@en[LS1]]:
== [212] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [213] Otherwise, if [VAR[char]] is [CODE(charname)@en[SS2]]:
== [226] Set [VAR[state]]'s [F[current element]] to [I[G2]].
== [214] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [215] Otherwise, if [VAR[char]] is [CODE(charname)@en[SS3]]:
== [227] Set [VAR[state]]'s [F[current element]] to [I[G3]].
== [216] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [31] Otherwise:
== [13] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [[2/0]] :
[FIG(steps)[

= [319] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [320] If [VAR[set]] [[is a 96 set]]:
== [317] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [321] Otherwise:
== [316] Let [VAR[char]] be [VAR[state]]'s [F[2/0 designated]].
= [318] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
:[ [[2/1]], [[7/14]] ]:
[FIG(steps)[

= [314] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [312] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [313] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [[7/15]] :
[FIG(steps)[

= [322] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GL invoked]].
= [323] If [VAR[set]] [[is a 96 set]]:
== [324] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [325] Otherwise:
== [326] Let [VAR[char]] be [VAR[state]]'s [F[7/15 designated]].
= [327] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [ [N[8/0]], [N[9/15]] ] :
[FIG(steps)[

= [26] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [27] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [199] If [VAR[char]] is [CODE(charname)@en[SS2]]:
== [228] Set [VAR[state]]'s [F[current element]] to [I[G2]].
== [200] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [201] Otherwise, if [VAR[char]] is [CODE(charname)@en[SS3]]:
== [229] Set [VAR[state]]'s [F[current element]] to [I[G3]].
== [202] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [203] Otherwise:
== [28] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [[10/0]] :
[FIG(steps)[

= [328] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [329] If [VAR[set]] [[is a 96 set]]:
== [330] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
= [331] Otherwise:
== [332] Let [VAR[char]] be [VAR[state]]'s [F[10/0 designated]].
= [333] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
:[ [[10/1]], [[15/14]] ]:
[FIG(steps)[

= [334] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [335] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
= [336] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [[15/15]] :
[FIG(steps)[

= [337] Let [VAR[set]] be the result of
[[getting invoked set][get invoked set]] with
[VAR[state]] and [VAR[state]]'s [F[GR invoked]].
= [338] If [VAR[set]] [[is a 96 set]]:
== [339] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
= [340] Otherwise:
== [341] Let [VAR[char]] be [VAR[state]]'s [F[15/15 designated]].
= [342] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** SS state

[217] The [DFN[SS state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[[2/0]], [[7/15]], [[10/0]], [[15/15]]:
[FIG(steps)[

= [353] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [349] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [350] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [351] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [352] If [VAR[set]] [[is 96 set]]:
== [364] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
== [365] [[Emit a character][emit a character]] [VAR[char]].
= [354] Otherwise:
== [366] [[Error][error]].
== [367] If [VAR[state]]'s [F[current element]] is [I[G2]]:
=== [368] [[Emit a character][emit a character]] [CODE(charname)@en[SS2]].
== [369] If [VAR[state]]'s [F[current element]] is [I[G3]]:
=== [370] [[Emit a character][emit a character]] [CODE(charname)@en[SS3]].
== [371] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
== [372] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]
:[ [[2/1]], [[7/14]] ], [ [[10/1]], [[15/14]] ]:
[FIG(steps)[

= [344] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [343] Let [VAR[set]] be [VAR[state]]'s [F[G2 designated]].
= [345] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [346] Let [VAR[set]] be [VAR[state]]'s [F[G3 designated]].
= [347] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] & [N[0b01111111]] ].
= [348] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: Otherwise :
[FIG(steps)[

= [357] [[Error][error]].
= [360] If [VAR[state]]'s [F[current element]] is [I[G2]]:
== [361] [[Emit a character][emit a character]] [CODE(charname)@en[SS2]].
= [362] If [VAR[state]]'s [F[current element]] is [I[G3]]:
== [363] [[Emit a character][emit a character]] [CODE(charname)@en[SS3]].
= [359] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [358] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape state

[32] The [DFN[escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [[2/0]] :
[FIG(steps)[

= [136] Set [VAR[state]]'s [F[decoder state]] to [I[escape announce state]].

]FIG]
: [[2/1]] :
[FIG(steps)[

= [218] Set [VAR[state]]'s [F[current element]] to [I[C0]].
= [157] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [[2/2]] :
[FIG(steps)[

= [230] Set [VAR[state]]'s [F[current element]] to [I[C1]].
= [158] Set [VAR[state]]'s [F[decoder state]] to [I[escape control state]].

]FIG]
: [[2/4]] :
[FIG(steps)[

@@

]FIG]
: [[2/5]] :
[FIG(steps)[

@@

]FIG]
: [[2/6]] :
[FIG(steps)[

@@

]FIG]
: [[2/8]] :
[FIG(steps)[

= [104] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [294] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [105] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/9]] :
[FIG(steps)[

= [111] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [168] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [170] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/10]] :
[FIG(steps)[

= [169] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [235] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [295] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/11]] :
[FIG(steps)[

= [234] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [296] Set [VAR[state]]'s [F[current size]] to [N[94]].
= [297] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/12]] :
[FIG(steps)[

= [279] [[Deprecated][deprecated]].
= [277] Set [VAR[state]]'s [F[current element]] to [I[G0]].
= [278] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [281] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/13]] :
[FIG(steps)[

= [280] Set [VAR[state]]'s [F[current element]] to [I[G1]].
= [283] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [285] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/14]] :
[FIG(steps)[

= [282] Set [VAR[state]]'s [F[current element]] to [I[G2]].
= [298] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [299] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
: [[2/15]] :
[FIG(steps)[

= [284] Set [VAR[state]]'s [F[current element]] to [I[G3]].
= [300] Set [VAR[state]]'s [F[current size]] to [N[96]].
= [301] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic state]].

]FIG]
:[ [[3/0]], [[3/15]] ], [[6/0]], [[6/1]], [[6/3]], [[6/5]], [[6/6]], [[6/8]], [[6/9]], [[7/1]], [[7/2]], [ [[7/4]], [[7/11]] ]:
[FIG(steps)[

= [35] [[Emit a character][emit a character]]
([VAR[escape]], [VAR[bc]]).
= [40] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [[4/0]], [[5/15]] ]:
[FIG(steps)[

= [36] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [37] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] + 0x40 ].
= [204] If [VAR[char]] is [CODE(charname)@en[SS2]]:
== [224] Set [VAR[state]]'s [F[current element]] to [I[G2]].
== [205] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [206] Otherwise, if [VAR[char]] is [CODE(charname)@en[SS3]]:
== [225] Set [VAR[state]]'s [F[current element]] to [I[G3]].
== [207] Set [VAR[state]]'s [F[decoder state]] to [I[SS state]].
= [208] Otherwise:
== [38] [[Emit a character][emit a character]] [VAR[char]].
== [39] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[6/2]] :
[FIG(steps)[

= [41] If [VAR[state]]'s [F[MARC-8 flag]] is [[true]]:
== [49] 
Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with 
[N[94]], [I[escape]], [VAR[bc]].
= [42] Otherwise:
== [43] [[Emit a character][emit a character]]
([VAR[escape]], [VAR[bc]]).
= [44] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[6/4]] :
[FIG(steps)[

= [48] Set [VAR[state]]'s [F[decoder state]] to [I[foreign state]].

]FIG]
: [[6/7]], [[7/3]] :
[FIG(steps)[

= [273] Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with 
[N[94]], [I[escape]], [VAR[bc]].

]FIG]
: [[6/11]] :
[FIG(steps)[

= [55] [[Deprecated][deprecated]].
= [118] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [119] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [120] Otherwise:
== [52] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
: [[6/12]] :
[FIG(steps)[

= [56] [[Deprecated][deprecated]].
= [121] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [122] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [123] Otherwise:
== [53] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
: [[6/13]] :
[FIG(steps)[

= [57] [[Deprecated][deprecated]].
= [124] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [125] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [126] Otherwise:
== [54] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
: [[6/14]] :
[FIG(steps)[

= [60] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].

]FIG]
: [[6/15]] :
[FIG(steps)[

= [61] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].

]FIG]
: [[7/0]] :
[FIG(steps)[

= [62] If [VAR[state]]'s [F[MARC-8 flag]] is [[true]]:
== [63]  
Set [VAR[state]]'s [F[G0 designated]] to the result of 
[[getting a graphic set][get a graphic set]] 
with 
[N[94]], [I[escape]], [VAR[bc]].
== [66] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [64] Otherwise:
== [65] Set [VAR[state]]'s [F[decoder state]] to [I[PCD state]].

]FIG]
: [[7/12]] :
[FIG(steps)[

= [127] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [128] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].
= [129] Otherwise:
== [101] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
: [[7/13]] :
[FIG(steps)[

= [130] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [131] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].
= [132] Otherwise:
== [102] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
: [[7/14]] :
[FIG(steps)[

= [133] If [VAR[state]]'s [F[bits]] is [I[7-bit]]:
== [134] Set [VAR[state]]'s [F[GL invoked]] to [I[G1]].
= [135] Otherwise:
== [103] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
: Otherwise :
[FIG(steps)[

= [375] [[Error][error]].
= [33] Set [VAR[state]]'s [F[current sequence]] be an [[empty character string]].
= [34] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned escape state]].
= [156] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape announce state

[137] The [DFN[escape announce state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[4/1]], [[7/14]] ] :
[FIG(steps)[

= [138] Let [VAR[announce]] be [VAR[bc]] - 0x40.
= [139] If [VAR[announce]] is one of:
[N[1]],
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [140] Set [VAR[state]]'s [F[GL invoked]] be [I[G0]].
= [141] If [VAR[announce]] is [N[1]] or [N[2]]:
== [142] Set [VAR[state]]'s [F[GR invoked]] be [CODE[null]].
= [143] If [VAR[announce]] is one of:
[N[3]],
[N[12]],
[N[13]],
or
[N[14]]:
== [144] Set [VAR[state]]'s [F[GR invoked]] be [I[G1]].
= [145] If [VAR[announce]] is one of:
[N[12]],
[N[13]],
or
[N[14]]:
== [146] Set [VAR[state]]'s [F[2/0 designated]] be [CODE(charname)@en[SP]].
== [147] Set [VAR[state]]'s [F[7/14 designated]] be [CODE(charname)@en[DEL]].
= [148] If [VAR[announce]] is one of:
[N[11]],
[N[12]],
[N[13]],
or
[N[14]]:
== [149] Set [VAR[state]]'s [F[bits]] be [I[8-bit]].
= [150] If [VAR[announce]] is [N[10]]:
== [151] Set [VAR[state]]'s [F[bits]] be [I[7-bit]].

]FIG]
: Otherwise :
[FIG(steps)[

= [376] [[Error][error]].
= [152] Set [VAR[state]]'s [F[current sequence]] be an [[empty character string]].
= [153] [[Append][append]] 
a [[character]] ([I[sequence]], [[2/0]])
to [VAR[state]]'s [F[current sequence]].
= [155] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned escape state]].
= [154] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape control state

[159] The [DFN[escape control state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [164] Let [VAR[state]]'s [F[C0 designated]] be the result of 
[[getting a C0 set][get a C0 set]] [VAR[bc]].
= [232] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [233] Let [VAR[state]]'s [F[C1 designated]] be the result of 
[[getting a C1 set][get a C1 set]] [VAR[bc]].

]FIG]
: Otherwise :
[FIG(steps)[

= [377] [[Error][error]].
= [160] Set [VAR[state]]'s [F[current sequence]] be an [[empty character string]].
= [231] If [VAR[state]]'s [F[current element]] is [I[C0]]:
== [166] Let [VAR[i]] be [[2/1]].
= [167] Otherwise, if [VAR[state]]'s [F[current element]] is [I[C1]]:
== [165] Let [VAR[i]] be [[2/2]].
= [161] [[Append][append]] 
a [[character]] ([I[sequence]], [VAR[i]])
to [VAR[state]]'s [F[current sequence]].
= [162] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned escape state]].
= [163] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Escape graphic state

[236] The [DFN[escape graphic state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/3]] ] :
[FIG(steps)[

= [254] Set [VAR[state]]'s [F[current I byte]] to [VAR[bc]].
= [255] Set [VAR[state]]'s [F[decoder state]] to [I[escape graphic I state]].

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [237] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [238] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [239] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [240] Set [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [286] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [287] Set [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].
= [288] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [289] Set [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[CODE[null]], [VAR[bc]].

]FIG]
: Otherwise :
[FIG(steps)[

= [378] [[Error][error]].
= [241] Set [VAR[state]]'s [F[current sequence]] be an [[empty character string]].
= [242] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [243] Let [VAR[i]] be [[2/8]].
= [244] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [245] Let [VAR[i]] be [[2/9]].
= [246] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [247] Let [VAR[i]] be [[2/10]].
= [248] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [249] Let [VAR[i]] be [[2/11]].
= [250] [[Append][append]] 
a [[character]] ([I[sequence]], [VAR[i]])
to [VAR[state]]'s [F[current sequence]].
= [251] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned escape state]].
= [252] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]



*** Escape graphic I state

[253] The [DFN[escape graphic I state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [257] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [256] Set [VAR[state]]'s [F[G0 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [258] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [259] Let [VAR[state]]'s [F[G1 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [290] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [291] Let [VAR[state]]'s [F[G2 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].
= [292] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [293] Let [VAR[state]]'s [F[G3 designated]] to the result of
[[getting a graphic set][get a graphic set]] with
[VAR[state]]'s [F[current size]],
[VAR[state]]'s [F[current I byte]], [VAR[bc]].

]FIG]
: Otherwise :
[FIG(steps)[

= [379] [[Error][error]].
= [260] Set [VAR[state]]'s [F[current sequence]] be an [[empty character string]].
= [261] If [VAR[state]]'s [F[current element]] is [I[G0]]:
== [262] Let [VAR[i]] be [[2/8]].
= [263] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G1]]:
== [264] Let [VAR[i]] be [[2/9]].
= [265] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G2]]:
== [266] Let [VAR[i]] be [[2/10]].
= [267] Otherwise, if [VAR[state]]'s [F[current element]] is [I[G3]]:
== [268] Let [VAR[i]] be [[2/11]].
= [270] Set [VAR[i]] to [VAR[i]] followed by [VAR[state]]'s [F[current I byte]].
= [271] [[Append][append]] 
a [[character]] ([I[sequence]], [VAR[i]])
to [VAR[state]]'s [F[current sequence]].
= [269] Set [VAR[state]]'s [F[decoder state]] to [I[unassigned escape state]].
= [272] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** Unassigned escape state

[106] The [DFN[unassigned escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [[2/0]], [[2/15]] ] :
[FIG(steps)[

= [107] [[Append][append]] 
a [[character]] ([I[sequence]], [VAR[bc]])
to [VAR[state]]'s [F[current sequence]].
= [110] If [VAR[state]]'s [F[current sequence]]'s [[length]]
is equal to the [[maximum sequence length]]:
== 
@@

]FIG]
: [ [[3/0]], [[7/14]] ] :
[FIG(steps)[

= [108] [[Append][append to a byte sequence]] 
a [[character]] ([I[sequence]], [VAR[bc]])
to [VAR[state]]'s [F[current sequence]].
= [114] [[Emit a sequence][emit a sequence]]
[VAR[state]]'s [F[current sequence]].
= [109] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD state

[67] The [DFN[PCD state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [68] Set [VAR[state]]'s [F[PCD PM]] to [VAR[bc]].
= [69] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PM state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PM state

[70] The [DFN[PCD PM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [71] Set [VAR[state]]'s [F[PCD PI]] to [VAR[bc]].
= [73] Set [VAR[state]]'s [F[PCD LI]] to [N[0]].
= [72] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PI state

[74] The [DFN[PCD PI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[10/0]], [[11/1]] ]:
[FIG(steps)[

= [75] Set [VAR[state]]'s [F[PCD LI]] to ([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [77] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@

]FIG]
:[ [[8/13]], [[9/14]] ]:
[FIG(steps)[

= [78] Set [VAR[state]]'s [F[PCD LI]] to 
([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [79] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@
= [87] Set [VAR[state]]'s [F[PCD data]] to the [[empty byte sequence]].
= [82] If [VAR[state]]'s [F[PCD LI]] is zero:
== [93] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [83] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [84] Otherwise:
== [80] Set [VAR[state]]'s [F[decoder state]] to [I[PCD LI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD LI state

[81] The [DFN[PCD LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [88] [[Append][append to a byte sequence]] [VAR[bc]] to [VAR[state]]'s [F[PCD data]].
= [76] Set [VAR[state]]'s [F[PCD LI]] to [VAR[state]]'s [F[PCD LI]] - 1.
= [85] If [VAR[state]]'s [F[PCD LI]] is zero:
== [92] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [86] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** Foreign state

[50] The [DFN[foreign state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [51] [[Emit a character][emit a character]]
([VAR[unassigned]], [VAR[bc]]).

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

* Character sets

[17] 
A [DFN[character set]] is an [[ordered map]],
where [[keys][key]] are [[byte sequences][byte sequence]] and
[[values][value]] are a [[character]].

[171] 
To [DFN[get a character set]] with
[[byte]] [VAR[start]],
[[byte]] [VAR[end]],
[VAR[t1]],
and
[VAR[t2]],
run these steps:

[FIG(steps)[

= [172] Let [VAR[set]] be a new [[character set]].
= [173] [[For each]] [VAR[c]] in [ [VAR[start]], [VAR[end]] ]:
== [174] Let [VAR[set]] [ [VAR[c]] ] be
a [[character]] ([VAR[t1]], [VAR[t2]], [VAR[c]]).
= [175] Return [VAR[set]].

]FIG]


[22] 
A [DFN[C0 set]] is a [[character set]] whose [[keys][key]] are 
«
[[0/0]],
[[0/1]],
...,
[[1/15]]
».

[176] 
To [DFN[get a C0 set]] [VAR[F]], run these steps:

[FIG(steps)[

= [177] Let [VAR[set]] be the result of 
[[getting a character set][get a character set]] 
with [[0/0]], [[1/15]], [I[C0]], and [VAR[F]].
= [180] If [VAR[F]] is ''not'' [[7/14]]:
== [178] Set [VAR[set]] [ [[1/11]] ] to [CODE(charname)@en[ESC]].
= [187] If [VAR[F]] is one of:
[[4/1]] ([[ISO-IR]] 1),
[[4/3]] ([[ISO-IR]] 26),
[[4/4]] ([[ISO-IR]] 36),
[[4/6]] ([[ISO-IR]] 74),
[[4/11]] ([[ISO-IR]] 135),
[[4/12]] ([[ISO-IR]] 140),
[[4/5]] ([[ISO-IR]] 106),
[[4/8]] ([[ISO-IR]] 130),
or
[[4/10]] ([[ISO-IR]] 134):
== [188] Set [VAR[set]] [ [[0/14]] ] to [CODE(charname)@en[LS1]].
== [189] Set [VAR[set]] [ [[0/15]] ] to [CODE(charname)@en[LS0]].
= [190] If [VAR[F]] is [[4/4]] ([[ISO-IR]] 36):
== [191] Set [VAR[set]] [ [[1/12]] ] to [CODE(charname)@en[SS2]].
= [192] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 106),
[[4/9]] ([[ISO-IR]] 132),
[[4/10]] ([[ISO-IR]] 134),
or 
[[4/12]] ([[ISO-IR]] 135):
== [193] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
== [193] Set [VAR[set]] [ [[1/14]] ] to [CODE(charname)@en[SS3]].
= [194] If [VAR[F]] is [[4/12]] ([[ISO-IR]] 140):
== [195] Set [VAR[set]] [ [[1/9]] ] to [CODE(charname)@en[SS2]].
= [179] Return [VAR[set]].

]FIG]

[19] 
The [DFN[initial C0 set]] is the result of 
[[getting a C0 set][get a C0 set]] [I[unassigned]].

[23] 
A [DFN[C1 set]] is a [[character set]] whose [[keys][key]] are
«
[[8/0]],
[[0/1]],
...,
[[9/15]]
».

[25] 
To [DFN[get a C1 set]] [VAR[F]], run these steps:

[FIG(steps)[

= [181] Let [VAR[set]] be the result of 
[[getting a character set][get a character set]] 
with [[8/0]], [[9/15]], [I[C1]], and [VAR[F]].
= [196] If [VAR[F]] is one of:
[[4/5]] ([[ISO-IR]] 40),
[[4/3]] ([[ISO-IR]] 77),
or
[[4/7]] ([[ISO-IR]] 105):
== [197] Set [VAR[set]] [ [[8/14]] ] to [CODE(charname)@en[SS2]].
== [198] Set [VAR[set]] [ [[8/15]] ] to [CODE(charname)@en[SS3]].
= [182] Return [VAR[set]].

]FIG]

[24] 
The [DFN[empty C1 set]] is the result of 
[[getting a C1 set][get a C1 set]] [[7/14]].

@@
[45] 
A [DFN[G set]] is ...

[373] 
A [DFN[96 set]] is a [[character set]] whose [[keys][key]] are
«
[[2/0]],
[[2/1]],
...,
[[7/15]]
».

[374] 
Whether a [[character set]] [VAR[set]] [DFN[is 96 set]] is [[true]]
when [VAR[set]] is a [[96 set]].


[46] 
To [DFN[get a graphic set]] with 
[VAR[size]], [VAR[I]], and [VAR[F]], run these steps:

[FIG(steps)[

= [47] If 
[VAR[size]] is [N[94]],
[VAR[I]] is [I[escape]], and 
[VAR[F]] is [[7/3]]:
== [275] Return the result of
[[getting a graphic set][get a graphic set]] with
[N[94]], [CODE[null]], [[4/2]].
[NOTE[
This is [[MARC-8]]'s [[ASCII]].
]NOTE]
== [276] Abort these steps.
= [220] If [VAR[I]] is ''not'' [CODE[null]]:
== [221] Let [VAR[f]] be [VAR[I]] followed by [VAR[F]].
= [222] Otherwise:
== [219] Let [VAR[f]] be [VAR[F]].
= [183] Let [VAR[set]] be the result of running the steps to
[[get a character set]] 
with [[2/1]], [[7/14]], [VAR[size]], and [VAR[f]].
= [184] Return [VAR[set]].

]FIG]

[NOTE[
[274] The following combinations of 
[VAR[size]], [VAR[I]], and [VAR[F]] are used:

- ([VAR[size]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [[3/0]], [[3/15]] ]
- ([VAR[size]], [CODE[null]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [[4/0]], [[7/13]] ]
- ([VAR[size]], [CODE[null]], [[7/14]]) where
[VAR[size]] is [N[94]] or [N[96]]
- ([VAR[size]], [[2/0]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]] and
[VAR[F]] is in [ [[3/0]], [[7/14]] ]
- ([VAR[size]], [VAR[I]], [VAR[F]]) where
[VAR[size]] is [N[94]] or [N[96]], 
[VAR[I]] is in [ [[2/1]], [[2/3]] ], and
[VAR[F]] is in [ [[3/0]], [[3/15]] ]
- ([VAR[size]], [VAR[I]], [VAR[F]]) where 
[VAR[size]] is [N[94]] or [N[96]],
[VAR[I]] is in [ [[2/1]], [[2/3]] ], and
[VAR[F]] is in [ [[4/0]], [[7/14]] ]
- ([N[94]], [I[escape]], [[6/2]])
- ([N[94]], [I[escape]], [[6/7]])
- ([N[94]], [I[escape]], [[7/0]])
- ([N[94]], [I[escape]], [[7/3]])

]NOTE]

[185] 
The [DFN[empty 94 set]] is the result of 
[[getting a graphic set][get a graphic set]] with 
[N[94]], [CODE[null]], and [[7/14]].



* Definitions

[14] 
This document depends on the [CITE[Infra Standard]].

[15] 
The terms
[[for each][For each]],
[[boolean]],
[[byte]],
[[byte sequence]],
[[length]],
[[tuple]],
[[list]],
[[append]],
[[extend]],
[[ordered map]],
[[entry]],
[[key]],
and
[[value]]
are defined by the [CITE[Infra Standard]].

[16] 
A [DFN[bit combination]] is a [[byte]].
A [[bit combination]] is represented as "[VAR[X]]/[VAR[Y]]",
where [VAR[X]] and [VAR[Y]] are integers in [ [N[0]], [N[15]] ],
which represents a [[byte]] [VAR[X]] × [N[16]] + [VAR[Y]].

[89] 
To [DFN[append][append to a byte sequence]] a [[bit combination]] [VAR[bc]]
to a [[byte sequence]] [VAR[bytes]], run these steps:

[FIG(steps)[
= [90] Replace [VAR[bytes]]'s content by [VAR[bytes]] followed by [VAR[bc]].
]FIG]

[91] The [DFN[empty byte sequence]] is a [[byte sequence]] whose [[length]]
is [N[0]].

[18] 
A [DFN[character]] is one of followings:

- [CODE(charname)@en[ESC]]
- [CODE(charname)@en[SP]]
- [CODE(charname)@en[MSP]]
- [CODE(charname)@en[DEL]]
- [CODE(charname)@en[LS0]]
- [CODE(charname)@en[LS1]]
- [CODE(charname)@en[SS2]]
- [CODE(charname)@en[SS3]]
- [[tuple]] ([I[escape]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- [[tuple]] ([I[sequence]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- [[tuple]] ([I[unassigned]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- [[tuple]] ([I[C0]], [VAR[F]], [VAR[bc]]), 
where [VAR[bc]] and [VAR[F]] are [[bit combinations][bit combination]]
- [[tuple]] ([I[C1]], [VAR[F]], [VAR[bc]]), 
where [VAR[bc]] and [VAR[F]] are [[bit combinations][bit combination]]
- [[tuple]] ([I[94]], [VAR[F]], [VAR[bc]]), 
where [VAR[bc]] and [VAR[F]] are [[bit combinations][bit combination]]
- [[tuple]] ([I[96]], [VAR[F]], [VAR[bc]]), 
where [VAR[bc]] and [VAR[F]] are [[bit combinations][bit combination]]

;; [186] 
Interpretation of these [[tuples][tuple]] are application-specific.

[112] 
A [DFN[character string]] is a [[list]] of zero or more [[characters][character]].

[113] 
An [DFN[empty character string]] is a [[character string]] whose [[length]]
is [N[0]].


[98] 
A [DFN[PCD data]]
is a [[tuple]] consisting of:
[DFN[[F[picture mode]]]] ([[byte]]),
[DFN[[F[picture identifier]]]] ([[byte]]),
and
[DFN[[F[picture data]]]] ([[byte sequence]]).

@@
[99] 
[DFN[EOF]]


* Notes

@@macro code,
[[SCI]],
[[OSC]],
[[DCS]]
