[SEE[ [[ISO/IEC 2022]] ]]

* ISO/IEC 2022 Decoder

[1] A [DFN[state]] is:

[FIG(list members)[

: [F[C0 designated]] : [[C0 set]].
Initially, the [[initial C0 set]].
: [F[2/0 designated]] : [CODE(charname)@en[SP]] or [CODE(charname)@en[MSP]].
Initially, [CODE(charname)@en[SP]].
: [F[7/15 designated]] : [CODE(charname)@en[DEL]].
: [F[C1 designated]] : [[C1 set]].
Initially. the [[empty C1 set]].
: [F[10/0 designated]] : [CODE(charname)@en[MSP]] or ([I[unassigned]], [[10/0]]).
Initially, ([I[unassigned]], [[10/0]]).
: [F[15/15 designated]] : ([I[unassigned]], [[15/15]]).
: [F[G0 designated]] : [[G set]].
Initially, the [[empty 94 set]].
: [F[G1 designated]] : [[G set]].
Initially, the [[empty 94 set]].
: [F[G2 designated]] : [[G set]].
Initially, the [[empty 94 set]].
: [F[G3 designated]] : [[G set]].
Initially, the [[empty 94 set]].
: [F[MARC-8 flag]] : [[Boolean][boolean]].
Initially, [[false]].
: [F[decoder state]] : One of [[decoder states][decoder state]].
Initially, [[initial state]].

]FIG]

[94] A [[maximum chunk length]] is an implementation-specific integer,
e.g. 2[SUP[30]] - 1.

[20] A [[state initialization steps]] is a set of zero or more steps
that modifies [VAR[state]].  It [MAY[MAY]] modify [VAR[state]] in these ways:

- [21] Modify values of [VAR[state]]'s 
[F[C0 designated]],
[F[2/0 designated]],
[F[7/15 designated]],
[F[C1 designated]],
[F[10/0 designated]],
[F[15/15 designated]],
[F[G0 designated]],
[F[G1 designated]],
[F[G2 designated]],
[F[G3 designated]],
and/or
[F[MARC-8 flag]].


[4] 
To [DFN[emit a [[character]]]] [VAR[char]], run these steps:

[FIG(steps)[
= 
[5] 
[[Append][append]]
[VAR[char]]
to 
[VAR[output stream]].
]FIG]

[58] 
When [DFN[deprecated]], run these steps:

[FIG(steps)[
= [59] 
Usage of an undesired feature [MAY[may]] be reported to a [[developer console]].
]FIG]

@@
[VAR[input stream]],
[VAR[initialization steps]] a [[state initialization steps]],
run these steps:

[FIG(steps)[
= [8] Let [VAR[state]] be a new [[state]].
= [9] Run [VAR[initialization steps]] with [VAR[state]].
= [6] 
Let [VAR[output stream]] be a [[list]].
= [10] 
@@
Process the input stream,
a sequence of zero or more [[bit combinations][bit combination]]
= [7] 
Return [VAR[output stream]].
]FIG]

@@[DFN[reconsume]]

@@

** Decoder states

[2] There are the following [DFN[decoder states][decoder state]]:

*** Initial state

[3] The [DFN[initial state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[1/15]] ] :
[FIG(steps)[

= [11] Let [VAR[set]] be [VAR[state]]'s [F[C0 designated]].
= [12] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [29] If [VAR[char]] is [CODE(charname)@en[ESC]]:
== [30] 
Set [VAR[state]]'s [F[decoder state]] to [[escape state]].
= [31] Otherwise:
== [13] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [N[2/0]] :
[[Emit a character][emit a character]] [VAR[state]]'s [F[2/0 designated]].
: [N[7/15]] :
[[Emit a character][emit a character]] [VAR[state]]'s [F[7/15 designated]].
: [ [N[8/0]], [N[9/15]] ] :
[FIG(steps)[

= [26] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [27] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] ].
= [28] [[Emit a character][emit a character]] [VAR[char]].

]FIG]
: [N[10/0]] :
[[Emit a character][emit a character]] [VAR[state]]'s [F[10/0 designated]].
: [N[15/15]] :
[[Emit a character][emit a character]] [VAR[state]]'s [F[15/15 designated]].
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** Escape state

[32] The [DFN[escape state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[2/0]], [[2/15]] ]:
@@
:[ [[4/0]], [[5/15]] ]:
[FIG(steps)[

= [36] Let [VAR[set]] be [VAR[state]]'s [F[C1 designated]].
= [37] Let [VAR[char]] be [VAR[set]] [ [VAR[bc]] + 0x40 ].
= [38] [[Emit a character][emit a character]] [VAR[char]].
= [39] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
:[ [[3/0]], [[3/15]] ], [[6/0]], [[6/1]], [[6/3]], [ [[6/5]], [[6/9]] ], [ [[7/1]], [[7/14]] ]:
[FIG(steps)[

= [35] [[Emit a character][emit a character]]
([VAR[escape]], [VAR[bc]]).
= [40] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[6/2]] :
[FIG(steps)[

= [41] If [VAR[state]]'s [F[MARC-8 flag]] is [[true]]:
== [49] 
Set [VAR[state]]'s [F[G0 designated]] to [[94 set]] ([I[escape]], [VAR[bc]]).
= [42] Otherwise:
== [43] [[Emit a character][emit a character]]
([VAR[escape]], [VAR[bc]]).
= [44] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[6/4]] :
[FIG(steps)[

= [48] Set [VAR[state]]'s [F[decoder state]] to [I[foreign state]].

]FIG]
: [[6/11]] :
[FIG(steps)[

= [55] [[Deprecated][deprecated]].
= [52] Set [VAR[state]]'s [F[GR invoked]] to [I[G1]].

]FIG]
: [[6/12]] :
[FIG(steps)[

= [56] [[Deprecated][deprecated]].
= [53] Set [VAR[state]]'s [F[GR invoked]] to [I[G2]].

]FIG]
: [[6/13]] :
[FIG(steps)[

= [57] [[Deprecated][deprecated]].
= [54] Set [VAR[state]]'s [F[GR invoked]] to [I[G3]].

]FIG]
: [[6/14]] :
[FIG(steps)[

= [60] Set [VAR[state]]'s [F[GL invoked]] to [I[G2]].

]FIG]
: [[6/15]] :
[FIG(steps)[

= [61] Set [VAR[state]]'s [F[GL invoked]] to [I[G3]].

]FIG]
: [[7/0]] :
[FIG(steps)[

= [62] If [VAR[state]]'s [F[MARC-8 flag]] is [[true]]:
== [63]  
Set [VAR[state]]'s [F[G0 designated]] to [[94 set]] ([I[escape]], [VAR[bc]]).
== [66] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [64] Otherwise:
== [65] Set [VAR[state]]'s [F[decoder state]] to [I[PCD state]].


]FIG]
: [[EOF]] :
@@
: Otherwise :
[FIG(steps)[

= [33] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [34] [[Reconsume][reconsume]] [VAR[bc]].

]FIG]

]FIG]

*** PCD state

[67] The [DFN[PCD state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [68] Set [VAR[state]]'s [F[PCD PM]] to [VAR[bc]].
= [69] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PM state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PM state

[70] The [DFN[PCD PM state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

: [ [N[0/0]], [N[15/15]] ] :
[FIG(steps)[

= [71] Set [VAR[state]]'s [F[PCD PI]] to [VAR[bc]].
= [73] Set [VAR[state]]'s [F[PCD LI]] to [N[0]].
= [72] Set [VAR[state]]'s [F[decoder state]] to [I[PCD PI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD PI state

[74] The [DFN[PCD PI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[10/0]], [[11/1]] ]:
[FIG(steps)[

= [75] Set [VAR[state]]'s [F[PCD LI]] to ([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [77] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@

]FIG]
:[ [[8/13]], [[9/14]] ]:
[FIG(steps)[

= [78] Set [VAR[state]]'s [F[PCD LI]] to 
([VAR[state]]'s [F[PCD LI]] << 5) + ([VAR[bc]] & [N[0b11111]]).
= [79] If [VAR[state]]'s [F[PCD LI]] is greater than the
[[maximum chunk length]]:
==
@@
= [87] Set [VAR[state]]'s [F[PCD data]] to the [[empty byte sequence]].
= [82] If [VAR[state]]'s [F[PCD LI]] is zero:
== [93] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [83] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].
= [84] Otherwise:
== [80] Set [VAR[state]]'s [F[decoder state]] to [I[PCD LI state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** PCD LI state

[81] The [DFN[PCD LI state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [88] [[Append][append to a byte sequence]] [VAR[bc]] to [VAR[state]]'s [F[PCD data]].
= [76] Set [VAR[state]]'s [F[PCD LI]] to [VAR[state]]'s [F[PCD LI]] - 1.
= [85] If [VAR[state]]'s [F[PCD LI]] is zero:
== [92] [[Emit a PCD data][emit a PCD data]]
[VAR[state]]'s [F[PCD PM]],
[VAR[state]]'s [F[PCD PI]],
[VAR[state]]'s [F[PCD data]].
== [86] Set [VAR[state]]'s [F[decoder state]] to [I[initial state]].

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]

*** Foreign state

[50] The [DFN[foreign state]] switches by the [[bit combination]] [VAR[bc]]:

[FIG(switch)[

:[ [[0/0]], [[15/15]] ]:
[FIG(steps)[

= [51] [[Emit a character][emit a character]]
([VAR[unassigned]], [VAR[bc]]).

]FIG]
: [[EOF]] :
@@
: Otherwise :
@@

]FIG]


* Definitions

[14] 
This document depends on the [CITE[Infra Standard]].

[15] 
The terms
[[boolean]],
[[byte]],
[[byte sequence]],
[[length]],
[[tuple]],
[[list]],
[[append]],
[[ordered map]],
[[entry]],
[[key]],
and
[[value]]
are defined by the [CITE[Infra Standard]].

[16] 
A [DFN[bit combination]] is a [[byte]].
A [[bit combination]] is represented as "[VAR[X]]/[VAR[Y]]",
where [VAR[X]] and [VAR[Y]] are integers in [ [N[0]], [N[15]] ],
which represents a [[byte]] [VAR[X]] × [N[16]] + [VAR[Y]].

[89] 
To [DFN[append][append to a byte sequence]] a [[bit combination]] [VAR[bc]]
to a [[byte sequence]] [VAR[bytes]], run these steps:

[FIG(steps)[
= [90] Replace [VAR[bytes]]'s content by [VAR[bytes]] followed by [VAR[bc]].
]FIG]

[91] The [DFN[empty byte sequence]] is a [[byte sequence]] whose [[length]]
is [N[0]].

[18] 
A [DFN[character]] is one of followings:

- [CODE(charname)@en[ESC]]
- [CODE(charname)@en[SP]]
- [CODE(charname)@en[MSP]]
- [CODE(charname)@en[DEL]]
- [[tuple]] ([I[escape]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]
- [[tuple]] ([I[unassigned]], [VAR[bc]]), where [VAR[bc]] is a [[bit combination]]

[17] 
A [DFN[character set]] is an [[ordered map]],
where [[keys][key]] are [[byte sequences][byte sequence]] and
[[values][value]] are a [[character]].

[22] 
A [DFN[C0 set]] is a [[character set]] whose [[keys][key]] are 
«
[[0/0]],
[[0/1]],
...,
[[1/15]]
».

[19] 
The [DFN[initial C0 set]] is a [[C0 set]] 
«[ 
[[0/0]] → ([I[unassigned]], [[0/0]]),
[[0/1]] → ([I[unassigned]], [[0/1]]),
...,
[[1/10]] → ([I[unassigned]], [[1/10]]),
[[1/11]] → [CODE(charname)@en[ESC]],
[[1/12]] → ([I[unassigned]], [[1/12]]),
...,
[[1/15]] → ([I[unassigned]], [[1/15]])
]».

[25] 
The [DFN[empty C0 set]] is a [[C0 set]] 
«[ 
[[0/0]] → ([I[unassigned]], [[0/0]]),
[[0/1]] → ([I[unassigned]], [[0/1]]),
...,
[[1/15]] → ([I[unassigned]], [[1/15]])
]».

[23] 
A [DFN[C1 set]] is a [[character set]] whose [[keys][key]] are
«
[[8/0]],
[[0/1]],
...,
[[9/15]]
».

[24] 
The [DFN[empty C1 set]] is a [[C1 set]] 
«[ 
[[8/0]] → ([I[unassigned]], [[8/0]]),
[[8/1]] → ([I[unassigned]], [[8/1]]),
...,
[[9/15]] → ([I[unassigned]], [[9/15]])
]».

@@
[45] 
A [DFN[G set]] is ...

[46] 
A [DFN[empty 94 set]] is a [[character set]] whose [[keys][key]] are
«[ 
[[2/1]] → ([I[unassigned]], [[2/1]]),
[[2/2]] → ([I[unassigned]], [[2/2]]),
...,
[[7/14]] → ([I[unassigned]], [[7/14]])
]».

[47] [DFN[94 set]] ([VAR[c1]], [VAR[c2]]) is defined by the following table:

[FIG(table)[

:c1:[VAR[c1]]
:c2:[VAR[c2]]
:set:[[94 set]] ([VAR[c1]], [VAR[c2]])
:note:[[Note]] ([[non-normative]])

:c1:[I[escape]]
:c2: [[6/2]]
:note: [[MARC-8]]
:set:
@@

:c1:[I[escape]]
:c2: [[6/7]]
:note: [[MARC-8]]
:set:
@@

:c1:[I[escape]]
:c2: [[7/0]]
:note: [[MARC-8]]
:set:
@@

:c1:[I[escape]]
:c2: [[7/3]]
:note: [[MARC-8]]
:set:
@@ASCII



]FIG]

* Notes

@@macro code