head	1.1;
access;
symbols;
locks; strict;
comment	@# @;
expand	@b@;


1.1
date	2011.01.08.11.45.43;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.1
log
@created by (anon)
@
text
@[1] [CITE[Programming Paradigms and Middleware for Sensor Networks]] を読んだメモ。

* 問題

- センサネットワークのプログラミングは難しい
  - センサノード単位でのプログラミング
  - 低級プログラミング言語
  - OS レベルの抽象化
- そこで必要なものは:
  - センサネットワークでのタスク指定を簡単化するプログラミングの抽象化
  - 上記の抽象化をサポートするミドルウェア
- 本論文で紹介するのは:
  - 抽象化やミドルウェアの設計上の挑戦は?
  - 現在試されている手法は?

* 動機

- 既存ネットワークでの抽象化、ミドルウェア
  - RPC (遠隔手続き呼び出し)、ONC RPC
  - DOM (分散オブジェクトモデル)、CORBA
  - DSM (分散共有メモリ)、MUNIN
- しかし、これらはそのままセンサネットワークに適用できない

** センサネットワーク向け抽象化、ミドルウェアの要件と問題

- プログラミングパラダイム
  - 以下のモデルにより開発可能なプログラミングパラダイム:
    - 高レベルのセンシングタスクの指定
    - センシングタスクに対応する個々のセンサノードの自動プログラミング
    - 個々のセンサデータの高レベルのセンシング結果への結合
  * 理想的には、センサネットワーク全体を仮想的なエンティティと見なせるとよい
  * 抽象化度、表現力、実装効率のトレードオフがある
- 資源制約
  - 軽いミドルウェアコンポーネント
    - 電力、計算能力、メモリ、通信帯域の制約
  - 性能・資源消費のアプリケーション要求への動的な適応
  - システム全体の資源割当の最適化
    - 複数アプリケーション間
- ネットワークダイナミクス
  - ネットワーク変化への適応による頑健な操作のサポート
    - データセントリックな通信はこの点で優れた手段
- スケーラビリティ
  - 自己設定、自己管理能力
    - 大量のノードを手動で管理するのは困難
  * フラッディング等グローバルな操作は使用不可能
- 実世界統合
  - センサネットワーク内での共通の時空間軸の確立
    - 事象の識別、区別、関連付けのために必要
  - 実時間性
    - 多くのアプリケーションで必要
- センサデータの収集・処理
  * source、ネットワーク内での情報処理が必要
    - 各ノードのデータから高レベルのセンシング結果を得るための操作が必要
    - 大量の生データを集めて集中処理するのは困難
  - アプリケーションの知識を指定する手段
  - 知識をネットワーク内のノードに注入する手段
- 背景インフラとの統合
  * 通常センサネットワークは外部装置・インフラと接続されている
    - タスクの指定、センシング結果の評価・蓄積に必要
    - センサネットワークにない資源を提供
      - 計算能力、ストレージなど
  - 背景インフラと統合された homegeneous な視点の提供
  - ミドルウェアの機能の一部だけをセンサノードで実行
    - センサノードの能力が低くて全体を実行できない場合
    - 環境の変化によりセンサノードで実行する部分を変化させられる必要があるかも
- OS とのインターフェイス
  * 従来のミドルウェアは OS の上で動作
  * タスク管理、メモリ管理等で OS は既に抽象化している
  * センサノード上の OS における抽象化は研究中
    - 資源に制約があるため、従来の OS ほどの抽象化ができるか不明
  * OS とミドルウェアの分離を諦め、分散 OS を目指すのも一案

* データベース

- センサネットワークを分散データベースと見なす
- SQL 風の問い合わせを使う
- TinyDB
  - スパニング木を構築する
  - 問い合わせをフラッディングする
  - 子は、問い合わせに対する回答を親に送信する
  - 親は子供達の回答を取りまとめた回答を作り、その親に送信する
  - その繰り返しで根に回答が届く

* モバイルエージェント

- タスクをプログラムとして注入する
- プログラムは:
  - 自ノードにあるデータを集める
  - (状態つきで) 他のノードに移動、または複製を送る
  - 複製と通信する
- SensorWare
  - Tcl + 上記に対応する手続き

* イベント

- イベントが発生するとアプリケーションに通知する
- 基本イベント
  - 実世界の状態の変化に対応する
  - アプリケーションが興味を示すと通知される
- 合成イベント
  - アプリケーションがパターンを示すと通知される
- DSWare
  - 合成イベントは次の要素により指定する:
    - イベント ID
    - 空間的範囲
    - 時間的範囲
    - 信頼度関数
    - 信頼度最小値
    - 基本イベントの集合
  - 合成イベントとして通知するのは:
    - 空間的・時間的な範囲内の基本イベントで、
    - 基本イベントの集合を信頼度関数に与えると最小値以上の値を返すとき
  - 例えば、信頼度関数「温度が急激に上昇」

* 議論

- 3つの手法は、利用のしやすさ、表現力、スケーラビリティ、オーバーヘッドに違いがある
- TinyDB
  - とても利用しやすい
    - 宣言的な問い合わせ
    - 個々のノードは隠されている
  - 表現力は限定的
    - 新しい集積操作の追加は難しく、全ノードのプログラムの修正が必要
    - 複雑なセンシングタスクを記述できるか疑問
      - 例えば時空間的な関係の検出を明示的にサポートできない
  - スケーラビリティに乏しい
    - グローバルな構造を用いる
      - スパニング木
      - 問い合わせのフラッディング
- SensorWare
  - 簡単なタスクも複雑なスクリプトになる
    - 手続き的なプログラミング言語
  - どんなアルゴリズムも実装可能
    - センシングタスク実装のために実行環境を変更する必要はない
  - グローバルな構造は用いない
- DSWare
  - 複雑、柔軟
    - 基本イベントを生成するコードが必要
    - 合成イベントを処理するコードが必要

- TinyDB は簡単だが表現力に限界がある
- SensorWare と DSWare は表現力が高いが単純なことも複雑になる
- 使いやすく表現力があり、かつスケーラブルで電力効率が良いアプリケーションを構築可能なミドルウェアが必要
- 既存のパラダイムから適当な抽象化ができるかはわからない
  - 完全に新しい方法が必要かも

@
