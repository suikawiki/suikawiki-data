head	1.1;
access;
symbols
	suika-20100509:1.1
	before-graph-20090923:1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.1
date	2008.11.20.19.33.31;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.1
log
@converted from SuikaWiki3 <http://suika.fam.cx/gate/cvs/suikawiki/wikidata/page/6D616E616B6169.ns/A5E1A5E2.ns/323030342D30362D3034.txt>
@
text
@#?SuikaWiki/0.9

[1]
文書実体の全処理として、改行の正規化と、
Char, RestrictedChar の検査を実装しました。

改行の正規化のためには XML の版を知っている必要があるので、
最初にすごく大雑把な XML 宣言の検査をすることにしました。

(Charset が不明な時には合計3回も同じ XML 宣言のチェックをすることになりますが・・・。 Charset を上位プロトコルで指定しないのは自業自得ですが、 XML の版は上位プロトコルで指定できないのが普通ですから、どうしようもないですね。)

;; XML 宣言だけ処理してから改行正規化という方法もありましょうが、今の実装方法ではちょいとばかり面倒なことになるので却下。

[2]
その[DEL[ついで]][INS[ため]]に [CODE(perl)[[[Char::Class::XML]]]] に XML 1.1 用の文字級を追加しておきました。

附属書 I の推奨名前文字の分はまた今度。

([[名無しさん]] [WEAK[2004-06-04 08:37:50 +00:00]])


[3]
[[完全正規化]]性の検証について。
([Q[正規化性]]って変な言葉だな。)

3段階に分けられる:
= 全体の (plain text としての) 正規化性
= [[取込み正規化]]性 — 実体境界における正規化性
= [[関連構造]]の正規化性

全体の正規化性は構文解析の前の文に検査するしかない (解析結果の部品を全部検査すれば全体で正規化されてい''ない''ことは分かるが、色々面倒そうだ)。
ただし構文解析のごとに必ずチェックしても仕方がないから、チェックするモードの時だけ原文を持っておいて、 (すぐに、またはあとでまとめて) 正規化性を検査することになろう。

取込み正規化の検査は、
参照の置換文の最初と最後と、参照がある文脈の参照直前・直後を調べればいい。

実際には置換文の最初と参照の直後だけで済む。そこに[[合成文字]]がなければいいわけだ。

関連構造の正規化性は、最初の文字が合成文字かを調べればいい。

ということで、取込み正規化と関連構造は妥当性検証と同じく、構文解析から完全に分離できそう。

([[名無しさん]] [WEAK[2004-06-04 08:56:46 +00:00]])

@
