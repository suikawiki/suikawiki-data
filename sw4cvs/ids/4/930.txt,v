head	1.1;
access;
symbols
	suika-20100509:1.1
	before-graph-20090923:1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.1
date	2008.11.13.21.41.45;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.1
log
@converted from SuikaWiki3 <http://suika.fam.cx/gate/cvs/suikawiki/wikidata/page/B8C7C4EAC9E4B9E6B2BDCAB8BBFA.txt>
@
text
@
- [[DELETE]] (削除) 07/15
- [[ESCAPE]] (エスケープ) 01/11
- [[SPACE]] (スペース) 02/00

[1] [[ISO/IEC 2022]] において、唯三つ固定されている符号化文字です。但し、
そうはいっても、これらの[[符号位置]] ([[ビット組合せ]]) 
が必ずしもこれらの文字を表現するとは限りません。 96/96[SUP[n]] 集合が [[GL]] に[[指示]]・[[呼び出し]]されている時には、 [CODE[02/00]] 及び [CODE[07/15]] は[[図形文字]]を表現する[[ビット組み合わせ]] (ぼ一部) になります。 ([CODE[01/11]] だけは常に[[制御文字]] [CODE[ESCAPE]] を表します。)

[2] >>1 [CODE(char)[[[ESC 2/1 7/14]]]] (空 C0 集合) 
が指示・呼出されている時も [CODE(char)[ESC]] ってつかえるんですかね? (使えないと困るが。)

[6] >>2 ISO/IEC 2022 によると、 [[CL]] になにも指示・呼出しされていない状態でも
[CODE(char)[ESC]] は使えるそうです。それが空集合が呼出された状態と同じ状態であるのなら、
答えは[Q[使える]]になりますね。

[3] 逆に、これらの文字がほかの符号位置に割当てられていることはないのかというと、''ほとんど''ありません。

[4] >>3 どういう時にその前提が崩れるのかというと、[[イラン]]の何とかとか言う[[符号化文字集合]]は不思議なことに、8ビット符号では C0 や [CODE(char)[SPACE]] とかも右側に呼び出されるんです。変でしょ?

[5] >>4 のような使い方が ISO/IEC 2022 に適合するのかは謎ですが、ともかくその符号化文字集合が ISO/IEC 2022 的構造をもっているのだけは事実。


[7]
>>2-3 [[JIS X 0202]]:1998 14.1 で[[空集合]]が規定されていますが、
その規定によれば[[空集合]]が指定されている時は対応する[[ビット組合せ]]を使ってはなりません。
そして[Q[何も[[指示]]・[[呼出]]しされていない状態]]と[Q[[[空集合]]が[[指示]]されている状態]]は
(特に明記されていない以上) 別の状態と考えるのが自然ですから、
[[空集合]]で [CODE(charname)@@en[[[ESCAPE]]]]
は使えないと考えてよいでしょう。
([[名無しさん]] [sage])

@
