head	1.2;
access;
symbols
	suika-20100509:1.1
	before-graph-20090923:1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.2
date	2014.02.24.11.44.58;	author wakaba;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.10.20.30.33;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.2
log
@updated by (anon)
@
text
@[[引数実体参照]]
@


1.1
log
@converted from SuikaWiki3 <http://suika.fam.cx/gate/cvs/suikawiki/wikidata/page/B0FABFF4BCC2C2CEBBB2BEC8.txt>
@
text
@d1 1
a1 210
#?SuikaWiki/0.9

[1] 【[[SGML]]/[[XML]]】 [[DTD]] 中で[[マーク宣言]]やその[[引数]]を値として持つ[[変数]]
(というか[[定数]]) 的に使用される[[実体参照]]。
[[パラメーター実体参照]], [[パラメタ実体参照]]などとも。
Parameter entity reference。

[2] [[規格参照具象構文]]だとして、
[PRE[
<!ENTITY % lt '<'>
<!ENTITY % a "%lt;!ENTITY ent 'entity value'>">
%a;
]PRE]

は適当でしょうか?

[[JISX4151]]‐1992 9.1.4 は、
「[CODE(SGML)[[[ds]]]] としての引数実体参照は、
0個以上の完全なマーク宣言と [CODE(SGML)[ds]]
とからなる実体を参照しなければならない」と述べています。

この例では [SAMP(SGML)[%a;]] も、それに含まれる 
[SAMP(SGML)[%lt;]] も [CODE(SGML)[ds]] 
としての引数実体参照とみなされます。
[SAMP(SGML)[<]] だけからなるマーク宣言は存在しませんから、
この例は'''不正'''です。

[3] それでは
[PRE[
<!ENTITY % q '"'>
<!ENTITY % a "<!ENTITY ent %q;entity value%q;>">
%a;
]PRE]

は適当でしょうか? ちなみに [[MSXML]] では通ってしまいます。

JIS X 4151‐1992 9.1.1 には、
「その参照する実体は、その参照が現れた [CODE(SGML)[ps]]
の直後に続ける0個以上の完全な引数の列からなっていなければならない」
としています。[SAMP(SGML)["]] だけの実体が「完全な引数」
でないことは明らかですから、この例は'''不正'''です。

実はこの例は次のように書くのと同じことです。
[PRE[
<!ENTITY % q '"'>
<!ENTITY ent %q;entity value%q;>
]PRE]

こちらの例を見れば、「完全な引数」になっていないことはますます自明です。
[[実体値指定]]内の引数実体参照は宣言時ではなくそれを含む引数実体が参照された時に評価されることを思い出して下さい。

[4] 
[PRE[
<!ENTITY % e1 "'Q&#x26;#x26;#x26;A'">
<!ENTITY e2 %e1;>
]PRE]

後者の[[実体宣言]]の解釈を試みる。名前 [CODE(SGML)[e2]]
と、その直後の [CODE(SGML)[ps]] である [CODE(SGML)[s]]
である文字 [CODE(char)[[[SP]]]] まで読んだ。
ここで、引数実体参照 [SAMP(SGML)[%e1;]] を発見する。
この引数実体参照も、 [CODE(SGML)[ps]] として評価される。

引数実体 [SAMP(SGML)[e1]] の値を得るが、その[[引数表記]]は
[SAMP(SGML)["'Q&#x26;#x26;#x26;A'"]] である。
引数表記は両端が [CODE(SGML)[[[lit]]]] 又は
[CODE(SGML)[[[lita]]]] だが、ここでは前者である。
その間の部分は[[置換可能引数データ]]である。

置換可能引数データでは、[[文字参照]]と引数実体参照が解釈される。
[WEAK[XML では、構文上文字参照でも一般実体参照でもない文字 [CODE(XML)[&]] を書くことが出来ないが、そうだとしても一般実体参照はまだ認知されない・・・のかなあ。よくわからない。]]
従って、参照を置換した結果 [SAMP(SGML)['Q&#x26;#x26;A']] 
を得る。

結局、先の後者の実体宣言は 
[SAMP(SGML)[<!ENTITY e2 'Q&#x26;#x26;A'>]]
と書かれていたことになる。

同様の解釈 [WEAK[(さっきのよりずっと簡単。)]]
により、 [SAMP(SGML)[e2]] の[[置換文]]は
[SAMP(SGML)[Q&#x26;A]] であるとわかる。

文書実現値中で [SAMP(SGML)[&e2;]] と参照すると、
今度はその参照の位置で数値文字参照 [SAMP(SGML)[&#x26;]]
が評価され、結局その参照は[[文字データ]] [SAMP[Q&A]]
となる。

[5]
[PRE[
<!ENTITY % e1 "'Q&#x26;#x26;#x26;A'">
<!ENTITY % e2.5 "%e1;">
<!ENTITY e2 %e2.5;>
]PRE]

>>4 の例と大差がないように思えるこの例で、 [SAMP(SGML)[e2]]
の置換文を求める。

前例と同様の手順により、 [SAMP(SGML)[e2]] の解釈に必要な
[SAMP(SGML)[e2.5]] の置換文を求めることとなった。
[SAMP(SGML)[e2.5]] の引数表記の中身は引数実体参照
[SAMP(SGML)[%e1;]] である。前例同様、 [SAMP(SGML)[e1]]
の置換文は [SAMP(SGML)['Q&#x26;#x26;A']] である。
従って、 [SAMP(SGML)[<!ENTITY % e2.5 "'Q&#x26;#x26;A'">]]
と記述されていたとみなせる。

ここで、数値文字参照 [SAMP(SGML)[&#x26;#x26;]]
がまた評価され、置換文は [SAMP(SGML)['Q&#x26;A']] となる。
結局 [SAMP(SGML)[<!ENTITY e2 'Q&#x26;A'>]]
となり、文書実現値中で参照したときの置換文は
[SAMP(SGML)[Q&A]] となる。 
[WEAK[XML では、[[整形式]]エラーとなる。]]

・・・と思うのだが、試しに [[MSXML]] で読ませてみると、
[SAMP(SGML)[e2]] の実体宣言でえらーが出る。
「この場所ではスペースが許可されません」ハァ?

この解釈が間違っているのでしょうか?

([SAMP(XML)[<!ENTITY e2 '%e2.5;'>]] と宣言すれば、
なんとなく意図したようにはなります。)

[6]
[PRE[
<!ENTITY % AMP0 '&#x26;#x26;#x26;'>
<!ENTITY AMP0 '&#x26;#x26;#x26;'>
<!ENTITY AMPp "%AMP0;">
<!ENTITY AMP "&AMP0;">
]PRE]

文書実現値で [SAMP(SGML)[&AMP;]] と [SAMP(SGML)[&AMPp;]]
と参照することを考えます。

まず [SAMP(SGML)[&AMP;]] からです。その引数指定は一般実体
[SAMP(SGML)[AMP0]] への参照があるのですが、
実体宣言の段階ではまだ認知されていません。
一般実体 [SAMP(SGML)[AMP]] の置換文はそのまま 
[SAMP(SGML)[&AMP0;]] で、これが文書実現値中の参照の場所で評価されます。

一般実体・引数実体ともに、 [SAMP(SGML)[AMP0]]
の置換文は [SAMP(SGML)[&#x26;#x26;]] です。
[WEAK[(両実体の宣言の引数指定の解釈で1つずつ減ってます。)]]

一般実体 [SAMP(SGML)[AMP0]] を文書実現値中で評価した結果、
得られる文字データは [SAMP(SGML)[&#x26;]] となります。

さて、 [SAMP(SGML)[&AMPp;]] の場合です。
こちらは、一般実体 [SAMP(SGML)[AMPp]] の''実体宣言の時点で''、
その引数指定内の引数実体 [SAMP(SGML)[AMP0]] 
への参照が評価されているため、 [SAMP(SGML)[AMPp]]
の宣言は [SAMP(SGML)[<!ENTITY AMPp "&#x26;#x26;">]]
と同じことです。

また引数指定ですから、置換文は [SAMP(SGML)[&#x26;]]
になります。

これが文書実現値中で評価される時、得られる文字データは
[SAMP(SGML)[&]] になります。

[7] 頭の体操のような様相を呈してきました。。。
- [8] >>3 解釈の順序を考えれば二つの例は同等ではないです。
- [9] [CODE(ABNF)[[DFN[引数実体参照]] := [CODE(SGML)[[[pero]]]] [[文書型指定]] [[名前]] [[参照終了]] ;; (60)]]

[10] >>3 の「実体値指定内の引数実体参照は宣言時ではなくそれを含む引数実体が参照された時に評価される」というのは、何かの勘違いではないでしょうか。

[[実体文]](実体値指定)が[[引数表記]]([[実体値]])で記述されている場合、表記の中の引数実体参照は単に[[置換可能引数データ]]の文脈で解釈されます(JISX4151‐1992 表3, XML 4.4.5)。

従って、>>6 の例と同様、>>2 や >>3 の例での [SAMP(SGML)[%lt;]] や [SAMP(SGML)[%q;]] は [SAMP(SGML)[a]] の実体宣言の際に展開されてしまうので、[CODE(SGML)[ds]] や [CODE(SGML)[ps]] として認知されることはありません。結局、[SAMP(SGML)[%a;]] はどちらの例でも正当な [CODE(SGML)[ds]] として解釈され、一般実体 [SAMP(SGML)[ent]] が正しく宣言されたものと見なされます。
- [11] ''"WFC: In DTD" の意味 - XML Core 関連'' <http://www.satoshii.org/markup/xml/wfc-indtd>

[12]
XML では、[[内部部分集合]]の[[マーク宣言]]の内部に引数実体参照を入れることができません。
引数実体参照が使えるのは他のマーク宣言ど同位のところ (「地」の部分)
だけです。
([[整形式制約]] PEs in Internal Subset)

[[外部引数実体]]や[[外部部分集合実体]]ではこの制限はなく、
マーク宣言内に書くことができます。

ということは、内部部分集合で参照されている[[内部引数実体]]の中でも使えないということです。
[[条件区間]]と同じですね。

([[名無しさん]])

[13]
>>11 の文書は以前から気になっていた整形式制約 In DTD
のことを説明してくれています。

そこでは [[CDATA区間]]のためだろうという結論になっていますが、
それでも、 XML の構文では文字データ区間に引数実体参照が使える余地はありません。
ですから整形式制約として敢えて立てる必要性の説明にはならないと思います。
(本当はやはり不要で、歴史的なものではないかとにらんでいます。)

関係ありませんが、 SGML でも、
構文的には[[文書型宣言]]などで引数実体参照が認められながら、
本文でそれを取消す形になっています。
これはおそらく[[マーク宣言]]の[[空白]]にはすべて
[CODE(SGML)[[[ps]]]] を使いたかったからでしょう。

([[名無しさん]])


[14]
>>13 意表をついて、 [Q[DTD の中では使ってもいいよ]]という[Q[制約]]ではないかと思ったりしましたが、こういう解釈って駄目ですか?

XML の整形式・妥当性制約ってのは EBNF の生成規則で表現できないことを記述しているではないですか。で、マーク宣言内の引数実体参照もうまく表現できていないから・・・。

でももし本当にこういう意味だとしたら、
説明がよくなさすぎる。
([[名無しさん]] [WEAK[2004-06-06 03:27:37 +00:00]])

@

