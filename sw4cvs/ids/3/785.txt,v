head	1.1;
access;
symbols
	suika-20100509:1.1
	before-graph-20090923:1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.1
date	2008.11.13.06.56.57;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.1
log
@converted from SuikaWiki3 <http://suika.fam.cx/gate/cvs/suikawiki/wikidata/page/37A5D3A5C3A5C8C9E4B9E6A4C838A5D3A5C3A5C8C9E4B9E6A4CECAD1B4B9.txt>
@
text
@
*8ビット符号から7ビット符号へ
-[[最上位ビット]]が 0 の時はそのままで OK
-[[CR]] → ESC Fe
-[[GR]] → [[GL]], 適切なシフト機能。
-単独シフト + [[GR]] → 単独シフト + [[GL]]

([[ISO/IEC2022]] 1994 11)

*7ビット符号から8ビット符号へ
-最上位ビットを 0 にし、残り7ビットはそのままで OK
-必要なら8ビット符号→7ビット符号の逆の操作をしてもよい(may)

8ビット符号から変換された7ビット符号の時は、 LS1R,
LS2R, LS3R が出現するかもしれないから、それを復元する
必要があるかも(may)。

([[ISO/IEC2022]] 1994 11)

*変換に関係する例外的規定

[[ISO/IEC2022]] 系の7ビット符号と8ビット符号は、
両者間の変換の便宜のために、ちょいと困った例外規定があります。

次の場所は本来左を使いますが、8ビット符号では右を使っても構いません。
([[ISO/IEC6429]] 9)

-[[制御列]]の P,I,F バイト
-[[制御文字列]]の命令列または文字列
-単独シフト制御機能の対象

(かつて [[EUC]] はこの規定を根拠に SS2, SS3 の後で [[GR]]
を使っていました。(と解釈されていました。) これは後の [[ISO/IEC2022]]
の改訂で例外扱いでは無しに、 SS + GR を使えることになりました。)

7ビット符号では次のところに SI や SO が来ても構いません。 ([[ISO/IEC6429]] 9)

-制御列の CSI と終端バイトの間
-制御文字列の開始区切子と ST の間
-単独シフト制御機能と対象の間

(制御文字列では元々 00/14 と 00/15 は使えると思うんですが...
それと区別する必要があるんですかね? (あるとしても無理だが。))

7ビット符号では次のところに [[GL]] が来ても構いません。
([[ISO/IEC2022]] 1994 11)

-LS1R, LS2R, LS3R と次の固定シフトの間

これらの規定が設けられたのは、おそらく古い ISO/IEC 2022
の規定に従って設計された7ビット←→8ビット変換器を[[CCデータ要素]]
が通過した時に、新しい ISO/IEC 2022 の機能を使っていても
最終的に新しい ISO/IEC 2022 の受信装置が理解出来るように、
ということだと思われます。

ところで、 SI や SO って [[C0]] 制御文字集合に何を使うかによって
符号位置が変化する(可能性がある)んじゃないですか... めんどいなぁ。
- [1] この規定のせいで、7単位符号と8単位符号では[[受信装置]]側の処理が少し違ってきてしまいます。これが困った点です。
- [2] [[SI]]/[[SO]] は登録されている[[C0文字集合]]では同じ[[符号位置]]ですね。これは仮定してもいいかもしれません。 (変なC0集合作る人なんていないでしょ。) ただし、 SI/SO が存在''しない'' C0 集合は''ある''ので注意です。
@
