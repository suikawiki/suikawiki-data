head	1.3;
access;
symbols
	suikawiki3-final:1.3
	before-db-leaffile:1.3
	after-upgrade-to-suikawiki-3:1.3
	before-fork-suikawiki3:1.3
	after-restore-20040122:1.3;
locks; strict;
comment	@# @;


1.3
date	2002.11.09.06.25.05;	author wakaba;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.17.10.24.06;	author wakaba;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.16.14.24.02;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated.
@
text
@
*8ビット符号から7ビット符号へ
-[[最上位ビット]]が 0 の時はそのままで OK
-[[CR]] → ESC Fe
-[[GR]] → [[GL]], 適切なシフト機能。
-単独シフト + [[GR]] → 単独シフト + [[GL]]

([[ISO/IEC2022]] 1994 11)

*7ビット符号から8ビット符号へ
-最上位ビットを 0 にし、残り7ビットはそのままで OK
-必要なら8ビット符号→7ビット符号の逆の操作をしてもよい(may)

8ビット符号から変換された7ビット符号の時は、 LS1R,
LS2R, LS3R が出現するかもしれないから、それを復元する
必要があるかも(may)。

([[ISO/IEC2022]] 1994 11)

*変換に関係する例外的規定

[[ISO/IEC2022]] 系の7ビット符号と8ビット符号は、
両者間の変換の便宜のために、ちょいと困った例外規定があります。

次の場所は本来左を使いますが、8ビット符号では右を使っても構いません。
([[ISO/IEC6429]] 9)

-[[制御列]]の P,I,F バイト
-[[制御文字列]]の命令列または文字列
-単独シフト制御機能の対象

(かつて [[EUC]] はこの規定を根拠に SS2, SS3 の後で [[GR]]
を使っていました。(と解釈されていました。) これは後の [[ISO/IEC2022]]
の改訂で例外扱いでは無しに、 SS + GR を使えることになりました。)

7ビット符号では次のところに SI や SO が来ても構いません。 ([[ISO/IEC6429]] 9)

-制御列の CSI と終端バイトの間
-制御文字列の開始区切子と ST の間
-単独シフト制御機能と対象の間

(制御文字列では元々 00/14 と 00/15 は使えると思うんですが...
それと区別する必要があるんですかね? (あるとしても無理だが。))

7ビット符号では次のところに [[GL]] が来ても構いません。
([[ISO/IEC2022]] 1994 11)

-LS1R, LS2R, LS3R と次の固定シフトの間

これらの規定が設けられたのは、おそらく古い ISO/IEC 2022
の規定に従って設計された7ビット←→8ビット変換器を[[CCデータ要素]]
が通過した時に、新しい ISO/IEC 2022 の機能を使っていても
最終的に新しい ISO/IEC 2022 の受信装置が理解出来るように、
ということだと思われます。

ところで、 SI や SO って [[C0]] 制御文字集合に何を使うかによって
符号位置が変化する(可能性がある)んじゃないですか... めんどいなぁ。
- [1] この規定のせいで、7単位符号と8単位符号では[[受信装置]]側の処理が少し違ってきてしまいます。これが困った点です。
- [2] [[SI]]/[[SO]] は登録されている[[C0文字集合]]では同じ[[符号位置]]ですね。これは仮定してもいいかもしれません。 (変なC0集合作る人なんていないでしょ。) ただし、 SI/SO が存在''しない'' C0 集合は''ある''ので注意です。
@


1.2
log
@Updated.
@
text
@d58 2
@


1.1
log
@Updated.
@
text
@a0 1
[[ISO/IEC2022]] (1994 11)
d7 3
d17 41
@

