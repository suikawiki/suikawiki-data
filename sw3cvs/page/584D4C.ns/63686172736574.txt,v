head	1.3;
access;
symbols
	suikawiki3-final:1.3
	before-db-leaffile:1.1
	after-upgrade-to-suikawiki-3:1.1
	before-fork-suikawiki3:1.1
	after-restore-20040122:1.1;
locks; strict;
comment	@# @;


1.3
date	2006.04.13.02.17.20;	author wakaba;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.02.06.15;	author wakaba;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.28.10.15.07;	author make;	state Exp;
branches;
next	;


desc
@@


1.3
log
@auto-committed
@
text
@
[1] [[XML]] と[[文字コード]]の関係について。

ここで特に扱うのは、[[文書文字集合]]や[[文字符号化方式]]についての話題です。
XML と [[URI]] と文字の関係については [[XML]] 参照。
改行や空白については [[XML//空白]]を参照。
[[数値文字参照]], [[名前文字]]についてはそれぞれの WikiPage を参照。

[2] XML 仕様書で関係する部分は、
''Extensible Markup Language (XML) 1.0 4.3.3 Character Encoding in Entities'' <http://www.w3.org/TR/REC-xml#charencoding>,
''Extensible Markup Language (XML) 1.0 F Autodetection of Character Encodings (Non-Normative)'' <http://www.w3.org/TR/REC-xml#sec-guessing>
辺り。[WEAK[ちなみに、附属書 F は [[FE]] errata <http://www.w3.org/XML/xml-19980210-errata> で全面的に書き換えられています。]]
あんまり役に立つことは書いてないけど、重要な [WEAK[(はずの)]]
文献として、 [[RFC2376]] (旧版)/[[RFC3023]] (新版) も参照。

[3] '''XML 実体の符号化方式''': XML の[[実体]]には、
任意の[[文字符号化方式]]を使うことができます。

但し、あくまで文書文字集合は [[UCS]]
で変化しません。ですからどんな[[文字コード]]を使ったとしても、
それが UCS とは定義が互換で無い場合にその文字コード本来の使い方と異なるものを使うことになります。
[WEAK[(例えば、 [[ISO-2022-JP]] を使うとしても、それは本来の [[RFC1468]]/[[JISX0208]]:1997 の定義する ISO-2022-JP ではなく、 UCS を ISO-2022-JP ''風''に表現したものでしかありません。ですから [[JIS]] の定義通りに「高」という文字を [CODE[{[[口高]]又は[[梯子高]]又は...}]] として使っているつもりでも、 [CODE[{口高}]] として解釈されてしまいます。 [WEAK[(もっとも、そんなことを一々気にする人はほとんどいません。その辺の概念・理解・規格・実装は XML 近辺に限らずぐちゃぐちゃなので、気にしていられません。)]])]]

[4] '''実装必須符号化方式''': 全ての [[XML処理系]]は、
[[UTF-8]] 及び [[UTF-16]] に対応しなければなりません。

ここで、 UTF-8 は [[BOM]] があってもなくても構いません。
UTF-16 は BOM が'''なければなりません'''。
[WEAK[なお、 BOM は符号化署名であって[[マーク]]や[[文字データ]]の一部ではありません。]]


* 符号化宣言

[5] [[外部実体]]の先頭には、
(そして丁度先頭に限って、) [[XML宣言]]あるいは[[文宣言]]を書くことができます。
(後述の通り、場合によっては書かなければなりません。)

XML 宣言/文宣言には[DFN[[[符号化宣言]]]] (擬似属性)
があって、使用している符号化方式を指定できます。
(文宣言では必須。 XML 宣言でも場合によっては書かなければなりません。)
- [80]    	EncodingDecl 	   ::=    	S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )
- [81]    	EncName 	   ::=    	[A-Za-z] ([A-Za-z0-9._] | '-')*

[WEAK[ [[IANA]] の charset 名より [CODE(XML)[EncName]] の方が制限されていることに注意して下さい。従って、全ての IANA 名が使えるわけではありません。 ]]
ここで、 [CODE(XML)[EncName]] に指定する値については、
WikiPage [[charset]] で取り扱っています。そちらをご参照下さい。

[83] この符号化宣言はもちろんそこに書かれた符号化方式で書かれています。
あれですよ、鍵がかかった箱の中に鍵があるって奴。
[[密室]]ですね。

実際には使われうる符号化方式は大体決まっていて、
想像できるので、ある程度は使い物になるのですが...
[[HTML]] の [[http-equiv]] hack と同じように、
役に立つこともあるかもしれないけどあんまり当てにならないものです。
それをあてにしろとは、 XML 天晴れですね。

[84] [[MIME]] とか [[HTTP]] とかの上位プロトコルで符号化方式を指定可能な時には、
''絶対に''そちらを使ってきちんと指定するべきです。
その方が確実です。処理系も[WEAK[まともに作ってあれば]]無駄な走査をする手間が省けます。

それなのに、世の中には上位プロトコルにも同じ情報があるのは無駄だ、
XML 側の宣言で統一しろよ XML 慢性! とか言ってる幸せな人達もいます。
(実は [[US-ASCII]] で十分☆とか言ってる人が多いんですが、
なんとそれだけにも限りません。)
困ったもんです。もっとも、符号化方式を明示しないといけないようになった分少しは進歩したと褒めてあげてもいいでしょうかね(w

[85] なお、 >>82 の手順を見れば分かりますが、
上位プロトコルと符号化宣言で食い違っている場合は上位プロトコルが優先されます。
(望ましいことではありませんが、[[誤り]]ではありません。
上位プロトコルで[[関門]]を通過時に変換されたとかの場合に起こりえます。)

[[#comment]]


* 符号化方式の決定

[82] XML の符号化方式の決定には、次の手順を経ます。

= 上位プロトコル (転送プロトコルやファイル・システムなど) が符号化方式についての情報を提供しているか調べる。提供しないないか、そもそも上位プロトコルが存在しないなら、この手順は飛ばす。
-- [[MIME]] や [[HTTP]] などでは、媒体型の指定で [[charsetパラメーター]]が指定されているか否か。
=== 指定されていれば、その値を採用。
=== 指定されていなくて、それに既定値があれば、それを採用。
---- [CODE[[[text/xml]]]] などでは、 MIME でも HTTP でも既定値は [CODE(charset)[US-ASCII]]。 [RFC 3023]
= XML 実体の先頭部分を読み込む。
== 先頭っぽい部分が XML 宣言又は文宣言なら、符号化宣言があるか調べる。
--- 調べるに当たって、符号化方式にあたりを付ける必要があります (>>83)。そのヒントは XML 仕様書の附属書 F に載ってます。
=== 符号化宣言があれば、その値を採用。
---- なお、ここに該当する場合には符号化宣言が必須になります。
=== 符号化宣言がなければ、 UTF-8 である。
== 正確に先頭が [CODE[0xFEFF]] なら、それは[[大エンディアン]]の UTF-16 である。
== 正確に先頭が [CODE[0xFFFE]] なら、それは[[小エンディアン]]の UTF-16 である。
== (正確に先頭が [CODE[0xEFBBBF]] なら、それは UTF-8 である。)
--- なお、以上3種は全ての XML 処理系が扱えなければならない。
= 以上で決定できなければ、それは UTF-8 である。
-- 仕様書では UTF-8 ではなくて、
しかも以上で決定できないなら[[致命的誤り]]であるとしていますが、
実際の処理ではそれはあり得ません。
(既定値 UTF-8 に決定してしまうから。)

[83] なお、以上で目出度く決定できても、
それが間違っている可能性やそれを扱えない場合もあります。
- その符号化方式を扱うことが出来ないなら、致命的誤りとする。
- その符号化方式であり得ない[[ビット組合せ]]が出現したら、致命的誤りとする。

[86]
dddd
([[Mr.Anonymous]] [WEAK[2004-06-11 17:51:25 +00:00]])

[[#comment]]


* 文書文字集合的なことについて

[INS[

書く。
]INS]

[[#comment]]


* メモ

[87]

> It is a fatal error if an XML entity is determined (via default, encoding declaration, or higher-level protocol) to be in a certain encoding but contains byte sequences that are not legal in that encoding. Specifically, it is a fatal error if an entity encoded in UTF-8 contains any irregular code unit sequences, as defined in Unicode [Unicode].

ここで、[Q@@en[byte sequences that are not legal in that encoding]]とはなにをもってそう判断するのでしょうか。

- その符号化方式の構造上存在し得ないバイト列が出現した場合

が該当することは後段より明らかですが、

- 符号構造上は正当ながら、文字が割り当てられていない符号位置を表すバイト列が出現した場合
- 冗長ながら必要なものが欠落している場合
- [[Unicode]]に対応するものがない場合

はどうなるのでしょうか。

2つ目は[[BOM]] (XMLで規定されている[[UTF-16]]を除く、[[BOM]]が必須の[[符号化方式]]の場合) や[[ISO-2022-KR]]の[[指示シーケンス]]のような場合で、欠落以後のすべてのバイト列が不正と考えるのなら該当することになります。

1つ目は、[Q@@en[This code point shall not be used]]なら不正といえるでしょうが、[[ISO/IEC 10646]]のように頻繁に追加が行われているとあるとき未割当でも近い将来そうでなくなる可能性があるので、致命的誤りにするのはいかがなものかとも思えます。[Q[保留]]とされていて禁止とされていない場合は不正といえるか微妙なところです。

3つ目は、[[Unicode]]の[[符号化方式]]としての既存の[[符号化方式]]において[[Unicode]]に対応しない[[文字]]を表すバイト列は使用され得ないという意味で不正なバイト列と取れなくもないですが、もともとの[[符号化文字集合]]としては不正ではなく、すっきりしません。
[[Unicode]]の[[私用域]]に対応させる変換表を作ることはできますが、
もとの[[符号化文字集合]]で[[Unicode]]の[[文字]]と対応しないような定義がなされていた場合、そのような変換表は別の[[符号化方式]]といわざるを得ません。
([[名無しさん]])

[88]
[[RFC 1468符号化表現]]で最後が[[IRV]]状態でない場合、
というのはどうなのでしょう? 最後の[[指示シーケンス]]以降がすべて不正なバイト列とでも考えるのでしょうか?
([[名無しさん]])

[89]
[[XML]]の[[UTF-16]]は[[BOM]]必須 ('''[[MUST]]''')
ですが、これへの違反は不正なバイト列としてよいのでしょうか。

;; よければ[[致命的誤り]]、そうでなければ[[誤り]]



([[名無しさん]])

@


1.2
log
@auto-committed
@
text
@a0 1
#?SuikaWiki/0.9
a105 1

a109 1

d123 42
a164 1
* メモ@


1.1
log
@auto-commited
@
text
@d1 126
a126 112
#?SuikaWiki/0.9
[1] [[XML]] と[[文字コード]]の関係について。

ここで特に扱うのは、[[文書文字集合]]や[[文字符号化方式]]についての話題です。
XML と [[URI]] と文字の関係については [[XML]] 参照。
改行や空白については [[XML//空白]]を参照。
[[数値文字参照]], [[名前文字]]についてはそれぞれの WikiPage を参照。

[2] XML 仕様書で関係する部分は、
''Extensible Markup Language (XML) 1.0 4.3.3 Character Encoding in Entities'' <http://www.w3.org/TR/REC-xml#charencoding>,
''Extensible Markup Language (XML) 1.0 F Autodetection of Character Encodings (Non-Normative)'' <http://www.w3.org/TR/REC-xml#sec-guessing>
辺り。[WEAK[ちなみに、附属書 F は [[FE]] errata <http://www.w3.org/XML/xml-19980210-errata> で全面的に書き換えられています。]]
あんまり役に立つことは書いてないけど、重要な [WEAK[(はずの)]]
文献として、 [[RFC2376]] (旧版)/[[RFC3023]] (新版) も参照。

[3] '''XML 実体の符号化方式''': XML の[[実体]]には、
任意の[[文字符号化方式]]を使うことができます。

但し、あくまで文書文字集合は [[UCS]]
で変化しません。ですからどんな[[文字コード]]を使ったとしても、
それが UCS とは定義が互換で無い場合にその文字コード本来の使い方と異なるものを使うことになります。
[WEAK[(例えば、 [[ISO-2022-JP]] を使うとしても、それは本来の [[RFC1468]]/[[JISX0208]]:1997 の定義する ISO-2022-JP ではなく、 UCS を ISO-2022-JP ''風''に表現したものでしかありません。ですから [[JIS]] の定義通りに「高」という文字を [CODE[{[[口高]]又は[[梯子高]]又は...}]] として使っているつもりでも、 [CODE[{口高}]] として解釈されてしまいます。 [WEAK[(もっとも、そんなことを一々気にする人はほとんどいません。その辺の概念・理解・規格・実装は XML 近辺に限らずぐちゃぐちゃなので、気にしていられません。)]])]]

[4] '''実装必須符号化方式''': 全ての [[XML処理系]]は、
[[UTF-8]] 及び [[UTF-16]] に対応しなければなりません。

ここで、 UTF-8 は [[BOM]] があってもなくても構いません。
UTF-16 は BOM が'''なければなりません'''。
[WEAK[なお、 BOM は符号化署名であって[[マーク]]や[[文字データ]]の一部ではありません。]]

*符号化宣言

[5] [[外部実体]]の先頭には、
(そして丁度先頭に限って、) [[XML宣言]]あるいは[[文宣言]]を書くことができます。
(後述の通り、場合によっては書かなければなりません。)

XML 宣言/文宣言には[DFN[[[符号化宣言]]]] (擬似属性)
があって、使用している符号化方式を指定できます。
(文宣言では必須。 XML 宣言でも場合によっては書かなければなりません。)
-[80]    	EncodingDecl 	   ::=    	S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )
-[81]    	EncName 	   ::=    	[A-Za-z] ([A-Za-z0-9._] | '-')*

[WEAK[ [[IANA]] の charset 名より [CODE(XML)[EncName]] の方が制限されていることに注意して下さい。従って、全ての IANA 名が使えるわけではありません。 ]]
ここで、 [CODE(XML)[EncName]] に指定する値については、
WikiPage [[charset]] で取り扱っています。そちらをご参照下さい。

[83] この符号化宣言はもちろんそこに書かれた符号化方式で書かれています。
あれですよ、鍵がかかった箱の中に鍵があるって奴。
[[密室]]ですね。

実際には使われうる符号化方式は大体決まっていて、
想像できるので、ある程度は使い物になるのですが...
[[HTML]] の [[http-equiv]] hack と同じように、
役に立つこともあるかもしれないけどあんまり当てにならないものです。
それをあてにしろとは、 XML 天晴れですね。

[84] [[MIME]] とか [[HTTP]] とかの上位プロトコルで符号化方式を指定可能な時には、
''絶対に''そちらを使ってきちんと指定するべきです。
その方が確実です。処理系も[WEAK[まともに作ってあれば]]無駄な走査をする手間が省けます。

それなのに、世の中には上位プロトコルにも同じ情報があるのは無駄だ、
XML 側の宣言で統一しろよ XML 慢性! とか言ってる幸せな人達もいます。
(実は [[US-ASCII]] で十分☆とか言ってる人が多いんですが、
なんとそれだけにも限りません。)
困ったもんです。もっとも、符号化方式を明示しないといけないようになった分少しは進歩したと褒めてあげてもいいでしょうかね(w

[85] なお、 >>82 の手順を見れば分かりますが、
上位プロトコルと符号化宣言で食い違っている場合は上位プロトコルが優先されます。
(望ましいことではありませんが、[[誤り]]ではありません。
上位プロトコルで[[関門]]を通過時に変換されたとかの場合に起こりえます。)

[[#comment]]

* 符号化方式の決定

[82] XML の符号化方式の決定には、次の手順を経ます。

= 上位プロトコル (転送プロトコルやファイル・システムなど) が符号化方式についての情報を提供しているか調べる。提供しないないか、そもそも上位プロトコルが存在しないなら、この手順は飛ばす。
=- [[MIME]] や [[HTTP]] などでは、媒体型の指定で [[charsetパラメーター]]が指定されているか否か。
=-= 指定されていれば、その値を採用。
=-= 指定されていなくて、それに既定値があれば、それを採用。
=-=- [CODE[[[text/xml]]]] などでは、 MIME でも HTTP でも既定値は [CODE(charset)[US-ASCII]]。 [RFC 3023]
= XML 実体の先頭部分を読み込む。
== 先頭っぽい部分が XML 宣言又は文宣言なら、符号化宣言があるか調べる。
==- 調べるに当たって、符号化方式にあたりを付ける必要があります (>>83)。そのヒントは XML 仕様書の附属書 F に載ってます。
=== 符号化宣言があれば、その値を採用。
===- なお、ここに該当する場合には符号化宣言が必須になります。
=== 符号化宣言がなければ、 UTF-8 である。
== 正確に先頭が [CODE[0xFEFF]] なら、それは[[大エンディアン]]の UTF-16 である。
== 正確に先頭が [CODE[0xFFFE]] なら、それは[[小エンディアン]]の UTF-16 である。
== (正確に先頭が [CODE[0xEFBBBF]] なら、それは UTF-8 である。)
==- なお、以上3種は全ての XML 処理系が扱えなければならない。
= 以上で決定できなければ、それは UTF-8 である。
=- 仕様書では UTF-8 ではなくて、
しかも以上で決定できないなら[[致命的誤り]]であるとしていますが、
実際の処理ではそれはあり得ません。
(既定値 UTF-8 に決定してしまうから。)

[83] なお、以上で目出度く決定できても、
それが間違っている可能性やそれを扱えない場合もあります。
- その符号化方式を扱うことが出来ないなら、致命的誤りとする。
- その符号化方式であり得ない[[ビット組合せ]]が出現したら、致命的誤りとする。

[[#comment]]

* 文書文字集合的なことについて
[INS[
書く。
]INS]
[[#comment]]
*メモ

@

