head	1.4;
access;
symbols
	suikawiki3-final:1.4
	before-db-leaffile:1.1
	after-upgrade-to-suikawiki-3:1.1
	before-fork-suikawiki3:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2006.02.18.02.17.09;	author wakaba;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.13.02.13.13;	author wakaba;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.13.02.09.21;	author wakaba;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.13.03.27.27;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.4
log
@auto-committed
@
text
@
[4] [DFN[[RUBYB[実体値] [entity value]]]]は、
[[実体宣言]]の中の[[引数表記]]です。
([[SGML]] ではなく [[XML]] の用語です。
SGML の[[実体文]]の一種です。)

- [3] [CODE(ABNF)[[DFN[[RUBYB[実体値] [EntityValue]]]] := "'" *(<[^'%&]> / [[実体参照]] / [[文字参照]]) "'" / <"> *(<[^"%&]> / 引数実体参照 / 実体参照 / 文字参照) <"> ;; XML 1.0/1.1 [9] 改]]

仕様書: 
- [XML 1.0] <http://www.w3.org/TR/REC-xml/#NT-EntityValue>
- [XML 1.1] <http://www.w3.org/TR/xml11/#NT-EntityValue>

[5]
[[一般実体]]を宣言する[[実体宣言]]の[CODE(ABNF)[実体値]]で生の
[CODE[<]] を使っても、その実体を[[参照]]しようとすると [[XML]]
ではどの場面であっても[[整形式]]とはならないので、
XML 仕様書は使用しないように強くすすめています。

[6] [[内部実体]]の[[表記実体値]]は[[実体値]]と同じものです。

内部実体の[[置換文]]は、表記実体値の内容を、
[[引数実体参照]]と文字参照を解決したものです。

[[#comment]]


* 実体値についての MSXML の挙動

[1] 

> なぜ実際に amp や lt を参照したわけでもないのにエラーになったのか、ということ。「ライン 1、位置 2」という表示もしっくりこないものがありますし、もしかすると MSXML は内部的に何らかの XML を利用していて、その中で amp への参照が現れてエラーになったのかなぁ…などと思ったり。

([[マーク付けノート]] ― M12N のバグと MSXML <http://www.satoshii.org/markup/notes/2004/02#date23-3>)

という話が気になったので、 [[MSXML]]
の挙動を調べてみました。
環境は [[WinXP]] + [[WinIE]] 6.0
です。

WinIE に XML 文書を与えると、
= [[前書き]]を構文解析
= [[一般実体]]の実体値を[[内容]]として構文解析
= [[文書実現値]]以降を構文解析

という順序で処理を進めるようです。
前書きと文書実現値の境目は、最初に
[CODE(SGML)[[[stago]]]] の文字に遭遇する手前のようです。
([CODE(SGML)[stago]] の文字の直後が[[名前開始文字]]でなくてもその時点では何も言われません。ただし、 [CODE(char)[!]] や [CODE(char)[?]] や [CODE(char)[/]] が直後に来ると文句を言われます。)

実体値の構文解析の段階では、
参照の有無にかかわらず (そもそも文書実現値はまだ処理していない)、
重複していないすべての一般実体宣言を処理しています。
[WEAK[(たぶんこの時点で[[グローブ]]を作ってしまうのでしょう。)]]
[[名前]]の重複により無視される一般実体宣言は無視されますが、
[[定義済み文字実体]]は特別扱いされません。また、[[内部実体]]と[[外部実体]]も扱いに違いはありません。

ですから、一般実体の実体値
[WEAK[(同じ名前の宣言が複数ある時は、最初のもの。)]] を内容として構文解析した時に不適当な文字列が含まれていると、誤りが発生します。

このとき、

> 無効な文字で名前が始まりました。リソース 'http://www.satoshii.org/markup/samp/2003/xhtml11-msxml-m12n' の実行エラーです。ライン 1、位置 2
> &&

のようなメッセージがブラウザに表示されますが、
- [[URI]] は必ず[[文書実体]]のものとなる
- 文字の位置が実体値の先頭を起点としたものであることが示されていない

という間抜けな仕様になっている模様です。

このメッセージの場合は、元凶が
XHTML m12n の[[実体集合]]中にある
[PRE[
<!ENTITY amp     "&#38;&#38;" ><!-- ampersand, U+0026 ISOnum -->
]PRE]

という記述なのですが、
この実体宣言を解釈して得られる実体値は [CODE[&&]] です。
これを構文解析すると、 [CODE(char)[&]] の直後
(つまり[Q[ライン 1、位置 2]]) には名前開始文字が要求されるというわけです。

[WEAK[([[著者]]に直接見えるソース上の位置ではなく、構文解析結果である実体値上の位置なんて示されても困るのですけど、手抜きしたい気持ちはよくわかります。。。)]]

[2] で、参照してもいない実体の中身を勝手に構文解析しちゃうのってどうなんでしょう。

[[#comment]]


* SGML と XML

[6] SGML では、引数表記には実質任意の内容が記述できます。
認知されない [CODE(SGML)[[[pero]]]] や [CODE(SGML)[[[ero]]]]
などに割当てられた文字が含まれていても問題ありません。
また、 [CODE(SGML)[ERO]] は認知されたところで結局[[データ]]になります
([CODE(ABNF)[[[置換可能引数データ]]]]に[CODE(ABNF)[[[一般実体参照]]]]は含まれないので)。

ところが、 XML では >>3 の構文の通りであり、それは許されません。
[CODE(char)[&]] は、[[文字参照]]か[[一般実体参照]]の最初の文字ではなければなりません。
XML [[解析器]]は[[整形式]]性の検証のために SGML 的には解釈しないはずの一般実体参照を調べないといけません。
([[XML名前空間]]を使う場合は、更に[[名前空間整形式]]性まで調べないといけません。)

[7]
[[実体]]が[[宣言]]されていることという[[整形式制約]] 
<IW:XML1:"#wf-entdeclared">
および[[妥当性制約]] <IW:XML1:"#vc-entdeclared">
は[[実体値]]に現れる[[一般実体参照]]にも適用されるのでしょうか。
[[SGML]]の場合 (>>6) はともかく、[[XML]]の仕様書でこの制約についての例外は特になさそうです。

[[実体参照]]の参照先が[[非解析対象実体]]では''ない''こととの[[整形式制約]]
<IW:XML1:"#textent"> は、[[実体値]]内での展開に関してSE正誤表で修正されて[[誤り]]になっています
(<IW:XML1:"#error">)。展開に関する節で[[誤り]]に修正されて、
[[参照]]そのものに関する節で[[整形式制約]] = [[致命的誤り]]とされている部分が修正されていないのは矛盾のような気がしますがこれいかに。

[[再帰]]なしの[[整形式制約]] <IW:XML1:"#norecursion">
についても[[実体]]が[[参照]]される場合は、との限定なしに、
単に再帰参照は駄目としか書いてありません。
([[名無しさん]])

[8]
>>7 [[Firefox]]も[[Opera]]も、[[参照]]されていない[[実体]]の[[実体値]]の[[一般実体参照]]に関してはチェックしていない模様です。
>>1 のような動作をする[[WinIE]]は[[致命的誤り]]を報告します。
([[名無しさん]])

[9]
[[DOM]]の[CODE(DOM)@@en[[CODE(DOMi)@@en[[[DocumentType]]]].[CODE(DOMa)@@en[[[entities]]]]]]は[[文書型]]で[[宣言]]されている[[一般実体]]に相当する[CODE(DOMi)@@en[[[Entity]]]][[節点]]が入ることになっています。
[[参照]]されていない[[実体]]が含まれるのかどうかはよくわかりませんが、除外するという規定はありません。 (重複する[[実体宣言]]は反映されません。)
[[参照]]されていない[[節点]]も含めようと思ったら、[[置換木]]を作るためには[[一般実体参照]]に関するチェックもしないといけません。

でも[[Gecko]]も[[Opera]]も[CODE(DOMa)@@en[[[entities]]]]か[CODE(DOM)@@en[[[null]]]]だったり空だったり。
([[名無しさん]])


[10]
[[適合性]]に関する項 <IW:XML1:"#proc-types"> に、
>Validating and non-validating processors alike '''MUST''' report violations of this specification's well-formedness constraints in the content of the document entity and any other parsed entities that they read.

とか
>Non-validating processors are '''REQUIRED''' to check only the document entity, including the entire internal DTD subset, for well-formedness.

とか書いてある。前者を鵜呑みにすれば、[[参照]]されていない[[解析対象実体]]の[[整形式制約]]違反も検出しなければならない。
後者を鵜呑みにすれば[[内部解析対象実体]]すら[[整形式制約]]を検査しなくてもよいことになる。あるいは[[内部実体]]については[[内部部分集合]]が〜の項でカバーしているつもりなのか。
([[名無しさん]])


[[#comment]]


* メモ@


1.3
log
@auto-committed
@
text
@d124 8
d133 6
a138 4
[9]
[[DOM]]の[CODE(DOM)@@en[[CODE(DOMi)@@en[[[DocumentType]]]].[CODE(DOMa)@@en[[[entities]]]]]]は[[文書型]]で[[宣言]]されている[[一般実体]]に相当する[CODE(DOMi)@@en[[[Entity]]]][[節点]]が入ることになっています。
[[参照]]されていない[[実体]]が含まれるのかどうかはよくわかりませんが、除外するという規定はありません。 (重複する[[実体宣言]]は反映されません。)
[[参照]]されていない[[節点]]も含めようと思ったら、[[置換木]]を作るためには[[一般実体参照]]に関するチェックもしないといけません。
d140 2
a141 1
でも[[Gecko]]も[[Opera]]も[CODE(DOMa)@@en[[[entities]]]]か[CODE(DOM)@@en[[[null]]]]だったり空だったり。
@


1.2
log
@auto-committed
@
text
@d1 136
a136 99
#?SuikaWiki/0.9
[4] [DFN[[RUBYB[実体値][entity value]]]]は、
[[実体宣言]]の中の[[引数表記]]です。
([[SGML]] ではなく [[XML]] の用語です。
SGML の[[実体文]]の一種です。)

-[3] [CODE(ABNF)[[DFN[[RUBYB[実体値][EntityValue]]]] := "'" *(<[^'%&]> / [[実体参照]] / [[文字参照]]) "'" / <"> *(<[^"%&]> / 引数実体参照 / 実体参照 / 文字参照) <"> ;; XML 1.0/1.1 [9] 改]]

仕様書: 
-[XML 1.0] <http://www.w3.org/TR/REC-xml/#NT-EntityValue>
-[XML 1.1] <http://www.w3.org/TR/xml11/#NT-EntityValue>

[5]
[[一般実体]]を宣言する[[実体宣言]]の[CODE(ABNF)[実体値]]で生の
[CODE[<]] を使っても、その実体を[[参照]]しようとすると [[XML]]
ではどの場面であっても[[整形式]]とはならないので、
XML 仕様書は使用しないように強くすすめています。

[6] [[内部実体]]の[[表記実体値]]は[[実体値]]と同じものです。

内部実体の[[置換文]]は、表記実体値の内容を、
[[引数実体参照]]と文字参照を解決したものです。

[[#comment]]

* 実体値についての MSXML の挙動

[1] 
> なぜ実際に amp や lt を参照したわけでもないのにエラーになったのか、ということ。「ライン 1、位置 2」という表示もしっくりこないものがありますし、もしかすると MSXML は内部的に何らかの XML を利用していて、その中で amp への参照が現れてエラーになったのかなぁ…などと思ったり。

([[マーク付けノート]] ― M12N のバグと MSXML <http://www.satoshii.org/markup/notes/2004/02#date23-3>)

という話が気になったので、 [[MSXML]]
の挙動を調べてみました。
環境は [[WinXP]] + [[WinIE]] 6.0
です。

WinIE に XML 文書を与えると、
= [[前書き]]を構文解析
= [[一般実体]]の実体値を[[内容]]として構文解析
= [[文書実現値]]以降を構文解析

という順序で処理を進めるようです。
前書きと文書実現値の境目は、最初に
[CODE(SGML)[[[stago]]]] の文字に遭遇する手前のようです。
([CODE(SGML)[stago]] の文字の直後が[[名前開始文字]]でなくてもその時点では何も言われません。ただし、 [CODE(char)[!]] や [CODE(char)[?]] や [CODE(char)[/]] が直後に来ると文句を言われます。)

実体値の構文解析の段階では、
参照の有無にかかわらず (そもそも文書実現値はまだ処理していない)、
重複していないすべての一般実体宣言を処理しています。
[WEAK[(たぶんこの時点で[[グローブ]]を作ってしまうのでしょう。)]]
[[名前]]の重複により無視される一般実体宣言は無視されますが、
[[定義済み文字実体]]は特別扱いされません。また、[[内部実体]]と[[外部実体]]も扱いに違いはありません。

ですから、一般実体の実体値
[WEAK[(同じ名前の宣言が複数ある時は、最初のもの。)]] を内容として構文解析した時に不適当な文字列が含まれていると、誤りが発生します。

このとき、
>    無効な文字で名前が始まりました。リソース 'http://www.satoshii.org/markup/samp/2003/xhtml11-msxml-m12n' の実行エラーです。ライン 1、位置 2
>
&&

のようなメッセージがブラウザに表示されますが、
- [[URI]] は必ず[[文書実体]]のものとなる
- 文字の位置が実体値の先頭を起点としたものであることが示されていない

という間抜けな仕様になっている模様です。

このメッセージの場合は、元凶が
XHTML m12n の[[実体集合]]中にある
[PRE[
<!ENTITY amp     "&#38;&#38;" ><!-- ampersand, U+0026 ISOnum -->
]PRE]
という記述なのですが、
この実体宣言を解釈して得られる実体値は [CODE[&&]] です。
これを構文解析すると、 [CODE(char)[&]] の直後
(つまり[Q[ライン 1、位置 2]]) には名前開始文字が要求されるというわけです。

[WEAK[([[著者]]に直接見えるソース上の位置ではなく、構文解析結果である実体値上の位置なんて示されても困るのですけど、手抜きしたい気持ちはよくわかります。。。)]]

[2] で、参照してもいない実体の中身を勝手に構文解析しちゃうのってどうなんでしょう。

[[#comment]]

* SGML と XML

[6] SGML では、引数表記には実質任意の内容が記述できます。
認知されない [CODE(SGML)[[[pero]]]] や [CODE(SGML)[[[ero]]]]
などに割当てられた文字が含まれていても問題ありません。
また、 [CODE(SGML)[ERO]] は認知されたところで結局[[データ]]になります
([CODE(ABNF)[[[置換可能引数データ]]]]に[CODE(ABNF)[[[一般実体参照]]]]は含まれないので)。

ところが、 XML では >>3 の構文の通りであり、それは許されません。
[CODE(char)[&]] は、[[文字参照]]か[[一般実体参照]]の最初の文字ではなければなりません。
XML [[解析器]]は[[整形式]]性の検証のために SGML 的には解釈しないはずの一般実体参照を調べないといけません。
([[XML名前空間]]を使う場合は、更に[[名前空間整形式]]性まで調べないといけません。)

[[#comment]]

@


1.1
log
@auto-committed
@
text
@d2 22
d80 21
a100 1
- [2] で、参照してもいない実体の中身を勝手に構文解析しちゃうのってどうなんでしょう。
@

