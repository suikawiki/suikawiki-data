head	1.1;
access;
symbols
	suikawiki3-final:1.1
	before-db-leaffile:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2004.03.18.02.07.17;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.1
log
@auto-committed
@
text
@#?SuikaWiki/0.9

[1]
[[SuikaWiki/0.9]] → HTML 変換で
[CODE(element)[[[anchor-end]]]] から変換された [CODE(HTMLe)[[[a]]]] 要素に、
[CODE[html_no_id]] 格下げ選択肢が有効になっている時にも [CODE(HTMLa)[[[name]]]] 属性がつかない不具合があったので、修正しました。
([[名無しさん]] [WEAK[2004-02-18 02:47:50 +00:00]])

[2]
WikiDB で locked とかの致死誤りが発生した後に、普通に処理を継続しようとして、 WikiDB が既に閉じられているので Perl 致死誤り (method が見つかりませんとか) が発生してしまう問題を修正しました。

本来そのような問題は catch して致死誤り通告をもって処理終了としないといけないのですが、 try〜catch が入れ子になっているために、内側の try〜catch で致死誤りが無かったことにされてしまっていました。
そこで、全部の WikiDB についての try〜catch で、 [CODE[ERROR_REPORTED]] という特別な誤り (誤り通告 view の処理後に送られる。) だけは上位に伝達するようにしました。

あとになって、そんなことしなくても、適当な別の名前の最上位でだけ catch する誤りを発生させれば修正の手間が省けるしもしかするとほんのすこしだけ (条件分岐の分) 処理速度が向上するかもしれないことに気づきましたが、もう全部直してしまったのでまあいいでしょう。
([[名無しさん]] [WEAK[2004-02-18 04:13:20 +00:00]])


[3]
ちなみに、今の実装の大半の箇所では、 WikiDB が開かれている ([CODE(perl)[$wiki->{db}]] が利用できる) ことを想定しています。 WikiDB は Wiki system の要なのですから、この想定は重くはないでしょう。今の実装でこの仮定が崩れるのは WikiDB fatal error などの深刻な誤りが発生しているときだけです。 (そしてそのような場合に使われる部分では WikiDB が開かれているかの検査が入っています。)
ですから、 error 報告部分を修正して現時点で使っていない整形規則なりなんなりを使うようにすると、未定義値から method を呼べませんのような Perl error が発生することになります。
(これはその都度修正でいいでしょう。)
([[名無しさん]] [WEAK[2004-02-18 04:23:54 +00:00]])
@
