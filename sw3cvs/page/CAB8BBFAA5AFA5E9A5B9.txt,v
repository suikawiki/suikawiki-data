head	1.1;
access;
symbols
	suikawiki3-final:1.1
	before-db-leaffile:1.1
	after-upgrade-to-suikawiki-3:1.1
	before-fork-suikawiki3:1.1
	after-restore-20040122:1.1;
locks; strict;
comment	@# @;


1.1
date	2003.06.06.12.26.42;	author make;	state Exp;
branches;
next	;


desc
@@


1.1
log
@auto-commited
@
text
@#?SuikaWiki/0.9 page-icon="字β" default-name="〓"

- [1] [[正規表現]]なんかの文字クラス、こんなのは悪い例でしょう。 [SAMP(regex)[ [ぁ-ん] ]]
-- [2] >>1 のような例は、特定の[[文字コード]]の文字の配列に依存してます。使う文字コードが決まってるならいいじゃないかと思うかもしれませんが、文字コードでの配列順を知らないと何を表しているのかがはっきりしないのはいただけません。
-- [3] 同様に [SAMP(regex)[ [!-~] ]] も悪い例です。 [[ASCII]] に含まれている [[SP]] 以外の[[印字可能文字]]の集合を表したいのなら面倒でも94文字列挙するべきですし、範囲 [CODE[0x21]]〜[CODE[0x7E]] を示したいなら [CODE(regex)[ [\x21-\x7E] ]] のような書き方 (が出来るなら。) をした方が意味がはっきりします。
- [4] 但し、[[用字系]]で確立した文字配列順があるなら、それを使うのもいいかとは思います。例えば [SAMP(regex)[ [A-Z] ]] や [SAMP(regex)[ [あ-ん] ]] は十分論理的です。 (但し、実際には前者は [[EBCDIC]] の場合に、後者は''ほとんど全て''の場合に、意図したようには動きません。[WEAK[[SAMP(char)[A]]〜[SAMP(char)[Z]] の間の並びにそれ以外の文字が混じっているからです。]])
-- [5] そのような場合には、処理系によっては [SAMP(regex)[ [:hiragana:] ]] とか [SAMP(regex)[ [[\p]]{InHiragana} ]] のような書き方が出来るかもしれません。これなら、可搬性・可読性の高い正規表現がかけます。
--- [6] >>5 しかし問題もあって、処理系によって書き方が違うこと、同じ名前でも実際の中身は異なる可能性があること、意図した集合が用意されているとは限らない [WEAK[(用字系に付属する記号類 ([[句読点]]や[[字上符]]など) の扱いとか。)]] ことなど、本当に使い物になるかは未知数です。 [WEAK[(それを言ったら [CODE(regex)[[[\s]]]] とかも同じことなんですが。)]]
@
