head	1.3;
access;
symbols
	suikawiki3-final:1.3
	before-db-leaffile:1.1
	after-upgrade-to-suikawiki-3:1.1
	before-fork-suikawiki3:1.1
	after-restore-20040122:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2006.12.18.02.29.33;	author wakaba;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.31.02.16.11;	author wakaba;	state dead;
branches;
next	1.1;

1.1
date	2003.06.06.12.26.54;	author make;	state Exp;
branches;
next	;


desc
@@


1.3
log
@auto-committed
@
text
@
[1]
ÕÅÊ±Óê
([[gb2312]] [big5] [WEAK[2006-12-15 09:45:00 +00:00]])

[2]
good morning!
([[gb2312]] [big5] [WEAK[2006-12-15 09:45:41 +00:00]])

[3]
1] $BUEJ1Sj
([[big5]] [gb2312] [WEAK[2006-12-15 09:47:30 +00:00]])

[4]
1] $BUEJ1Sj
([[big5]] [gb2312] [WEAK[2006-12-15 09:47:34 +00:00]])


[5]
1] $BUEJ1Sj
([[big5]] [gb2312] [WEAK[2006-12-15 09:47:38 +00:00]])

@


1.2
log
@auto-committed
@
text
@d1 22
a22 753
#?SuikaWiki/0.9

*Perl 5.8 ÉÕÂ°¤Î Encode ¥â¥¸¥å¡¼¥ë

**NAME

Encode - character encodings Ê¸»úÉä¹æ²½

**SYNOPSIS

    use Encode;

***Table of Contents ÌÜ¼¡

Encode consists of a collection of modules whose details are too big
to fit in one document.  This POD itself explains the top-level APIs
and general topics at a glance.  For other topics and more details,
see the PODs below:

Encode ¤Ï¡¢¾ÜºÙ¤ò°ì¤Ä¤ÎÊ¸½ñ¤Ë¤Þ¤È¤á¤ë¤Ë¤ÏÂç¤­¤¹¤®¤ë
¥â¥¸¥å¡¼¥ë·²¤Ç¹½À®¤µ¤ì¤Þ¤¹¡£¤³¤Î [[POD]] ¼«ÂÎ¤Ï¾å°Ì [[API]]
¤È°ìÈÌÅª»ö¹à¤Ë´ÊÃ±¤Ë¿¨¤ì¤Þ¤¹¡£Â¾¤ÎÏÃÂê¤ä¾ÜºÙ¤Ë¤Ä¤¤¤Æ¤Ï¡¢
¼¡¤Ë¼¨¤¹ POD ¤ò»²¾È¤·¤Æ²¼¤µ¤¤¡£

,Name Ì¾Á°        ,Description                ,ÀâÌÀ
,[[Encode::Alias]]         ,Alias definitions to encodings,Éä¹æ²½¤ÎÊÌÌ¾¤ÎÄêµÁ
,[[Encode::Encoding]]      ,Encode Implementation Base Class,Encode ¼ÂÁõ´ðÄì¥¯¥é¥¹
,[[Encode::Supported]]     ,List of Supported Encodings   ,ÂÐ±þÉä¹æ²½¤Î°ìÍ÷
,[[Encode::CN]]            ,Simplified Chinese Encodings  ,´ÊÂÎ»úÃæÊ¸Éä¹æ²½
,[[Encode::JP]]            ,Japanese Encodings      ,ÆüËÜ¸ìÉä¹æ²½
,[[Encode::KR]]            ,Korean Encodings        ,´Ú¸ìÉä¹æ²½
,[[Encode::TW]]            ,Traditional Chinese Encodings ,ÅÁÅý»úÃæÊ¸Éä¹æ²½

**DESCRIPTION

The C<Encode> module provides the interfaces between Perl's strings
and the rest of the system.  Perl strings are sequences of
B<characters>.

Encode ¥â¥¸¥å¡¼¥ë¤Ï [[Perl]] ¤ÎÊ¸»úÎó¤È½èÍý·Ï¤Î rest
¤È¤Î´Ö¤Î³¦ÌÌ¤òÄó¶¡¤·¤Þ¤¹¡£ Perl Ê¸»úÎó¤ÏÊ¸»ú¤ÎÏ¢Â³¤Ç¤¹¡£

The repertoire of characters that Perl can represent is at least that
defined by the Unicode Consortium. On most platforms the ordinal
values of the characters (as returned by C<ord(ch)>) is the "Unicode
codepoint" for the character (the exceptions are those platforms where
the legacy encoding is some variant of EBCDIC rather than a super-set
of ASCII - see L<perlebcdic>).

Perl ¤¬É½¸½²ÄÇ½¤ÊÊ¸»ú¤Î[[¥ì¥Ñ¡¼¥È¥ê]]¤Ï¡¢ºÇÄã [[UnicodeConsortium]]
¤ÇÄêµÁ¤µ¤ì¤Æ¤¤¤Þ¤¹¡£¤Û¤È¤ó¤É¤Î´Ä¶­¤Ç¤ÏÊ¸»ú¤Î½ø¿ô
(ord(ch) ¤ÇÊÖ¤ë) ¤ÏÊ¸»ú¤Î¡Ö[[Unicode]] [[Éä¹æ°ÌÃÖ]]¡×¤Ç¤¹
(Îã³°¤Ï[[°ä»º]]Éä¹æ²½¤¬ [[ASCII]] ¤Î super-set ¤Ç¤Ï¤Ê¤¯
[[EBCDIC]] ¤ÎÊÑ¼ï¤Ç¤¢¤ë´Ä¶­¤Ç¤¹¡£ [[perlebcdic]] »²¾È)¡£

Traditionally, computer data has been moved around in 8-bit chunks
often called "bytes". These chunks are also known as "octets" in
networking standards. Perl is widely used to manipulate data of many
types - not only strings of characters representing human or computer
languages but also "binary" data being the machine's representation of
numbers, pixels in an image - or just about anything.

ÅÁÅýÅª¤Ë¡¢·×»»µ¡¥Ç¡¼¥¿¤Ï¤·¤Ð¤·¤Ð¡Ö[[¥Ð¥¤¥È]]¡×¤È¸Æ¤Ð¤ì¤ë8¥Ó¥Ã¥È²ô
¤ÎÊÕ¤ê¤Ë¤Ê¤Ã¤Æ¤Þ¤¹¡£¤³¤Î²ô¤Ï¥Í¥Ã¥È¥ï¡¼¥¯µ¬³Ê¤Ç¤Ï¡Ö[[¥ª¥¯¥Æ¥Ã¥È]]¡×
¤È¤â¸Æ¤Ð¤ì¤Þ¤¹¡£ Perl ¤Ï¤¤¤í¤ó¤Ê¼ïÎà¤Î¥Ç¡¼¥¿¤ò°·¤¦¤Î¤Ë
¹­¤¯»È¤ï¤ì¤Æ¤¤¤Þ¤¹¡£¿Í´Ö¤Î¸À¸ì¤Þ¤¿¤Ï·×»»µ¡¸À¸ì¤ò¤¢¤é¤ï¤¹Ê¸»ú¤ÎÎó
¤À¤±¤Ç¤Ï¤Ê¤¯¡¢¿ôÃÍ¡¦²èÁü¤Î²èÁÇ¤Ê¤É¤Ê¤É¤Îµ¡³£¤ÎÉ½¸½¤Î
¡Ö[[¥Ð¥¤¥Ê¥ê]]¡×¥Ç¡¼¥¿¤À¤Ã¤¿¤ê¤â¤·¤Þ¤¹¡£

[INS[
ÌõÃí: ¥Ð¥¤¥È¤È¥ª¥¯¥Æ¥Ã¥È¤Ï¡¢ËÜÍè¸·Ì©¤Ë¶èÊÌ¤µ¤ì¤ë¤Ù¤­¤â¤Î¤Ç¤¹¡£
(Perl ¤ÎÀ¤³¦¤Ç¤Ï¤½¤¦¤¹¤ë°ÕµÁ¤Ï¤½¤ì¤Û¤É¤Ê¤¤¤Î¤Ç¡¢¤³¤¦ÀâÌÀ
¤·¤Æ¤¤¤ë¤Î¤Ç¤·¤ç¤¦¤¬¡£) See [[¥Ð¥¤¥È]]¡£
]INS]

When Perl is processing "binary data", the programmer wants Perl to
process "sequences of bytes". This is not a problem for Perl - as a
byte has 256 possible values, it easily fits in Perl's much larger
"logical character".

Perl ¤¬¡Ö¥Ð¥¤¥Ê¥ê¡¦¥Ç¡¼¥¿¡×¤ò½èÍý¤¹¤ë»þ¤Ë¡¢¥×¥í¥°¥é¥Þ¡¼¤Ï
Perl ¤¬¡Ö¥Ð¥¤¥È¤ÎÎó¡×¤ò½èÍý¤¹¤ë¤³¤È¤òË¾¤ß¤Þ¤¹¡£¤³¤ì¤Ï Perl
¤Ë¤È¤Ã¤Æ¤ÏÌäÂê¤Ç¤Ï¤Ê¤¯¡¢¥Ð¥¤¥È¤Ï256¼ïÎà¤ÎÃÍ¤ò¼è¤ê¤¨¤Þ¤¹¤¬¡¢
Perl ¤Î¤è¤ê¹­ÈÏ°Ï¤Ë¤ï¤¿¤ë¡ÖÏÀÍýÊ¸»ú¡×¤Ë¤Ï´ÊÃ±¤Ë¹ç¤¤¤Þ¤¹¡£

***TERMINOLOGY ÍÑ¸ì

I<character>: a character in the range 0..(2**32-1) (or more).
(What Perl's strings are made of.)

[[Ê¸»ú]]: 0..(2**32-1) (¤Þ¤¿¤Ï¤³¤ì°Ê¾å) ¤ÎÈÏ°Ï¤ÎÊ¸»ú¡£
(Perl ¤ÎÊ¸»úÎó¤Î¹½À®Í×ÁÇ)

I<byte>: a character in the range 0..255
(A special case of a Perl character.)

[[¥Ð¥¤¥È]]: 0..255 ¤ÎÈÏ°Ï¤ÎÊ¸»ú (Perl Ê¸»ú¤ÎÆÃ¼ì¤Ê¾ì¹ç¡£)

I<octet>: 8 bits of data, with ordinal values 0..255
(Term for bytes passed to or from a non-Perl context, e.g. a disk file.)

¥ª¥¯¥Æ¥Ã¥È: ¥Ç¡¼¥¿¤Î8¥Ó¥Ã¥È¤Ç¡¢½ø¿ôÃÍ¤Ï 0..255
(¥Ç¥£¥¹¥¯¤Î¥Õ¥¡¥¤¥ë¤Ê¤É¤ÎÈó Perl Ê¸Ì®¤Ø¤Þ¤¿¤Ï¤½¤¦¤·¤¿Ê¸Ì®¤«¤é
¥Ð¥¤¥È¤¬ÅÏ¤µ¤ì¤ë»þ¤ÎÍÑ¸ì¡£)

[INS[
ÌõÃí: ¤³¤ÎÊ¸¾ÏÃæ¤ÎÄêµÁ¤Ç¤¢¤Ã¤Æ¡¢°ìÈÌÅª¤ÊÄêµÁ¤Ç¤Ï¤Ê¤¤¤³¤È¤ËÃí°Õ¡£
]INS]

**PERL ENCODING API

-$octets  = encode(ENCODING, $string [, CHECK])

Encodes a string from Perl's internal form into I<ENCODING> and returns
a sequence of octets.  ENCODING can be either a canonical name or
an alias.  For encoding names and aliases, see L</"Defining Aliases">.
For CHECK, see L</"Handling Malformed Data">.

Ê¸»úÎó¤ò Perl ¤ÎÆâÉô·Á¼°¤«¤é ENCODING ¤ËÉä¹æ²½¤·¡¢
¥ª¥¯¥Æ¥Ã¥È¤ÎÎó¤òÊÖ¤·¤Þ¤¹¡£ ENCODING ¤ÏÀµµ¬Ì¾¤Ç¤âÊÌÌ¾¤Ç¤â
¹½¤¤¤Þ¤»¤ó¡£Éä¹æ²½Ì¾¤ÈÊÌÌ¾¤Ë¤Ä¤¤¤Æ¤Ï¡ÖÊÌÌ¾¤òÄêµÁ¤¹¤ë¡×¤ò¤´Í÷²¼¤µ¤¤¡£
CHECK ¤Ë¤Ä¤¤¤Æ¤Ï¡¢¡ÖÉÔÀµ¥Ç¡¼¥¿¤Î¼è¤ê°·¤¤¡×¤ò¤´Í÷²¼¤µ¤¤¡£

For example, to convert a string from Perl's internal format to
iso-8859-1 (also known as Latin1),

Îã¤¨¤Ð¡¢ Perl ¤ÎÆâÉô·Á¼°¤ÎÊ¸»úÎó¤ò iso-8859-1 (aka Latin1)
¤ËÊÑ´¹¤¹¤ë¤Ë¤Ï¡¢¼¡¤Î¤è¤¦¤Ë¤·¤Þ¤¹¡£

  $octets = encode("iso-8859-1", $string);

B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then $octets
B<may not be equal to> $string.  Though they both contain the same data, the utf8 flag
for $octets is B<always> off.  When you encode anything, utf8 flag of
the result is always off, even when it contains completely valid utf8
string. See L</"The UTF-8 flag"> below.

'''·Ù¹ð''': $octets = encode ("utf8", $string) ¤ò¤·¤¿¤È¤­¡¢ $octets
¤Ï $string ¤È'''Æ±¤¸¤Ç¤Ê¤¤¤«¤â¤·¤ì¤Þ¤»¤ó'''¡£Î¾¼Ô¤ÏÆ±¤¸¥Ç¡¼¥¿¤«¤é
À®¤Ã¤Æ¤¤¤Þ¤¹¤¬¡¢ $octets ¤Î utf8 ´ú¤Ï'''¾ï¤Ë''' off ¤Ç¤¹¡£
Éä¹æ²½¤¬²¿¤Ç¤¢¤ì¡¢·ë²Ì¤Î utf8 ´ú¤Ï¤½¤ì¤¬´°Á´¤ËÂÅÅö¤Ê utf8
Ê¸»úÎó¤Ç¤¢¤Ã¤Æ¤â¾ï¤Ë off ¤Ç¤¹¡£²¼¤Î¡ÖUTF-8 ´ú¡×¤ò¤´Í÷²¼¤µ¤¤¡£

encode($valid_encoding, undef) is harmless but warns you for 
C<Use of uninitialized value in subroutine entry>. 
encode($valid_encoding, '') is harmless and warnless.

encode ($valid_encoding, undef) ¤ÏÌµ³²¤Ç¤¹¤¬¡¢
¡ÖUse of uninitialized value in subroutine entry
(¾® routine ¹àÌÜÃæ¤Ë½é´ü²½¤µ¤ì¤Æ¤¤¤Ê¤¤ÃÍ¤¬»È¤ï¤ì¤Æ¤¤¤ë)¡×
·Ù¹ð¤¬½Ð¤Þ¤¹¡£ encode ($valid_encoding, '') ¤ÏÌµ³²¤ÇÌµ·Ù¹ð¤Ç¤¹¡£

-$string = decode(ENCODING, $octets [, CHECK])

Decodes a sequence of octets assumed to be in I<ENCODING> into Perl's
internal form and returns the resulting string.  As in encode(),
ENCODING can be either a canonical name or an alias. For encoding names
and aliases, see L</"Defining Aliases">.  For CHECK, see
L</"Handling Malformed Data">.

¥ª¥¯¥Æ¥Ã¥È¤ÎÏ¢Â³¤ò ENCODING ¤Ç½ñ¤«¤ì¤Æ¤¤¤ë¤È²¾Äê¤·¤Æ
Perl ¤ÎÆâÉô·Á¤ËÊÑ´¹¤·¡¢·ë²Ì¤ÎÊ¸»úÎó¤òÊÖ¤·¤Þ¤¹¡£ encode() Æ±ÍÍ¡¢
ENCODING ¤ÏÀµµ¬Ì¾¤Ç¤âÊÌÌ¾¤Ç¤â¹½¤¤¤Þ¤»¤ó¡£

For example, to convert ISO-8859-1 data to a string in Perl's internal format:

Îã¤¨¤Ð¡¢ ISO-8859-1 ¤Î¥Ç¡¼¥¿¤ò Perl ÆâÉô·Á¼°¤ÎÊ¸»úÎó¤Ë
ÊÑ´¹¤¹¤ë¤Ë¤Ï¡¢¤³¤Î¤è¤¦¤Ë¤·¤Þ¤¹¡£

  $string = decode("iso-8859-1", $octets);

B<CAVEAT>: When you run C<$string = decode("utf8", $octets)>, then $string
B<may not be equal to> $octets.  Though they both contain the same data,
the utf8 flag for $string is on unless $octets entirely consists of
ASCII data (or EBCDIC on EBCDIC machines).  See L</"The UTF-8 flag">
below.

'''·Ù¹ð''': $string = decode("utf8", $octets) ¤·¤¿¤È¤­¤Ë¡¢
$string ¤Ï $octet ¤È'''Æ±°ì¤Ç¤Ê¤¤¤«¤â¤·¤ì¤Þ¤»¤ó'''¡£
Î¾¼Ô¤ÏÆ±¤¸¥Ç¡¼¥¿¤ò»ý¤Á¤Þ¤¹¤¬¡¢ $string ¤Î utf8 ´ú¤Ï
$octets Á´ÂÎ¤¬ ASCII ¥Ç¡¼¥¿ (EBCDIC µ¡¤Ç¤Ï EBCDIC)
¤Ç¹½À®¤µ¤ì¤Æ¤¤¤Ê¤¤»þ¤Ï on ¤Ë¤Ê¤ê¤Þ¤¹¡£

decode($valid_encoding, undef) is harmless but warns you for 
C<Use of uninitialized value in subroutine entry>. 
decode($valid_encoding, '') is harmless and warnless.

decode($valid_encoding, undef) ¤ÏÌµ³²¤Ç¤¹¤¬
C<Use of uninitialized value in subroutine entry>
(¾® routine ¹àÌÜÃæ¤Ç¤ÎÌ¤½é´ü²½ÃÍ¤Î»ÈÍÑ) ¤ò·Ù¹ð¤µ¤ì¤Þ¤¹¡£
decode($valid_encoding, '') ¤ÏÌµ³²¤«¤ÄÌµ·Ù¹ð¤Ç¤¹¡£

-[$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])

Converts B<in-place> data between two encodings. The data in $octets
must be encoded as octets and not as characters in Perl's internal
format. For example, to convert ISO-8859-1 data to Microsoft's CP1250 encoding:

'''¤½¤Î¾ì¤Ç'''¥Ç¡¼¥¿¤ò2¤Ä¤ÎÉä¹æ²½´Ö¤ÇÊÑ´¹¤·¤Þ¤¹¡£ $octets
Ãæ¤Î¥Ç¡¼¥¿¤Ï¥ª¥¯¥Æ¥Ã¥È¤ÇÉä¹æ²½¤µ¤ì¤Æ¤¤¤ëÉ¬Í×¤¬¤¢¤ê¡¢
Perl ¤ÎÆâÉô·Á¼°¤ÎÊ¸»ú¤Ç¤¢¤Ã¤Æ¤Ï¤Ê¤ê¤Þ¤»¤ó¡£ ISO-8859-1
¥Ç¡¼¥¿¤ò Microsoft ¤Î CP1250 Éä¹æ²½¤ËÊÑ´¹¤¹¤ë¤Ë¤Ï¡¢
¼¡¤Î¤è¤¦¤Ë¤·¤Þ¤¹¡£

  from_to($octets, "iso-8859-1", "cp1250");

and to convert it back:

¤³¤ÎµÕÊÑ´¹¤Ï¼¡¤Î¤è¤¦¤Ë¤·¤Þ¤¹¡£

  from_to($octets, "cp1250", "iso-8859-1");

Note that because the conversion happens in place, the data to be
converted cannot be a string constant; it must be a scalar variable.

ÊÑ´¹¤Ï¤½¤Î¾ì¤Ç¹Ô¤ï¤ì¤ë¤³¤È¤ËÃí°Õ¤·¤Æ²¼¤µ¤¤¡£ÊÑ´¹¤µ¤ì¤ë¥Ç¡¼¥¿¤Ï
Ê¸»úÎóÄê¿ô¤Ç¤Ï¤Ê¤¯¡¢¥¹¥«¥é¡¼ÃÍ¤Ç¤Ê¤±¤ì¤Ð¤Ê¤ê¤Þ¤»¤ó¡£

from_to() returns the length of the converted string in octets on success, undef
otherwise.

from_to() ¤ÏÊÑ´¹¤·¤¿Ê¸»úÎó¤Î¥ª¥¯¥Æ¥Ã¥ÈÄ¹¤òÀ®¸ù¤·¤¿¾ì¹ç¤ÏÊÖ¤·¡¢
¤½¤¦¤Ç¤Ê¤±¤ì¤Ð undef ¤òÊÖ¤·¤Þ¤¹¡£

B<CAVEAT>: The following operations look the same but are not quite so;

'''·Ù¹ð''': ¼¡¤Î½èÍý¤ÏÆ±¤¸ÍÍ¤Ë¸«¤¨¤Þ¤¹¤¬¡¢¤½¤¦¤Ç¤Ï¤¢¤ê¤Þ¤»¤ó¡£

  from_to($data, "iso-8859-1", "utf8"); #1
  $data = decode("iso-8859-1", $data);  #2

Both #1 and #2 make $data consist of a completely valid UTF-8 string
but only #2 turns utf8 flag on.  #1 is equivalent to

#1, #2 ¶¦¤Ë $data ¤ò´°Á´¤ËÂÅÅö¤Ê UTF-8 Ê¸»úÎó¤È¤·¤Þ¤¹¤¬¡¢
#2 ¤À¤±¤¬ utf8 ´ú¤ò on ¤Ë¤·¤Þ¤¹¡£ #1 ¤Ï

  $data = encode("utf8", decode("iso-8859-1", $data));

See L</"The UTF-8 flag"> below.

¤ÈÆ±Åù¤Ç¤¹¡£

-$octets = encode_utf8($string);

Equivalent to C<$octets = encode("utf8", $string);> The characters
that comprise $string are encoded in Perl's internal format and the
result is returned as a sequence of octets. All possible
characters have a UTF-8 representation so this function cannot fail.

$octets = encode("utf8", $string); ¤ÈÆ±Åù¤Ç¤¹¡£ $string
¤ò¹½À®¤¹¤ëÊ¸»ú¤Ï Perl ¤ÎÆâÉô·Á¼°¤ÇÉä¹æ²½¤µ¤ì¤Æ¤ª¤ê¡¢
·ë²Ì¤Ë¤Ï¥ª¥¯¥Æ¥Ã¥È¤ÎÏ¢Â³¤È¤·¤ÆÊÖ¤µ¤ì¤Þ¤¹¡£Á´¤Æ¤Î¹Í¤¨¤é¤ì¤ë
Ê¸»ú¤Ï UTF-8 É½¸½¤ò¤â¤Á¤Þ¤¹¤«¤é¡¢¤³¤Î´Ø¿ô¤Ï¼ºÇÔ¤·¤Þ¤»¤ó¡£

-$string = decode_utf8($octets [, CHECK]);

equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
The sequence of octets represented by
$octets is decoded from UTF-8 into a sequence of logical
characters. Not all sequences of octets form valid UTF-8 encodings, so
it is possible for this call to fail.  For CHECK, see
L</"Handling Malformed Data">.

$string = decode("utf8", $octets [, CHECK]) ¤ÈÆ±Åù¤Ç¤¹¡£
$octets ¤ÇÉ½¸½¤µ¤ì¤ë¥ª¥¯¥Æ¥Ã¥È¤ÎÏ¢Â³¤ò UTF-8 ¤«¤éÉü¹æ¤·¤Æ
ÏÀÍýÊ¸»ú¤ÎÎó¤Ë¤·¤Þ¤¹¡£Á´¤Æ¤Î¥ª¥¯¥Æ¥Ã¥È¤ÎÏ¢Â³·Á¤¬ÂÅÅö¤Ê UTF-8
Éä¹æ²½¤Ç¤Ï¤¢¤ê¤Þ¤»¤ó¤«¤é¡¢¤³¤Î¸Æ¤Ó½Ð¤·¤Ï¼ºÇÔ¤·ÆÀ¤Þ¤¹¡£
CHECK ¤Ë¤Ä¤¤¤Æ¤ÏÉÔÀµ¤Ê¥Ç¡¼¥¿¤Î¼è¤ê°·¤¤¤ò»²¾È¡£

***Listing available encodings ÍøÍÑ²ÄÇ½Éä¹æ²½¤òÎóµó

  use Encode;
  @@list = Encode->encodings();

Returns a list of the canonical names of the available encodings that
are loaded.  To get a list of all available encodings including the
ones that are not loaded yet, say

ÆÉ¤ß¹þ¤Þ¤ì¤Æ¤¤¤ëÍøÍÑ²ÄÇ½¤ÊÉä¹æ²½¤ÎÀµµ¬Ì¾¤Î°ìÍ÷¤òÊÖ¤·¤Þ¤¹¡£
¤Þ¤ÀÆÉ¤ß¹þ¤Þ¤ì¤Æ¤¤¤Ê¤¤¤â¤Î¤ò´Þ¤á¤¿Á´¤Æ¤ÎÍøÍÑ²ÄÇ½¤ÊÉä¹æ²½¤Î
°ìÍ÷¤òÆÀ¤ë¤Ë¤Ï¡¢

  @@all_encodings = Encode->encodings(":all");

Or you can give the name of a specific module.

¤È¤¹¤ë¤«¡¢ÆÃÄê¥â¥¸¥å¡¼¥ë¤ÎÌ¾Á°¤òÍ¿¤¨¤ë¤³¤È¤â½ÐÍè¤Þ¤¹¡£

  @@with_jp = Encode->encodings("Encode::JP");

When "::" is not in the name, "Encode::" is assumed.

"::" ¤¬Ì¾Á°Ãæ¤ËÌµ¤±¤ì¤Ð¡¢ "Encode::" ¤òÊä¤¤¤Þ¤¹¡£

  @@ebcdic = Encode->encodings("EBCDIC");

To find out in detail which encodings are supported by this package,
see L<Encode::Supported>.

¤³¤Î package ¤ÇÂÐ±þ¤·¤Æ¤¤¤ëÉä¹æ²½¤Î¾ÜºÙ¤Ë¤Ä¤¤¤Æ¤Ï
Encode::Supported ¤ò»²¾È¡£

***Defining Aliases ÊÌÌ¾¤òÄêµÁ¤¹¤ë

To add a new alias to a given encoding, use:

¤¢¤ëÉä¹æ²½¤Ë¿·¤·¤¤ÊÌÌ¾¤òÄÉ²Ã¤¹¤ë¤Ë¤Ï¡¢¤³¤¦¤·¤Þ¤¹¡£

  use Encode;
  use Encode::Alias;
  define_alias(newName => ENCODING);

After that, newName can be used as an alias for ENCODING.
ENCODING may be either the name of an encoding or an
I<encoding object>

¤³¤Î¸å¡¢ newName ¤Ï ENCODING ¤ÎÊÌÌ¾¤È¤·¤Æ»ÈÍÑ½ÐÍè¤Þ¤¹¡£
ENCODING ¤ÏÉä¹æ²½¤ÎÌ¾Á°¤« ''encoding object'' ¤Î¤É¤Á¤é¤«¤Ç¤¹¡£

But before you do so, make sure the alias is nonexistent with
C<resolve_alias()>, which returns the canonical name thereof.
i.e.

¤·¤«¤·¤³¤¦¤¹¤ëÁ°¤Ë¡¢ÊÌÌ¾¤¬ resolve_alias() ¤ÇÂ¸ºß¤·¤Ê¤¤¤³¤È¤ò
³ÎÇ§¤·¤Æ¤¯¤À¤µ¤¤¡£¤³¤Î´Ø¿ô¤ÏÊÌÌ¾¤ÎÀµµ¬Ì¾¤òÊÖ¤·¤Þ¤¹¡£

  Encode::resolve_alias("latin1") eq "iso-8859-1" # true
  Encode::resolve_alias("iso-8859-12")   # false; nonexistent  # µ¶; Â¸ºß¤·¤Ê¤¤
  Encode::resolve_alias($name) eq $name  # true if $name is canonical  # $name ¤¬Àµµ¬Ì¾¤Ê¤é¿¿

resolve_alias() does not need C<use Encode::Alias>; it can be
exported via C<use Encode qw(resolve_alias)>.

resolve_alias() ¤Ï use Encode::Alias ¤¹¤ëÉ¬Í×¤Ï¤¢¤ê¤Þ¤»¤ó¡£
use Encode qw(resolve_alias) ¤ÇÍ¢½Ð½ÐÍè¤Þ¤¹¡£

See L<Encode::Alias> for details.

**Encoding via PerlIO PerlIO ¤ò²ð¤·¤¿Éä¹æ²½

If your perl supports I<PerlIO> (which is the default), you can use a PerlIO layer to decode
and encode directly via a filehandle.  The following two examples
are totally identical in their functionality.

¤ª»È¤¤¤Î perl ¤¬ ''[[PerlIO]]'' ¤ËÂÐ±þ¤·¤Æ¤¤¤ì¤Ð 
(´ûÄê¾õÂÖ¤Ç¤ÏÂÐ±þ¤·¤Æ¤¤¤Þ¤¹)¡¢ filehandle ¤«¤éÄ¾ÀÜÉü¹æ¤ä
Éä¹æ²½¤¹¤ë¤Î¤Ë PerlIO ÁØ¤ò»È¤¨¤Þ¤¹¡£¼¡¤Î2¤Ä¤ÎÎã¤Ïµ¡Ç½Åª¤Ë¤Ï
Á´¤¯Æ±Åù¤Ç¤¹¡£

  # via PerlIO
  open my $in,  "<:encoding(shiftjis)", $infile  or die;
  open my $out, ">:encoding(euc-jp)",   $outfile or die;
  while(<$in>){ print $out $_; }

  # via from_to
  open my $in,  "<", $infile  or die;
  open my $out, ">", $outfile or die;
  while(<$in>){
    from_to($_, "shiftjis", "euc-jp", 1);
    print $out $_;
  }

Unfortunately, it may be that encodings are PerlIO-savvy.  You can check
if your encoding is supported by PerlIO by calling the C<perlio_ok>
method.

À¸Áþ¡¢Éä¹æ²½¤Ï PerlIO ¤òÃÎ¤Ã¤Æ¤¤¤ë¤«¤â¤·¤ì¤Þ¤»¤ó¡£
¤¢¤ëÉä¹æ²½¤¬ PerlIO ¤ËÂÐ±þ¤·¤Æ¤¤¤ë¤«¤ò perlio_ok
method ¤ò¸Æ¤Ö¤³¤È¤Ç¸¡ºº½ÐÍè¤Þ¤¹¡£

  Encode::perlio_ok("hz");             # False  # µ¶
  find_encoding("euc-cn")->perlio_ok;  # True where PerlIO is available  # PerlIO ¤¬ÍøÍÑ²ÄÇ½¤Ê¤é¿¿

  use Encode qw(perlio_ok);            # exported upon request  # Í×µá¤Ë¤è¤êÍ¢½Ð
  perlio_ok("euc-jp")

Fortunately, all encodings that come with Encode core are PerlIO-savvy
except for hz and ISO-2022-kr.  For gory details, see L<Encode::Encoding> and L<Encode::PerlIO>.

¹¬¤¤¡¢ Encode ³Ë¤ÎÁ´¤Æ¤ÎÉä¹æ²½¤Ï hz ¤È iso-2022-kr
¤ò½ü¤¤¤Æ¤¹¤Ù¤Æ PerlIO ¤òÃÎ¤Ã¤Æ¤¤¤Þ¤¹¡£¾Ü¤·¤¯¤Ï
[[Encode::Encoding]] ¤È [[Encode::PerlIO]] ¤ò»²¾È¡£

**Handling Malformed Data ÉÔÀµ¤Ê¥Ç¡¼¥¿¤Î¼è¤ê°·¤¤

The I<CHECK> argument is used as follows.  When you omit it,
the behaviour is the same as if you had passed a value of 0 for
I<CHECK>.

CHECK °ú¿ô¤Ï¼¡¤Î¤è¤¦¤Ë»È¤¤¤Þ¤¹¡£¤³¤ì¤ò¾ÊÎ¬¤·¤¿¾ì¹ç¡¢
¤½¤ÎÆ°ºî¤Ï CHECK ¤Ë 0 ¤ÎÃÍ¤òÅÏ¤·¤¿»þ¤ÈÆ±¤¸¤Ë¤Ê¤ê¤Þ¤¹¡£

-I<CHECK> = Encode::FB_DEFAULT ( == 0)

If I<CHECK> is 0, (en|de)code will put a I<substitution character>
in place of a malformed character.  For UCM-based encodings,
E<lt>subcharE<gt> will be used.  For Unicode, the code point C<0xFFFD> is used.
If the data is supposed to be UTF-8, an optional lexical warning
(category utf8) is given.

CHECK ¤¬ 0 ¤Ê¤é¡¢ (en|de)code ¤ÏÉÔÀµ¤ÊÊ¸»ú¤Î¾ì½ê¤Ë
''ÂåÂØÊ¸»ú''¤òÁÞÆþ¤·¤Þ¤¹¡£´ð [[UCM]] Éä¹æ²½¤Ç¤Ï¡¢¡Ösubchar¡× 
¤¬»È¤ï¤ì¤Þ¤¹¡£ [[Unicode]] ¤Ç¤Ï¡¢[[Éä¹æ°ÌÃÖ]] 0xFFFD
¤¬»È¤ï¤ì¤Þ¤¹¡£¥Ç¡¼¥¿¤¬ UTF-8 ¤ÈÁÛÄê¤µ¤ì¤Æ¤¤¤ë¤Ê¤é¡¢
optional lexical ·Ù¹ð (Ê¬Îà utf8) ¤¬½Ð¤Þ¤¹¡£

-I<CHECK> = Encode::FB_CROAK ( == 1)

If I<CHECK> is 1, methods will die on error immediately with an error
message.  Therefore, when I<CHECK> is set to 1,  you should trap the
fatal error with eval{} unless you really want to let it die on error.

CHECK ¤¬ 1 ¤Ê¤é¡¢ method ¤Ï¥¨¥é¡¼¡¦¥á¥Ã¥»¡¼¥¸¤È¶¦¤ËÂ¨ºÂ¤Ë
»à¤Ë¤Þ¤¹¡£½¾¤Ã¤Æ¡¢ CHECK ¤¬ 1 ¤ËÀßÄê¤µ¤ì¤Æ¤¤¤ë¤Ê¤é¡¢
ËÜÅö¤Ë¥¨¥é¡¼¤È¶¦¤Ë»à¤ó¤ÇÍß¤·¤¤¤Î¤Ç¤Ê¤¤¸Â¤ê eval{}
¤ÇÃ×Ì¿Åª¥¨¥é¡¼¤òÆ¨¤ì¤ë¤Î¤¬ÎÉ¤¤¤Ç¤·¤ç¤¦¡£

-I<CHECK> = Encode::FB_QUIET

If I<CHECK> is set to Encode::FB_QUIET, (en|de)code will immediately
return the portion of the data that has been processed so far when
an error occurs. The data argument will be overwritten with
everything after that point (that is, the unprocessed part of data).
This is handy when you have to call decode repeatedly in the case
where your source data may contain partial multi-byte character
sequences, for example because you are reading with a fixed-width
buffer. Here is some sample code that does exactly this:

CHECK ¤¬ Encode::FB_QUIET ¤ËÀßÄê¤µ¤ì¤Æ¤¤¤ë¤È¡¢ (en|de)code
¤Ï¥¨¥é¡¼¤¬µ¯¤³¤Ã¤¿»þ¤ËÂ¨ºÂ¤Ë¥Ç¡¼¥¿¤Î½èÍýºÑ¤ß¤ÎÉôÊ¬¤òÊÖ¤·¤Þ¤¹¡£
¥Ç¡¼¥¿°ú¿ô¤Ï¤½¤Î°ÌÃÖ°Ê¹ßÁ´ÂÎ (¤Ä¤Þ¤ê¥Ç¡¼¥¿¤Î½èÍý¤Ç¤­¤Ê¤«¤Ã¤¿ÉôÊ¬)
¤Ç¾å½ñ¤­¤·¤Þ¤¹¡£
¤³¤ì¤ÏÎã¤¨¤Ð¸ÇÄêÄ¹¥Ð¥Ã¥Õ¥¡¡¼¤òÆÉ¤ó¤Ç¤¤¤ë»þ¤ÎÍÍ¤Ë
¸µ¥Ç¡¼¥¿¤¬Ê¬³ä¤µ¤ì¤¿Â¿¥Ð¥¤¥ÈÊ¸»úÎó¤Ç¹½À®¤µ¤ì¤Æ¤¤¤Æ
decode ¤ò·«¤êÊÖ¤·¸Æ¤Ð¤Ê¤¤¤È¤¤¤±¤Ê¤¤»þ¤ËÊØÍø¤Ç¤¹¡£
¤³¤ÎÎã¤ò¼¡¤Ë¼¨¤·¤Þ¤¹¡£

[INS[
[2] ÌõÃí: Ê¬³ä¤µ¤ì¤¿Â¿¥Ð¥¤¥ÈÊ¸»ú¤È¤Ï¡¢¤¿¤È¤¨¤Ð[[¥·¥Õ¥ÈJIS]]¤ÎÃ»¤¤Ê¸»úÎó¡Ö¤¢¡¢¤¤¡×
¤ò3¥ª¥¯¥Æ¥Ã¥ÈËè¤ËÊ¬³ä¤¹¤ë¤È¡¢ (SJIS ¤Ç¤Ï²¾Ì¾1Ê¸»ú = 2¥Ð¥¤¥È¤Ê¤Î¤Ç)
¿¿¤óÃæ¤Î¡Ö¡¢¡× = [CODE[0x8141]] ¤¬ [CODE[0x81]] ¤È [CODE[0x41]]
¤Ç¤Ð¤é¤Ð¤é¤Ë¤Ê¤Ã¤Æ¤·¤Þ¤¤¤Þ¤¹¡£

¤³¤¦¤¤¤¦ÌµÃã¶ìÃã¤Ê¤³¤È¤¹¤ë¼ÂÁõ¤ä»ÅÍÍ¤Ã¤ÆÂ¿¤¤¤ó¤Ç¤·¤ç¤¦¤«¤Í?
(±Ñ¸ìÈÇ¤Î¥×¥í¥°¥é¥à¤òÆüËÜ¸ì M$-DOS/Windows ¤Ë°Ü¿¢¤·¤¿¤â¤Î¤È¤«¤Ç¤¢¤ê¤½¤¦¤«¤â¡£)
[[MIME¤ÎparameterÃÍ³ÈÄ¥]]¤Ï³Î¤«¤Ë¤³¤ì¤Ç¤¹¤±¤É¡¢¤³¤ì¤ÏÈæ³ÓÅªÃ»¤¤Ê¸»úÎóÂÐ¾Ý¤À¤È»×¤¦¤«¤é¡¢Í½¤áÁ´Éô¹çÂÎ¤µ¤»¤Æ¤«¤é
decode ¤¹¤ëÊý¤¬³Ú¤À¤í¤¦¤·¡£
]INS]

  my $data = '';
  my $utf8 = '';
  while(defined(read $fh, $buffer, 256)){
    # buffer may end in a partial character so we append
    [INS[# ¥Ð¥Ã¥Õ¥¡¡¼¤ÏÊ¬³ä¤µ¤ì¤¿Ê¸»ú¤Ç½ª¤ï¤ë¤«¤â¤·¤ì¤Ê¤¤¤Î¤Ç¤¯¤Ã¤Ä¤±¤ë]]
    $data .= $buffer;
    $utf8 .= decode($encoding, $data, Encode::FB_QUIET);
    # $data now contains the unprocessed partial character
    [INS[# $data ¤Ï¤³¤³¤ÇÌ¤½èÍý¤ÎÊ¬³ä¤µ¤ì¤¿Ê¸»ú¤ò´Þ¤ó¤Ç¤¤¤Þ¤¹¡£]]
  }

-''CHECK'' = Encode::FB_WARN

This is the same as above, except that it warns on error.  Handy when
you are debugging the mode above.

¤³¤ì¤Ï¾å¤ÈÆ±¤¸¤Ç¤¹¤¬¡¢¥¨¥é¡¼·Ù¹ð¤·¤Þ¤¹¡£¾å¤Î¥â¡¼¥É¤Î¥Ð¥°¼è¤ê¤Ë
ÊØÍø¤Ç¤¹¡£

-perlqq mode (I<CHECK> = Encode::FB_PERLQQ)
-HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)
-XML charref mode (I<CHECK> = Encode::FB_XMLCREF)

For encodings that are implemented by Encode::XS, CHECK ==
Encode::FB_PERLQQ turns (en|de)code into C<perlqq> fallback mode.

Encode::XS ¤Ç¼ÂÁõ¤µ¤ì¤¿Éä¹æ²½¤Ç¡¢ CHECK == Encode::FB_PERLQQ
¤Î»þ (en|de)code ¤Ï perlqq fallback ¥â¡¼¥É¤Ë¤Ê¤ê¤Þ¤¹¡£

When you decode, C<\xI<HH>> will be inserted for a malformed character,
where I<HH> is the hex representation of the octet  that could not be
decoded to utf8.  And when you encode, C<\x{I<HHHH>}> will be inserted,
where I<HHHH> is the Unicode ID of the character that cannot be found
in the character repertoire of the encoding.

decode ¤Î»þ¡¢ \x''HH'' ¤¬ÉÔÀµÊ¸»ú¤Î½ê¤ËÁÞÆþ¤µ¤ì¤Þ¤¹¡£¤³¤³¤Ç ''HH''
¤Ï utf8 ¤ËÉü¹æ½ÐÍè¤Ê¤«¤Ã¤¿¥ª¥¯¥Æ¥Ã¥È¤Î16¿ÊÉ½¸½¤Ç¤¹¡£¤Þ¤¿
Éä¹æ²½¤Î»þ¡¢ \x{''HHHH''} ¤¬ÁÞÆþ¤µ¤ì¤Þ¤¹¡£¤³¤³¤Ç ''HHHH''
¤ÏÉä¹æ²½¤ÎÊ¸»ú¥ì¥Ñ¡¼¥È¥ê¤Ë¸«¤Ä¤«¤é¤Ê¤«¤Ã¤¿Ê¸»ú¤Î Unicode ID
¤Ç¤¹¡£

HTML/XML character reference modes are about the same, in place of
C<\x{I<HHHH>}>, HTML uses C<&#I<NNNN>>; where I<NNNN> is a decimal digit and
XML uses C<&#xI<HHHH>>; where I<HHHH> is the hexadecimal digit.

[[HTML]]/[[XML]] Ê¸»ú»²¾È¥â¡¼¥É¤Ï¾å¤ÈÆ±¤¸¤Ç¤¹¤¬¡¢ \x{''HHHH''}
¤Î½ê¤Ç HTML ¤Ç¤Ï &#''NNNN'';, XML ¤Ç¤Ï &#x''HHHH'';
¤ò»È¤¤¤Þ¤¹¡£¤³¤³¤Ç ''NNNN'' ¤Ï10¿Ê¿ô»ú¤Ç ''HHHH'' ¤Ï16¿Ê¿ô»ú¤Ç¤¹¡£

-The bitmask

These modes are actually set via a bitmask.  Here is how the FB_XX
constants are laid out.  You can import the FB_XX constants via
C<use Encode qw(:fallbacks)>; you can import the generic bitmask
constants via C<use Encode qw(:fallback_all)>.

¤³¤ì¤é¤Î¥â¡¼¥É¤Ï¼ÂºÝ¤Ë¤Ï bitmask ¤ÇÀßÄê¤·¤Þ¤¹¡£
¤³¤³¤Ë FB_XX Äê¿ô¤¬¤É¤¦ÇÛÃÖ¤·¤Æ¤¢¤ë¤«¤ò¼¨¤·¤Þ¤¹¡£ FB_XX
Äê¿ô¤Ï use Encode qw(:fallbacks) ¤ÇÍ¢Æþ¤Ç¤­¤Þ¤¹¡£
°ìÈÌ bitmask Äê¿ô¤Ï use Encode qw(:fallback_all) ¤ÇÍ¢Æþ¤Ç¤­¤Þ¤¹¡£

,             ,      ,FB_DEFAULT,FB_CROAK,FB_QUIET,FB_WARN,FB_PERLQQ
,DIE_ON_ERR   ,0x0001,          ,  X
,WARN_ON_ERR  ,0x0002,          ,                 ,  X
,RETURN_ON_ERR,0x0004,          ,        ,  X     ,  X
,LEAVE_SRC    ,0x0008,
,PERLQQ       ,0x0100,          ,        ,        ,       ,   X
,HTMLCREF     ,0x0200,
,XMLCREF      ,0x0400,

**Unimplemented fallback schemes Ì¤¼ÂÁõ fallback Êý¼°

In the future, you will be able to use a code reference to a callback
function for the value of I<CHECK> but its API is still undecided.

¾­Íè¡¢ callback ´Ø¿ô¤Î code »²¾È¤ò CHECK ¤ÎÃÍ¤Ë»È¤¨¤ë¤è¤¦¤Ë
¤Ê¤ë¤«¤â¤·¤ì¤Þ¤»¤ó¤¬¡¢¤½¤Î API ¤Ï¤Þ¤À·è¤Þ¤Ã¤Æ¤¤¤Þ¤»¤ó¡£

The fallback scheme does not work on EBCDIC platforms.

fallback Êý¼°¤Ï EBCDIC ´Ä¶­¤Ç¤ÏÆ°ºî¤·¤Þ¤»¤ó¡£

**Defining Encodings Éä¹æ²½¤ÎÄêµÁ

To define a new encoding, use:

¿·¤·¤¤Éä¹æ²½¤òÄêµÁ¤¹¤ë¤Ë¤Ï¡¢¤³¤¦¤·¤Þ¤¹¡£

    use Encode qw(define_encoding);
    define_encoding($object, 'canonicalName' [, alias...]);

I<canonicalName> will be associated with I<$object>.  The object
should provide the interface described in L<Encode::Encoding>.
If more than two arguments are provided then additional
arguments are taken as aliases for I<$object>.

canonicalName (Àµµ¬Ì¾)¤Ï $object ¤È´ØÏ¢ÉÕ¤±¤é¤ì¤Þ¤¹¡£
object ¤Ï [[Encode::Encoding]] ¤ÇÀâÌÀ¤¹¤ë³¦ÌÌ¤òÄó¶¡
¤¹¤ë¤Î¤¬¤è¤¤¤Ç¤¹¡£2¤Ä°Ê¾å¤Î°ú¿ô¤¬¤¢¤ë¤È¤­¤Ï
ÄÉ²Ã¤Î°ú¿ô¤Ï $object ¤ÎÊÌÌ¾¤È¤ß¤Ê¤·¤Þ¤¹¡£

See L<Encode::Encoding> for more details.

**The UTF-8 flag UTF-8 ´ú

Before the introduction of utf8 support in perl, The C<eq> operator
just compared the strings represented by two scalars. Beginning with
perl 5.8, C<eq> compares two strings with simultaneous consideration
of I<the utf8 flag>. To explain why we made it so, I will quote page
402 of C<Programming Perl, 3rd ed.>

utf8 ÂÐ±þ¤¬ perl ¤ËÆþ¤ëÁ°¤Ï¡¢ eq ±é»»»Ò¤ÏÃ±¤Ë2¤Ä¤Î¥¹¥«¥é¡¼¤Ç
É½¤µ¤ì¤ëÊ¸»úÎó¤òÈæ³Ó¤·¤Æ¤¤¤Þ¤·¤¿¡£ perl 5.8 ¤«¤é¤Ï
eq ¤Ï2¤Ä¤ÎÊ¸»úÎó¤ò ''utf8 ´ú''¤â¹ÍÎ¸¤ËÆþ¤ì¤ÆÈæ³Ó¤·¤Þ¤¹¡£
¤É¤¦¤·¤Æ¤½¤¦¤·¤¿¤«¤Ë¤Ä¤¤¤Æ¤Ï¡¢ Programming Perl Âè3ÈÇ¤Î
402ÊÇ¤ò°úÍÑ¤·¤Þ¤¹¡£

-Goal #1: ÌÜÉ¸1

Old byte-oriented programs should not spontaneously break on the old
byte-oriented data they used to work on.

¸Å¤¤¥Ð¥¤¥È»Ø¸þ¥×¥í¥°¥é¥à¤¬¤½¤Î°·¤¦¸Å¤¤¥Ð¥¤¥È»Ø¸þ¥Ç¡¼¥¿¤ò
¾¡¼ê¤Ë²õ¤µ¤Ê¤¤¤Î¤¬¤è¤¤¡£

-Goal #2: ÌÜÉ¸2

Old byte-oriented programs should magically start working on the new
character-oriented data when appropriate.

¸Å¤¤¥Ð¥¤¥È»Ø¸þ¥×¥í¥°¥é¥à¤ÏÅ¬Åö¤Ê¤éËâÅª¤Ë¤â¿·¤·¤¤Ê¸»ú»Ø¸þ¥Ç¡¼¥¿
¤ò°·¤¨¤ë¤Î¤¬ÎÉ¤¤¡£

-Goal #3: ÌÜÉ¸3

Programs should run just as fast in the new character-oriented mode
as in the old byte-oriented mode.

¥×¥í¥°¥é¥à¤Ï¸Å¤¤¥Ð¥¤¥È»Ø¸þ¥â¡¼¥É¤ÈÅùÂ®¤Ç¿·¤·¤¤Ê¸»ú»Ü¹Ô¥â¡¼¥É¤Ç¤â
Æ°¤¯¤Î¤¬ÎÉ¤¤¡£

-Goal #4: ÌÜÉ¸4

Perl should remain one language, rather than forking into a
byte-oriented Perl and a character-oriented Perl.

Perl ¤Ï1¤Ä¤Î¸À¸ì¤Ç¤¢¤êÂ³¤±¤ë¤Î¤¬ÎÉ¤¤¡£¥Ð¥¤¥È»Ø¸þ Perl
¤ÈÊ¸»ú»Ø¸þ Perl ¤ËÊ¬Îö¤¹¤ë¤Î¤è¤ê¡£

Back when C<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0
was born and many features documented in the book remained
unimplemented for a long time.  Perl 5.8 corrected this and the introduction
of the UTF-8 flag is one of them.  You can think of this perl notion as of a
byte-oriented mode (utf8 flag off) and a character-oriented mode (utf8
flag on).

Programming Perl Âè3ÈÇ¤Î½ñ¤«¤ì¤¿»þ¤ËÌá¤ë¤È¡¢
Perl 5.6.0 ¤µ¤¨½Ð¤Æ¤ª¤é¤º¡¢¤³¤ÎËÜ¤Ë½ñ¤«¤ì¤¿Â¿¤¯¤Îµ¡Ç½¤Ï
Ä¹¤é¤¯Ì¤¼ÂÁõ¤Î¤Þ¤Þ¤Ç¤·¤¿¡£ Perl 5.8 ¤Ï¤³¤ì¤òÂÇ³«¤¹¤ë¤â¤Î¤Ç
UTF-8 ´ú¤ÎÆ³Æþ¤Ï¤½¤Î°ì¤Ä¤Ç¤¹¡£¤³¤Î perl ¤Î´ÑÇ°¤Ï
¥Ð¥¤¥È»Ø¸þ¥â¡¼¥É (utf8 ´ú²¼¤¬¤ê) ¤ÈÊ¸»ú»Ø¸þ¥â¡¼¥É
(utf8 ´ú¾å¤¬¤ê) ¤ÈÂª¤¨¤ë¤³¤È¤¬½ÐÍè¤Þ¤¹¡£

Here is how Encode takes care of the utf8 flag.

¤³¤³¤Ë Encode ¤¬ utf8 ´ú¤ò¤É¤¦°·¤¦¤«¤ò¼¨¤·¤Þ¤¹¡£

-When you encode, the resulting utf8 flag is always off.
Éä¹æ²½¤Î»þ¡¢·ë²Ì¤Ç¤Ï utf8 ´ú¤Ï¾ï¤Ë²¼¤¬¤Ã¤Æ¤Þ¤¹¡£
-When you decode, the resulting utf8 flag is on unless you can
unambiguously represent data.  Here is the definition of
dis-ambiguity.
Éü¹æ¤Î»þ¡¢·ë²Ì¤Ç¤Ï utf8 ¤Ï¾ï¤Ë¾å¤¬¤Ã¤Æ¤Þ¤¹¡£Ã¢¤·Û£ËæÌµ¤¯
¥Ç¡¼¥¿¤òÉ½¸½½ÐÍè¤ë¾ì¹ç¤ò½ü¤­¤Þ¤¹¡£Û£Ëæ¤Ç¤Ê¤¤¤³¤È¤ÎÄêµÁ¤Ï
¼¡¤Ë¼¨¤·¤Þ¤¹¡£

After C<$utf8 = decode('foo', $octet);>, ¤Î¸å¡¢

,When $octet is...,$octet ¤Ï   ,The utf8 flag in $utf8 is
,                 ,            ,$utf8 ¤Î  utf8 ´ú¤Ï
,In ASCII only (or EBCDIC only),ASCII ¤Î¤ß (Ëô¤Ï EBCDIC ¤Î¤ß),OFF
,In ISO-8859-1                 ,,ON
,In any other Encoding        ,¤½¤ÎÂ¾¤ÎÉä¹æ²½,ON

As you see, there is one exception, In ASCII.  That way you can assue
Goal #1.  And with Encode Goal #2 is assumed but you still have to be
careful in such cases mentioned in B<CAVEAT> paragraphs.

¤´Í÷¤ÎÄÌ¤ê¡¢Îã³°¤Ï ASCII ¤Ç¤¹¡£¤³¤ì¤Ë¤è¤êÌÜÉ¸ 1 ¤¬Ã£À®¤µ¤ì¤Þ¤¹¡£
Éä¹æ²½ÌÜÉ¸ 2 ¤âÃ£À®¤µ¤ì¤Þ¤¹¤¬¡¢°ÍÁ³''·Ù¹ð''ÃÊÍî¤Ç½Ò¤Ù¤¿
¾ì¹ç¤Ë¤Ä¤¤¤ÆÃí°Õ¤¹¤ëÉ¬Í×¤¬¤¢¤ê¤Þ¤¹¡£

This utf8 flag is not visible in perl scripts, exactly for the same
reason you cannot (or you I<don't have to>) see if a scalar contains a
string, integer, or floating point number.   But you can still peek
and poke these if you will.  See the section below.

utf8 ´ú¤Ï¡¢¥¹¥«¥é¡¼¤¬Ê¸»úÎó¤Ç¤¢¤ë¤«À°¿ô¤Ç¤¢¤ë¤«ÉâÆ°¾®¿ôÅÀÃÍ
¤Ç¤¢¤ë¤«¸«¤¨¤Ê¤¤ (¤¢¤ë¤¤¤Ï''¸«¤ëÉ¬Í×¤¬Ìµ¤¤'') ¤Î¤ÈÆ±ÍÍ¤Ë
perl script ¤Ë¤Ï¸«¤¨¤Þ¤»¤ó¡£Ã¢¤·½ü¤¤¤¿¤êÆÍ¤Ã¤Ä¤¤¤¿¤ê¤Ï
½ÐÍè¤Þ¤¹¡£²¼¤Î¾Ï¤ò¤´Í÷¤¢¤ì¡£

***Messing with Perl's Internals Perl ÆâÉô¤ò¤¤¤¸¤¯¤ë

The following API uses parts of Perl's internals in the current
implementation.  As such, they are efficient but may change.

¼¡¤Î API ¤Ï¸½ºß¤Î¼ÂÁõ¤Ç¤Î Perl ÆâÉô¤ÎÉôÊ¬¤ò»È¤¤¤Þ¤¹¡£
¤Ç¤¹¤«¤é¡¢Í­Ç½¤Ç¤¹¤¬ÊÑ¹¹¤µ¤ì¤ë²ÄÇ½À­¤â¤¢¤ê¤Þ¤¹¡£

-is_utf8(STRING [, CHECK])

[INTERNAL] Tests whether the UTF-8 flag is turned on in the STRING.
If CHECK is true, also checks the data in STRING for being well-formed
UTF-8.  Returns true if successful, false otherwise.

(''ÆâÉô'') STRING ¤Ç UTF-8 ´ú¤¬ÍÈ¤¬¤Ã¤Æ¤¤¤ë¤«¤ò»î¸³¤·¤Þ¤¹¡£
CHECK ¤¬¿¿¤Ê¤é¡¢ STRING ¤¬[[À°·Á¼°]] UTF-8 ¤Ç¤¢¤ë¤«¤â
¸¡ºº¤·¤Þ¤¹¡£À®¸ù¤Ê¤é¿¿¤òÊÖ¤·¡¢¤½¤¦¤Ç¤Ê¤±¤ì¤Ðµ¶¤òÊÖ¤·¤Þ¤¹¡£

-_utf8_on(STRING)

[INTERNAL] Turns on the UTF-8 flag in STRING.  The data in STRING is
B<not> checked for being well-formed UTF-8.  Do not use unless you
B<know> that the STRING is well-formed UTF-8.  Returns the previous
state of the UTF-8 flag (so please don't treat the return value as
indicating success or failure), or C<undef> if STRING is not a string.

(''ÆâÉô'') STRING ¤Î UTF-8 ´ú¤òÍÈ¤²¤Þ¤¹¡£ STRING
Ãæ¤Î¥Ç¡¼¥¿¤¬À°·Á¼° UTF-8 ¤«¤Ï¸¡ºº'''¤·¤Þ¤»¤ó'''¡£ STRING
¤¬À°·Á¼° UTF-8 ¤Ç¤¢¤ë¤È'''Ê¬¤«¤Ã¤Æ¤¤¤ë'''¾ì¹ç¤ò½ü¤¤¤Æ
»È¤Ã¤Æ¤Ï¤¤¤±¤Þ¤»¤ó¡£ UTF-8 ´ú¤Î°ÊÁ°¤Î¾õÂÖ¤òÊÖ¤¹
(¤Î¤ÇÀ®¸ù¤·¤¿¤«¼ºÇÔ¤·¤¿¤«¤ò¼¨¤¹¤Î¤ËÊÖ¤·ÃÍ¤ò»È¤ï¤Ê¤¤¤Ç²¼¤µ¤¤¡£)
¤«¡¢ STRING ¤¬Ê¸»úÎó¤Ç¤Ê¤¤»þ¤Ë¤Ï undef ¤òÊÖ¤·¤Þ¤¹¡£

-_utf8_off(STRING)

[INTERNAL] Turns off the UTF-8 flag in STRING.  Do not use frivolously.
Returns the previous state of the UTF-8 flag (so please don't treat the
return value as indicating success or failure), or C<undef> if STRING is
not a string.

(''ÆâÉô'') STRING ¤Î UTF-8 ´ú¤ò¹ß¤í¤·¤Þ¤¹¡£·ÚÎ¨¤Ë»È¤ï¤Ê¤¤¤Ç²¼¤µ¤¤¡£
UTF-8 ´ú¤Î°ÊÁ°¤Î¾õÂÖ¤òÊÖ¤¹
(¤Î¤ÇÀ®¸ù¤·¤¿¤«¼ºÇÔ¤·¤¿¤«¤ò¼¨¤¹¤Î¤ËÊÖ¤·ÃÍ¤ò»È¤ï¤Ê¤¤¤Ç²¼¤µ¤¤¡£)
¤«¡¢ STRING ¤¬Ê¸»úÎó¤Ç¤Ê¤¤»þ¤Ë¤Ï undef ¤òÊÖ¤·¤Þ¤¹¡£

**SEE ALSO

[[Encode::Encoding]],
[[Encode::Supported]],
[[Encode::PerlIO]],
[[encoding]],
[[perlebcdic]],
[[perlfunc]]/open,
[[perlunicode]],
[[utf8]],
the Perl Unicode Mailing List <MAIL:perl-unicode@@perl.org>

**MAINTAINER

This project was originated by Nick Ing-Simmons and later maintained
by Dan Kogai <MAIL:dankogai@@dan.co.jp>.  See AUTHORS for a full
list of people involved.  For any questions, use
<MAIL:perl-unicode@@perl.org> so we can all share.

¤³¤Î·×²è¤Ï Nick Ing-Simmons ¤Ë¤è¤ê»Ï¤á¤é¤ì¡¢¸å¤Ë
¾®»ôÃÆ¤Ë¤è¤ê´ÉÍý¤µ¤ì¤Æ¤¤¤Þ¤¹¡£´Ø·¸¼Ô¤Î´°Á´¤ÊÉ½¤Ï
AUTHORS ¤ò¤´Í÷²¼¤µ¤¤¡£µ¿ÌäÅÀ¤¬¤¢¤ì¤Ð perl-unicode
¤ò»È¤Ã¤Æ²¼¤µ¤¤¡£¤½¤¦¤¹¤ì¤Ð²æ¡¹³§¤¬¶¦Í­¤Ç¤­¤Þ¤¹¡£

**¤³¤ÎÉôÊ¬¤Î License

[[perl¤ÈÆ±¤¸¥é¥¤¥»¥ó¥¹]]¡£
*Q&A
**Wide character ¤È¤·¤«¤é¤ì¤Æ»à¤Ì

[9] '''¼ÁÌä''': >Wide character in subroutine entry at /path/to/perl/lib/Encode.pm line 154.

¤È¸À¤ï¤ì¤Æ»à¤Ë¤Þ¤¹¡£ Encode ¤Î bug ¤Ç¤¹¤«?

[10] ¤¤¤¨¡¢¤ª¤½¤é¤¯»ÅÍÍ¤Ç¤¹¡£

¤³¤Î¥¨¥é¡¼¤¬½Ð¤Æ»à¤Ì¸¶°ø¤Ï¡¢ [CODE[decode]] ¤ÎÆþÎÏÊ¸»úÎó¤¬ utf8 (Wide character)
·Á¼°¤Ë¤Ê¤Ã¤Æ¤¤¤ë¡¢¤Ä¤Þ¤ê [CODE[U+0100]] °Ê¾å¤ÎÊ¸»ú¤¬´Þ¤Þ¤ì¤Æ¤¤¤ë¤³¤È¤Ë¤¢¤ê¤Þ¤¹¡£

[CODE[Encode::decode]] ¤Ï¼ÂºÝ¤Ë¤Ï [CODE[Encode::find_encoding ($encoding)->decode ($string)]]
¤ò¤·¤Æ¤¤¤Þ¤¹¤¬¡¢¤³¤Î¸åÈ¾¤Î [CODE[decode]] ¤¬ [[carp]]
¤·¤Æ¤¤¤ë¤Î¤Ç¡¢¥¨¥é¡¼½ÐÎÏ¤Ë¤Ï Encode ¥â¥¸¥å¡¼¥ëÆâ¤Ç»à¤ó¤À¤È½Ð¤ë¤Î¤Ç¤¹¡£

[[#form:'%radio(id=>type,label=>²óÅú,value=>false,default); or %radio(id=>type,label=>ÄÉ²Ã¼ÁÌä,value=>true);: %text(label=>"Ì¾Á° : ",id=>name,size=>"9.5"); %text(label=>"¥á¥¤¥ë: ",id=>mail,size=>9.5);%n;%textarea(id=>a,size=>20);':'[%index;] %iif(source=>type,true=>"\'\'\'¼ÁÌä\'\'\' ",false=>"");\'\'%name;\'\'%text(source=>mail,prefix=>" [",suffix=>"]"); [WEAK[%date;]]: %text(source=>a);%n;':'%require(a);']]
[[#form(newq):'':'**%text(source=>qsum);%n;%n;[%index;] \'\'\'¼ÁÌä\'\'\' (\'\'%name;\'\'%text(source=>mail,prefix=>" [",suffix=>"]"); [WEAK[%date;]]): %text(source=>q);%n;%n;[[#form:\'%percent;radio(id=>type,label=>²óÅú,value=>false,default); or %percent;radio(id=>type,label=>ÄÉ²Ã¼ÁÌä,value=>true);: %percent;text(label=>"Ì¾Á° : ",id=>name,size=>"9.5"); %percent;text(label=>"¥á¥¤¥ë: ",id=>mail,size=>9.5);%percent;n;%percent;textarea(id=>a,size=>20);\':\'[%percent;index;] %percent;iif(source=>type,true=>"\\\'\\\'\\\'¼ÁÌä\\\'\\\'\\\' ",false=>"");\\\'\\\'%percent;name;\\\'\\\'%percent;text(source=>mail,prefix=>" [",suffix=>"]"); [WEAK[%percent;date;]]: %percent;text(source=>a);%percent;n;\':\'%percent;require(a);\']]']]
**¿·¤·¤¤¼ÁÌä¤ÎÄÉ²Ã
[[#form:'%text(id=>qsum,label=>¼ÁÌäÍ×Ìó,size=>10); %text(label=>"Ì¾Á° : ",id=>name,size=>"9.5"); %text(label=>"¥á¥¤¥ë: ",id=>mail,size=>9.5);%n;%textarea(id=>q,label=>¼ÁÌä,size=>20);':'':'%output(id=>newq);']]
*¥á¥â
- [1] [[°ìÈÌÆ°»ì]]¤Î ''encode'' ¤Î¤³¤È¤Ï¡¢[[Éä¹æ²½]]¤ò»²¾È¤·¤Æ²¼¤µ¤¤¡£
- [3] [WEAK[2002-12-13 (¶â) 19:24]] ''[[Ì¾Ìµ¤·¤µ¤ó]]'': ´ö¤Ä¤«¸íÌõ¤¬¤¢¤Ã¤¿¤Î¤Ç½¤Àµ¤·¤Þ¤·¤¿¡£
- [4] fallback ¤Ï³¦ÌÌ¤È¤·¤Æ¤Ò¤É¤¤¤È»×¤¤¤Þ¤»¤ó? ¿ôÃÍÄê¿ô¤Î¥Ó¥Ã¥È¥Þ¥¹¥¯¤â perl Åª¤¸¤ã¤Ê¤¤¤È»×¤¦¤·¡£
- [5] [CODE(perl)[FB_QUIET]] ¤È¤«¾å¤ÎÊý¤Î¤Ï [CODE(perl)[decode]] ¤Ç»È¤ï¤ì¤ë¤³¤È¤òÁÛÄê¤·¤Æ¤¤¤ë¤è¤¦¤Ê´¶¤¸¤Ç¤¹¤Í¤§¡£ [CODE(perl)[encode]] ¤Ë»È¤Ã¤Æ¤â¤¤¤¤¤ó¤Ç¤·¤ç¤¦¤«?
- [6] >>5 »È¤Ã¤Æ¤â¤¤¤¤¤È¤·¤Æ¡¢¾õÂÖ¤ò»ý¤Á¡¢¤·¤«¤â½ªÎ»¾õÂÖ¤¬µ¬Äê¤µ¤ì¤Æ¤¤¤ë[[Éä¹æ]]¤Ç¤Î[[Éä¹æ²½]]¤Ç¤½¤Î¾ì¹ç¤É¤¦¤·¤¿¤é¤¤¤¤¤ó¤Ç¤·¤ç¤¦? (¤¿¤È¤¨¤Ð [[ISO-2022-JP]] ½ÐÎÏ¤Ç¡¢ ISO-2022-JP ¤ÇÉ½¸½½ÐÍè¤Ê¤¤Ê¸»ú¤¬¤¢¤ê¡¢ [CODE(perl)[FB_QUIET]] ¤¬»ØÄê¤µ¤ì¤Æ¤¤¤ë»þ¤Ë¡¢¤·¤«¤â [[JISX0208]] ¤¬[[»Ø¼¨]]¤µ¤ì¤Æ¤¤¤ë¾õÂÖ¤Ç¤¢¤Ã¤¿¤È¤·¤Æ¡¢ [[ASCII]] ¤ËÌá¤ë [CODE[ESC 02/08 04/02]] ¤ò½ÐÎÏ¤·¤Æ¤«¤é½ª¤ï¤ë¤Î¤«¡¢¤·¤Ê¤¤¤Ç½ª¤ï¤ë¤Î¤«¡£)
- [7] [CODE(perl)[Encode::FB_QUIET]] ¤ÎÎã¤Î script ¤Ã¤ÆËÜÅö¤Ëµ¡Ç½¤¹¤ë¤Î¤À¤í¤¦¤«? [CODE(perl)[Encode::decode]] ¤Ç¤Ï¤Ê¤¯ [CODE(perl)[Encode::find_encoding]] ¤ò¸Æ¤Ð¤Ê¤¤¤È¤¤¤±¤Ê¤¤¤è¤¦¤Ê¡£
- [8] ÀâÌÀ¤Î·ç¤±¤Æ¤¤¤ë [CODE(perl)[Encode::LEAVE_SRC]] ¤Ï¡¢ [CODE[encode.h]] ¤ÎÃí¼á¤Ë¤è¤ë¤È [CODE[$src updated unless set]] ¤Ç¤¹¡£
- [11] >>2 ¤³¤ì¤¬Æþ¤Ã¤Æ¤¤¤ë¤Î¤Ï¡¢ [[PerlIO]] ¤Ç buffering ¤·¤Ä¤ÄÆÉ¤ß¹þ¤à¤È¤­¤ËÅÓÃæ¤ÇÀÚ¤é¤ì¤ëÂÐºö¤Ê¤ó¤À¤½¤¦¤Ê¡£ <IW:JcodeML:542> »²¾È¡£
@


1.1
log
@auto-commited
@
text
@@

