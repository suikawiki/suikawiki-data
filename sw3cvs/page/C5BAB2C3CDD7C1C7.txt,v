head	1.3;
access;
symbols
	suikawiki3-final:1.3
	before-db-leaffile:1.2
	after-upgrade-to-suikawiki-3:1.2
	before-fork-suikawiki3:1.2
	after-restore-20040122:1.2;
locks; strict;
comment	@# @;
expand	@b@;


1.3
date	2004.05.03.02.03.35;	author wakaba;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.03.02.02.41;	author wakaba;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.27.02.03.13;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.3
log
@auto-committed
@
text
@#?SuikaWiki/0.9

[1] 
> 
:添加要素 (inclusions):
[[適用モデル]]が許していなくても、[[要素]]又はその[[部分要素]]の[[内容]]中のどこにでも許されている要素。 ([[JIS X 4151]]‐1992 3. (185))


[2] 例えば、[[内容モデル]]が [SAMP(SGML)[(foo|bar) +(baz)]] だと、本来 [CODE(SGML)[baz]] 要素は使えないはずなのですが、添加要素として敢えて示されているので、使えることになります。 [WEAK[この例では普通に内容モデルに加えるのとさして変わりませんが、内容モデルがより複雑な場合や子要素の内容との絡みによって、添加要素の仕組みがあると便利な場面がままあります。ちなみに [[XML]] には添加要素の仕組みはありません。内容モデル定義の便利さよりも[[妥当性検証]]の容易さを優先させた結果です。]]

[3] [[WebSGML]] では、名前の代わりに [CODE(SGML)[#[[ALL]]]] (全要素型) や [CODE(SGML)[#[[IMPLICIT]]]] (暗黙宣言要素型) を使用できます。いずれも、 [CODE(SGML)[([VAR[e1]] | [VAR[e2]] |...| [VAR[e[VAR[n]]]])*]] と対象要素型を並べたのと同じ意味になります。 (K.4.11 参照。)

[4] 添加要素に含まれていても、[[除外要素]]になっていれば、そちらが優先されて結局使えません。

[5]
添加要素はその周辺の[[空白]]の扱いが他の要素と異なることがあります。
詳しくは [[SGML//空白]]を参照。


@


1.2
log
@auto-committed
@
text
@d1 19
a19 6
#?SuikaWiki/0.9

- [1] [[適用モデル]]が許していなくても、[[要素]]又はその[[部分要素]]の[[内容]]中のどこにでも許されている要素。 Inclusions。 ([[JISX4151]]‐1992 定義 (185))
- [2] 例えば、[[内容モデル]]が [SAMP(SGML)[(foo|bar) +(baz)]] だと、本来 [CODE(SGML)[baz]] 要素は使えないはずなのですが、添加要素として敢えて示されているので、使えることになります。 [WEAK[この例では普通に内容モデルに加えるのとさして変わりませんが、内容モデルがより複雑な場合や子要素の内容との絡みによって、添加要素の仕組みがあると便利な場面がままあります。ちなみに [[XML]] には添加要素の仕組みはありません。内容モデル定義の便利さよりも[[妥当性検証]]の容易さを優先させた結果です。]]
- [3] [[WebSGML]] では、名前の代わりに [CODE(SGML)[#[[ALL]]]] (全要素型) や [CODE(SGML)[#[[IMPLICIT]]]] (暗黙宣言要素型) を使用できます。いずれも、 [CODE(SGML)[([VAR[e1]] | [VAR[e2]] |...| [VAR[e[VAR[n]]]])*]] と対象要素型を並べたのと同じ意味になります。 (K.4.11 参照。)
- [4] 添加要素に含まれていても、[[除外要素]]になっていれば、そちらが優先されて結局使えません。
@


1.1
log
@auto-committed
@
text
@d5 2
@

