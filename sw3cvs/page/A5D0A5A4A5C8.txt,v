head	1.7;
access;
symbols
	suikawiki3-final:1.7
	before-db-leaffile:1.5
	after-upgrade-to-suikawiki-3:1.4
	before-fork-suikawiki3:1.4
	after-restore-20040122:1.4;
locks; strict;
comment	@# @;


1.7
date	2005.06.13.02.20.01;	author wakaba;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.08.02.09.13;	author wakaba;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.13.02.01.14;	author wakaba;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.13.02.01.47;	author wakaba;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.27.07.25.09;	author make;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.23.06.25.55;	author wakaba;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.22.06.24.14;	author wakaba;	state Exp;
branches;
next	;


desc
@@


1.7
log
@auto-committed
@
text
@
*単位
[1]
>
:[INS[[[JIS X 0211]]‐1994]] 4.2.10 バイト (byte):
一つの[[単位]]として取り扱う[[ビット]]列。

[5]
>
:4.2 バイト (byte):一つの[[単位]]として[[操作]]する[[ビット列]]。
各[[ビット]]は、0又は1の[[値]]をもつ。
[SRC[[[JIS X 0202]]:1998 4.]]

[3] ''バイト''と併用される倍数接頭辞には、幾つかの流儀があります。

一番よく使われているのは、 1 [[KB]] (キロ・バイト) = 1024 B = 2[SUP[10]] B
とする方法です。[[ビット]]の2進性を中心に考えると自然な方法です。

しかし、これは [[SI]] の流儀 ([[k]] (キロ) = 1000 = 10[SUP[3]])
とは一致しません。日常的 (10進的) 感覚からすると 1024
という数は中途半端な感じがしますし、計算も面倒です。
(例えば 100,000 バイトは 100 キロ・バイトでは''ありません''。)
この方法は[[ハード・ディスク]]の製品案内などでよく使われます。

この問題を解決するための幾つかの提案があります。
まず、 KB の K と [[kg]] の k (SI のキロ) を別のものとしてしまうというものです。
この流儀の人の中には、 KB を「ケー・バイト」, MB
を「エム・バイト」のように読むべきだと言う人もいます。
(但しこの考え方は古めのもので、現在では廃れた感があります。)

しかしこの方法には致命的な欠点があります。 K と k
は区別できても、それ以上の単位, M や G は区別できません。
SI が既に大文字ですし、 SI には [[m]] (ミリ) や [[g]]
(グラム) が存在しますから、どうにもなりません。

他の回避法として、バイト系の接頭辞に i をつける方法と、
接頭辞を二重にする方法があります。前者では KiB, MiB, GiB
([RUBYB[ギビ] [gibi]]・バイト)、後者では KKB ([RUBYB[大] [large]]キロ・
バイト), MMB, TTB のような単位になります。 

しかし、これらの回避法はいずれも普及したものではありません。
普及する見通しも今のところありません。
今後も 10[SUP[3]] 系と 2[SUP[10]] 系の単位による混乱は続くでしょう。

-''Large Disk HOWTO: 単位とサイズ'' <http://www.linux.or.jp/JF/JFdocs/Large-Disk-HOWTO-3.html>
[[#comment]]

** C において

[4]
> [[実行環境]]の[[基本文字集合]]の任意の要素を保持するために十分な大きさを持つ[[データ記憶域]]の[[単位]]。
[[オブジェクト]]の個々のバイトの[[アドレス]]を、
一意に表現できなければならない。
バイトは連続する[[ビット]]の列からなる。
1バイト中のビット数は、[[処理系定義]]とする。
最も[[重み]]の小さいビットを[DFN[[[下位ビット]]]]
(low-order bit) と呼び、最も重みの大きいビットを[DFN[[[上位ビット]]]]
(high‐order bit) と呼ぶ。 [INS[([[JISX3010]]-1993 3.4)]]

[[#comment]]


*アルバイト

[2] [[アルバイト]]のこと。


[[#comment]]


*メモ@


1.6
log
@auto-committed
@
text
@d1 1
a1 1
#?SuikaWiki/0.9
d8 5
@


1.5
log
@auto-committed
@
text
@d11 1
a11 1
一番よく使われているのは、 1 [[KB]] (キロ・バイト) = 1024 B = 2[SUP[10] B
d17 1
a17 1
(例えば 100,000 バイトは 100 バイトでは''ありません''。)
d31 1
a31 1
他の回避法ほして、バイト系の接頭辞に i をつける方法と、
d38 1
a38 1
今後も 10[SUB[3]] 系と 2[SUB[10]] 系の単位による混乱は続くでしょう。
@


1.4
log
@auto-committed
@
text
@d4 4
a7 2
>一つの単位として取り扱う[[ビット]]列。 byte。
([[JISX0211]]-1994 4.2.10)
@


1.3
log
@pre-namespace
@
text
@d41 15
@


1.2
log
@Updated.
@
text
@d1 49
a49 3
一つの単位として取り扱う[[ビット]]列。 byte。
([[JISX0211]]-1994 4.2.10)
- [1] [[アルバイト]]のこと。
@


1.1
log
@Updated.
@
text
@d2 2
a3 1
([[JISX0211]]-1994 4.2.10)@

